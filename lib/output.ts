// Autogenerated, do not edit directly

// CONSTANTS

/**
 * APPLICATION_VERSION
 *
 * @var {string}
 */
export const APPLICATION_VERSION = "23.9.6";

/**
 * APPLICATION_VERSION_MAJOR
 *
 * @var {number}
 */
export const APPLICATION_VERSION_MAJOR = 23;

/**
 * APPLICATION_VERSION_MINOR
 *
 * @var {number}
 */
export const APPLICATION_VERSION_MINOR = 9;

/**
 * APPLICATION_VERSION_REVISION
 *
 * @var {number}
 */
export const APPLICATION_VERSION_REVISION = 6;

/**
 * BACKUPJOBAUTORETENTION_AUTOMATIC
 * AutoRetentionLevel: The system will automatically choose how often to run an automatic Retention Pass after each backup job.
 *
 * @var {number}
 */
export const BACKUPJOBAUTORETENTION_AUTOMATIC = 0;

/**
 * BACKUPJOBAUTORETENTION_IMMEDIATE
 * AutoRetentionLevel: The system will run a Retention Pass after every single backup job. This is more system-intensive, but is the most responsive at freeing storage space.
 *
 * @var {number}
 */
export const BACKUPJOBAUTORETENTION_IMMEDIATE = 1;

/**
 * BACKUPJOBAUTORETENTION_MORE_OFTEN
 * AutoRetentionLevel: The system will follow the automatic ruleset for a 'High Power' device.
 *
 * @var {number}
 */
export const BACKUPJOBAUTORETENTION_MORE_OFTEN = 2;

/**
 * BACKUPJOBAUTORETENTION_LESS_OFTEN
 * AutoRetentionLevel: The system will follow the automatic ruleset for a 'Low Power' device.
 *
 * @var {number}
 */
export const BACKUPJOBAUTORETENTION_LESS_OFTEN = 3;

/**
 * BRANDINGSTYLETYPE_AUTO_LEGACY
 * If set, will be automatically replaced with one of the other BRANDINGSTYLETYPE_ constants after next server upgrade.
 *
 * @var {number}
 */
export const BRANDINGSTYLETYPE_AUTO_LEGACY = 0;

/**
 * BRANDINGSTYLETYPE_DEFAULT
 * Use Comet company branding and colours for all web interface branding
 *
 * @var {number}
 */
export const BRANDINGSTYLETYPE_DEFAULT = 1;

/**
 * BRANDINGSTYLETYPE_CUSTOM_TEXT
 * Use custom branding and colours, with text in the main logo area.
 *
 * @var {number}
 */
export const BRANDINGSTYLETYPE_CUSTOM_TEXT = 2;

/**
 * BRANDINGSTYLETYPE_CUSTOM_LOGO
 * Use custom branding and colours, with a supplied image in the main logo area.
 *
 * @var {number}
 */
export const BRANDINGSTYLETYPE_CUSTOM_LOGO = 3;

/**
 * CLIENTBRANDINGBUILD_CUSTOM
 * ClientBrandingBuildMode: The software client will be custom-built by this Comet Server, allowing custom branding, default server URL, and codesigning.
 *
 * @var {number}
 */
export const CLIENTBRANDINGBUILD_CUSTOM = 0;

/**
 * CLIENTBRANDINGBUILD_PREBUILT
 * ClientBrandingBuildMode: A pre-built software client will be served, with Comet-branding, no server URL, and Comet codesigning.
 *
 * @var {number}
 */
export const CLIENTBRANDINGBUILD_PREBUILT = 1;

/**
 * COMPRESS_INVALID
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_INVALID = 0;

/**
 * COMPRESS_LVL_1
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_LVL_1 = 1;

/**
 * COMPRESS_LVL_2
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_LVL_2 = 2;

/**
 * COMPRESS_LVL_3
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_LVL_3 = 3;

/**
 * COMPRESS_LVL_4
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_LVL_4 = 4;

/**
 * COMPRESS_LVL_5
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_LVL_5 = 5;

/**
 * COMPRESS_MAX
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_MAX = COMPRESS_LVL_5;

/**
 * COMPRESS_DEFAULT
 * CompressMode
 *
 * @var {number}
 */
export const COMPRESS_DEFAULT = COMPRESS_LVL_4;

/**
 * DEFAULT_LANGUAGE
 * LanguageCode
 *
 * @var {string}
 */
export const DEFAULT_LANGUAGE = "en_US";

/**
 * DEFAULT_TIMEZONE
 *
 * @var {string}
 */
export const DEFAULT_TIMEZONE = "UTC";

/**
 * DEFAULT_BRAND_NAME
 *
 * @var {string}
 */
export const DEFAULT_BRAND_NAME = "COMET";

/**
 * DEFAULT_TOPCOLOR
 *
 * @var {string}
 */
export const DEFAULT_TOPCOLOR = "#191F33";

/**
 * DEFAULT_ACCENTCOLOR
 *
 * @var {string}
 */
export const DEFAULT_ACCENTCOLOR = "#D88463";

/**
 * DEFAULT_SESSIONTIMEOUT
 * The default number of seconds for the SessionOptions.ExpiredInSeconds field (30 minutes).
 *
 * @var {number}
 */
export const DEFAULT_SESSIONTIMEOUT = 1800;

/**
 * DESTINATION_SFTP_AUTHMODE_NATIVE
 * SftpAuthMode
 *
 * @var {number}
 */
export const DESTINATION_SFTP_AUTHMODE_NATIVE = 0;

/**
 * DESTINATION_SFTP_AUTHMODE_PASSWORD
 * SftpAuthMode
 *
 * @var {number}
 */
export const DESTINATION_SFTP_AUTHMODE_PASSWORD = 1;

/**
 * DESTINATION_SFTP_AUTHMODE_PRIVATEKEY
 * SftpAuthMode
 *
 * @var {number}
 */
export const DESTINATION_SFTP_AUTHMODE_PRIVATEKEY = 2;

/**
 * DESTINATIONTYPE___INVALID
 *
 * @var {number}
 */
export const DESTINATIONTYPE___INVALID = 0;

/**
 * DESTINATIONTYPE_S3
 * S3-compatible, or a specific S3 service such as AWS S3, Wasabi, or iDrive e2
 *
 * @var {number}
 */
export const DESTINATIONTYPE_S3 = 1000;

/**
 * DESTINATIONTYPE_SFTP
 * SFTP protocol
 *
 * @var {number}
 */
export const DESTINATIONTYPE_SFTP = 1001;

/**
 * DESTINATIONTYPE_LOCALCOPY
 * Local Path
 *
 * @var {number}
 */
export const DESTINATIONTYPE_LOCALCOPY = 1002;

/**
 * DESTINATIONTYPE_COMET
 * The Comet Server Storage Role protocol
 *
 * @var {number}
 */
export const DESTINATIONTYPE_COMET = 1003;

/**
 * DESTINATIONTYPE_FTP
 * FTP protocol
 *
 * @var {number}
 */
export const DESTINATIONTYPE_FTP = 1004;

/**
 * DESTINATIONTYPE_AZUREBLOB
 * Azure Blob Storage
 *
 * @var {number}
 */
export const DESTINATIONTYPE_AZUREBLOB = 1005;

/**
 * DESTINATIONTYPE_SPANNED
 * Spanned
 *
 * @var {number}
 */
export const DESTINATIONTYPE_SPANNED = 1006;

/**
 * DESTINATIONTYPE_SWIFT
 * Openstack Swift
 *
 * @var {number}
 */
export const DESTINATIONTYPE_SWIFT = 1007;

/**
 * DESTINATIONTYPE_B2
 * Backblaze B2 (Native API)
 *
 * @var {number}
 */
export const DESTINATIONTYPE_B2 = 1008;

/**
 * DESTINATIONTYPE_STORJ
 * Storj
 *
 * @var {number}
 */
export const DESTINATIONTYPE_STORJ = 1009;

/**
 * DESTINATIONTYPE_WEBDAV
 *
 * @var {number}
 */
export const DESTINATIONTYPE_WEBDAV = 1010;

/**
 * DESTINATIONTYPE_LATEST
 * When defining a schedule via policy, use this option to dynamically select the Storage Vault that was created most recently.
 *
 * @var {number}
 */
export const DESTINATIONTYPE_LATEST = 1100;

/**
 * DESTINATIONTYPE_ALL
 * When defining a schedule via policy, use this option to create a schedule for each Storage Vault in the user's profile.
 *
 * @var {number}
 */
export const DESTINATIONTYPE_ALL = 1101;

/**
 * EMAIL_WORKER_STATE_NOT_STARTED
 * The Comet Server is still starting up and has not yet checked whether any email reports are due to be sent.
 *
 * @var {number}
 */
export const EMAIL_WORKER_STATE_NOT_STARTED = 0;

/**
 * EMAIL_WORKER_STATE_STARTED
 * The Comet Server is still starting up and has not yet checked whether any email reports are due to be sent.
 *
 * @var {number}
 */
export const EMAIL_WORKER_STATE_STARTED = 1;

/**
 * EMAIL_WORKER_STATE_CALCULATING
 * The Comet Server is currently searching through email report configuration, to determine when the next email report is due to be sent.
 *
 * @var {number}
 */
export const EMAIL_WORKER_STATE_CALCULATING = 2;

/**
 * EMAIL_WORKER_STATE_WAITING
 * The Comet Server knows when the next scheduled email report is due to be sent, and is waiting until that time.
 *
 * @var {number}
 */
export const EMAIL_WORKER_STATE_WAITING = 3;

/**
 * EMAIL_WORKER_STATE_SENDING
 * The Comet Server is currently sending a scheduled email report.
 *
 * @var {number}
 */
export const EMAIL_WORKER_STATE_SENDING = 4;

/**
 * EMAIL_DELIVERY_INHERIT
 * EmailDeliveryType: If this is for the top-level Organization, email is disabled. If this is for an Organization, use the parent's email settings.
 *
 * @var {string}
 */
export const EMAIL_DELIVERY_INHERIT = "";

/**
 * EMAIL_DELIVERY_MX_DIRECT
 * EmailDeliveryType
 *
 * @var {string}
 */
export const EMAIL_DELIVERY_MX_DIRECT = "builtin";

/**
 * EMAIL_DELIVERY_SMTP
 * EmailDeliveryType
 *
 * @var {string}
 */
export const EMAIL_DELIVERY_SMTP = "smtp";

/**
 * EMAIL_DELIVERY_SMTP_SSL
 * EmailDeliveryType
 *
 * @var {string}
 */
export const EMAIL_DELIVERY_SMTP_SSL = "smtp-ssl";

/**
 * EMAIL_DELIVERY_DISABLED
 * EmailDeliveryType
 *
 * @var {string}
 */
export const EMAIL_DELIVERY_DISABLED = "disabled";

/**
 * EMAIL_DELIVERY_BUILTIN
 * EmailDeliveryType: Legacy alias for EMAIL_DELIVERY_MX_DIRECT
 *
 * @var {string}
 */
export const EMAIL_DELIVERY_BUILTIN = EMAIL_DELIVERY_MX_DIRECT;

/**
 * EMAIL_DELIVERY_NONE
 * EmailDeliveryType: Legacy alias for EMAIL_DELIVERY_INHERIT
 *
 * @var {string}
 * @deprecated This const has been deprecated since Comet version 22.12.1
 */
export const EMAIL_DELIVERY_NONE = EMAIL_DELIVERY_INHERIT;

/**
 * EMAILREPORTTYPE_IMMEDIATE
 * EmailReportType
 *
 * @var {number}
 */
export const EMAILREPORTTYPE_IMMEDIATE = 0;

/**
 * EMAILREPORTTYPE_SUMMARY
 * EmailReportType
 *
 * @var {number}
 */
export const EMAILREPORTTYPE_SUMMARY = 1;

/**
 * EMAILREPORTTYPE_GROUPED_STATUS
 * EmailReportType
 *
 * @var {number}
 */
export const EMAILREPORTTYPE_GROUPED_STATUS = 2;

/**
 * EMAILREPORTTYPE_RECENT_ACTIVITY
 * EmailReportType
 *
 * @var {number}
 */
export const EMAILREPORTTYPE_RECENT_ACTIVITY = 3;

/**
 * ENCRYPTIONMETHOD_UNCONFIGURED
 *
 * @var {number}
 */
export const ENCRYPTIONMETHOD_UNCONFIGURED = 0;

/**
 * ENGINE_BUILTIN_FILE
 * Files and Folders
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_FILE = "engine1/file";

/**
 * ENGINE_BUILTIN_STDOUT
 * Program Output
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_STDOUT = "engine1/stdout";

/**
 * ENGINE_BUILTIN_MYSQL
 * MySQL
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_MYSQL = "engine1/mysql";

/**
 * ENGINE_BUILTIN_SYSTEMSTATE
 * Windows Server System State
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_SYSTEMSTATE = "engine1/systemstate";

/**
 * ENGINE_BUILTIN_MSSQL
 * Microsoft SQL Server
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_MSSQL = "engine1/mssql";

/**
 * ENGINE_BUILTIN_WINDOWSSYSTEM
 * Windows System Backup
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_WINDOWSSYSTEM = "engine1/windowssystem";

/**
 * ENGINE_BUILTIN_EXCHANGEEDB
 * Microsoft Exchange Server
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_EXCHANGEEDB = "engine1/exchangeedb";

/**
 * ENGINE_BUILTIN_VSSWRITER
 * Application-Aware Writer
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_VSSWRITER = "engine1/vsswriter";

/**
 * ENGINE_BUILTIN_HYPERV
 * Microsoft Hyper-V
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_HYPERV = "engine1/hyperv";

/**
 * ENGINE_BUILTIN_WINDISK
 * Disk Image
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_WINDISK = "engine1/windisk";

/**
 * ENGINE_BUILTIN_MONGODB
 * MongoDB
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_MONGODB = "engine1/mongodb";

/**
 * ENGINE_BUILTIN_MSOFFICE
 * Office 365
 *
 * @var {string}
 */
export const ENGINE_BUILTIN_MSOFFICE = "engine1/winmsofficemail";

/**
 * FTPS_MODE_PLAINTEXT
 * FtpsModeType: Use plain FTP, do not use FTPS.
 *
 * @var {number}
 */
export const FTPS_MODE_PLAINTEXT = 0;

/**
 * FTPS_MODE_IMPLICIT
 * FtpsModeType: Use implicit FTPS, immediately creating a secure SSL/TLS channel before any data is sent. This usually requires a different port on the FTP server. It is generally advised to use explicit mode instead.
 *
 * @var {number}
 */
export const FTPS_MODE_IMPLICIT = 1;

/**
 * FTPS_MODE_EXPLICIT
 * FtpsModeType: Use explicit FTPS, first creating an insecure connection and then upgrading to SSL/TLS using AUTH TLS (like STARTTLS).
 *
 * @var {number}
 */
export const FTPS_MODE_EXPLICIT = 2;

/**
 * JOB_CLASSIFICATION__MIN
 * JobClassification: All BackupJobDetail.Classification fields will fall in the 4xxx range.
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION__MIN = 4000;

/**
 * JOB_CLASSIFICATION_UNKNOWN
 * JobClassification
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_UNKNOWN = 4000;

/**
 * JOB_CLASSIFICATION_BACKUP
 * JobClassification: This is a backup job.
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_BACKUP = 4001;

/**
 * JOB_CLASSIFICATION_RESTORE
 * JobClassification: This is a restore job.
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_RESTORE = 4002;

/**
 * JOB_CLASSIFICATION_RETENTION
 * JobClassification: Automatic or manual retention cleaning pass.
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_RETENTION = 4003;

/**
 * JOB_CLASSIFICATION_UNLOCK
 * JobClassification: Another process needed exclusive Vault access (e.g. for retention) but the process died. This task cleans up exclusive lockfiles.
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_UNLOCK = 4004;

/**
 * JOB_CLASSIFICATION_DELETE_CUSTOM
 * JobClassification: A specific snapshot has been deleted via the Restore wizard.
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_DELETE_CUSTOM = 4005;

/**
 * JOB_CLASSIFICATION_REMEASURE
 * JobClassification: Explicitly re-measuring the size of a Vault (right-click > Advanced menu).
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_REMEASURE = 4006;

/**
 * JOB_CLASSIFICATION_UPDATE
 * JobClassification: Software update
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_UPDATE = 4007;

/**
 * JOB_CLASSIFICATION_IMPORT
 * JobClassification: Importing settings from another installed product
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_IMPORT = 4008;

/**
 * JOB_CLASSIFICATION_REINDEX
 * JobClassification: Repair indexes
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_REINDEX = 4009;

/**
 * JOB_CLASSIFICATION_DEEPVERIFY
 * JobClassification: Deep Verify
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_DEEPVERIFY = 4010;

/**
 * JOB_CLASSIFICATION_UNINSTALL
 * JobClassification: Software uninstall
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION_UNINSTALL = 4011;

/**
 * JOB_CLASSIFICATION__MAX
 * JobClassification
 *
 * @var {number}
 */
export const JOB_CLASSIFICATION__MAX = 4999;

/**
 * JOB_STATUS_STOP_SUCCESS__MIN
 * JobStatus: If the BackupJobDetail.Status field is a 5xxx code, the job has stopped for a successful reason.
 *
 * @var {number}
 */
export const JOB_STATUS_STOP_SUCCESS__MIN = 5000;

/**
 * JOB_STATUS_STOP_SUCCESS
 * JobStatus: The job is complete and was successful.
 *
 * @var {number}
 */
export const JOB_STATUS_STOP_SUCCESS = 5000;

/**
 * JOB_STATUS_STOP_SUCCESS__MAX
 * JobStatus
 *
 * @var {number}
 */
export const JOB_STATUS_STOP_SUCCESS__MAX = 5999;

/**
 * JOB_STATUS_RUNNING__MIN
 * JobStatus: If the BackupJobDetail.Status field is a 6xxx code, the job is still running.
 *
 * @var {number}
 */
export const JOB_STATUS_RUNNING__MIN = 6000;

/**
 * JOB_STATUS_RUNNING_INDETERMINATE
 * JobStatus: Unused
 *
 * @var {number}
 */
export const JOB_STATUS_RUNNING_INDETERMINATE = 6000;

/**
 * JOB_STATUS_RUNNING_ACTIVE
 * JobStatus: The last information the server received from the device is that the job is currently running.
 *
 * @var {number}
 */
export const JOB_STATUS_RUNNING_ACTIVE = 6001;

/**
 * JOB_STATUS_RUNNING_REVIVED
 * JobStatus: The job was thought to have been in an Abandoned state but updated the Comet Server with a running status.
 *
 * @var {number}
 */
export const JOB_STATUS_RUNNING_REVIVED = 6002;

/**
 * JOB_STATUS_RUNNING__MAX
 * JobStatus
 *
 * @var {number}
 */
export const JOB_STATUS_RUNNING__MAX = 6999;

/**
 * JOB_STATUS_FAILED__MIN
 * JobStatus: If the BackupJobDetail.Status field is a 7xxx code, the job has stopped for an unsuccessful reason.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED__MIN = 7000;

/**
 * JOB_STATUS_FAILED_TIMEOUT
 * JobStatus
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_TIMEOUT = 7000;

/**
 * JOB_STATUS_FAILED_WARNING
 * JobStatus: The job is complete but there was a problem that may have resulted in issues with the expected result.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_WARNING = 7001;

/**
 * JOB_STATUS_FAILED_ERROR
 * JobStatus: There was an error during the job and it did not fully complete.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_ERROR = 7002;

/**
 * JOB_STATUS_FAILED_QUOTA
 * JobStatus: During a backup job either the "All protected items" quota or "Storage Vault" quota was exceeded.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_QUOTA = 7003;

/**
 * JOB_STATUS_FAILED_SCHEDULEMISSED
 * JobStatus: The job did not start at its scheduled time.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_SCHEDULEMISSED = 7004;

/**
 * JOB_STATUS_FAILED_CANCELLED
 * JobStatus: The job was cancelled manually, a device shutdown was detected, or the backup time limit was reached.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_CANCELLED = 7005;

/**
 * JOB_STATUS_FAILED_SKIPALREADYRUNNING
 * JobStatus: The backup job was skipped as there was already a backup running and the "Skip if already running" option was enabled.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_SKIPALREADYRUNNING = 7006;

/**
 * JOB_STATUS_FAILED_ABANDONED
 * JobStatus: The job has stopped unexpectedly or has been manually marked as abandoned by an admin.
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED_ABANDONED = 7007;

/**
 * JOB_STATUS_FAILED__MAX
 * JobStatus
 *
 * @var {number}
 */
export const JOB_STATUS_FAILED__MAX = 7999;

/**
 * LDAPSECURITYMETHOD_PLAIN
 * LDAPSecurityMethod
 *
 * @var {string}
 */
export const LDAPSECURITYMETHOD_PLAIN = "plain";

/**
 * LDAPSECURITYMETHOD_LDAPS
 * LDAPSecurityMethod
 *
 * @var {string}
 */
export const LDAPSECURITYMETHOD_LDAPS = "ldaps";

/**
 * LDAPSECURITYMETHOD_STARTTLS
 * LDAPSecurityMethod
 *
 * @var {string}
 */
export const LDAPSECURITYMETHOD_STARTTLS = "starttls";

/**
 * LEGACY_TOPCOLOR
 *
 * @var {string}
 */
export const LEGACY_TOPCOLOR = "#06041E";

/**
 * LOGOIMAGE_NONE
 * LogoImageType
 *
 * @var {number}
 */
export const LOGOIMAGE_NONE = 1;

/**
 * LOGOIMAGE_AS_PER_FILE
 * LogoImageType
 *
 * @var {number}
 */
export const LOGOIMAGE_AS_PER_FILE = 2;

/**
 * LOGOIMAGE_COMETEMBEDDED
 * LogoImageType
 *
 * @var {number}
 */
export const LOGOIMAGE_COMETEMBEDDED = 3;

/**
 * MACOSCODESIGN_LEVEL_SIGN
 * MacOSCodesignLevel: Sign only
 *
 * @var {number}
 */
export const MACOSCODESIGN_LEVEL_SIGN = 0;

/**
 * MACOSCODESIGN_LEVEL_SIGN_NOTARISE
 * MacOSCodesignLevel: Sign and notarize
 *
 * @var {number}
 */
export const MACOSCODESIGN_LEVEL_SIGN_NOTARISE = 1;

/**
 * MACOSCODESIGN_LEVEL_SIGN_NOTARISE_STAPLE
 * MacOSCodesignLevel: Sign, notarize, and staple
 *
 * @var {number}
 */
export const MACOSCODESIGN_LEVEL_SIGN_NOTARISE_STAPLE = 2;

/**
 * MINIMUM_LOG_RETENTION_DAYS
 *
 * @var {number}
 */
export const MINIMUM_LOG_RETENTION_DAYS = 10;

/**
 * MIXED_VIRTUAL_ACCOUNT_TYPE_USER
 *
 * @var {number}
 */
export const MIXED_VIRTUAL_ACCOUNT_TYPE_USER = 1;

/**
 * MIXED_VIRTUAL_ACCOUNT_TYPE_GROUP
 *
 * @var {number}
 */
export const MIXED_VIRTUAL_ACCOUNT_TYPE_GROUP = 2;

/**
 * MIXED_VIRTUAL_ACCOUNT_TYPE_TEAM_GROUP
 *
 * @var {number}
 */
export const MIXED_VIRTUAL_ACCOUNT_TYPE_TEAM_GROUP = 3;

/**
 * MIXED_VIRTUAL_ACCOUNT_TYPE_SHAREPOINT_ONLY
 *
 * @var {number}
 */
export const MIXED_VIRTUAL_ACCOUNT_TYPE_SHAREPOINT_ONLY = 4;

/**
 * MONGODB_DEFAULT_PORT
 *
 * @var {number}
 */
export const MONGODB_DEFAULT_PORT = 27017;

/**
 * MSSQL_AUTH_WINDOWS
 * MSSQLAuthMode
 *
 * @var {string}
 */
export const MSSQL_AUTH_WINDOWS = "windows";

/**
 * MSSQL_AUTH_NATIVE
 * MSSQLAuthMode
 *
 * @var {string}
 */
export const MSSQL_AUTH_NATIVE = "native";

/**
 * MSSQL_METHOD_OLEDB_NATIVE
 * MSSQLMethod: On Windows x86_64, use the native x86_64 driver.
 *
 * @var {string}
 */
export const MSSQL_METHOD_OLEDB_NATIVE = "OLEDB_NATIVE";

/**
 * MSSQL_METHOD_OLEDB_32
 * MSSQLMethod: On Windows x86_64, use an x86_32 OLEDB driver.
 *
 * @var {string}
 */
export const MSSQL_METHOD_OLEDB_32 = "OLEDB_32";

/**
 * MSSQL_RESTORE_RECOVERY
 * MSSQLRestoreOpt
 *
 * @var {string}
 */
export const MSSQL_RESTORE_RECOVERY = "RECOVERY";

/**
 * MSSQL_RESTORE_NORECOVERY
 * MSSQLRestoreOpt
 *
 * @var {string}
 */
export const MSSQL_RESTORE_NORECOVERY = "NO_RECOVERY";

/**
 * OBJECT_LOCK_LEGACY
 *
 * @var {number}
 */
export const OBJECT_LOCK_LEGACY = 0;

/**
 * OBJECT_LOCK_ON
 *
 * @var {number}
 */
export const OBJECT_LOCK_ON = 1;

/**
 * OBJECT_LOCK_OFF
 *
 * @var {number}
 */
export const OBJECT_LOCK_OFF = 2;

/**
 * OFFICE365_REGION_PUBLIC
 *
 * @var {string}
 */
export const OFFICE365_REGION_PUBLIC = "GlobalPublicCloud";

/**
 * OFFICE365_REGION_CHINA
 *
 * @var {string}
 */
export const OFFICE365_REGION_CHINA = "ChinaCloud";

/**
 * OFFICE365_REGION_GERMANY
 *
 * @var {string}
 */
export const OFFICE365_REGION_GERMANY = "GermanCloud";

/**
 * OFFICE365_REGION_US_GOVT
 *
 * @var {string}
 */
export const OFFICE365_REGION_US_GOVT = "USGovtGccCloud";

/**
 * OFFICE365_REGION_US_DOD
 *
 * @var {string}
 */
export const OFFICE365_REGION_US_DOD = "USGovtGccDoDCloud";

/**
 * OS_ANY
 * ExtraFileExclusionOSRestriction: Applies to any device
 *
 * @var {number}
 */
export const OS_ANY = 0;

/**
 * OS_ONLY_WINDOWS
 * ExtraFileExclusionOSRestriction: Applies to all Windows devices, regardless of CPU type
 *
 * @var {number}
 */
export const OS_ONLY_WINDOWS = 1;

/**
 * OS_ONLY_WINDOWS_X8632
 * ExtraFileExclusionOSRestriction: Applies to Windows devices with x86_32 CPU
 *
 * @var {number}
 */
export const OS_ONLY_WINDOWS_X8632 = 2;

/**
 * OS_ONLY_WINDOWS_X8664
 * ExtraFileExclusionOSRestriction: Applies to Windows devices with x86_64 CPU
 *
 * @var {number}
 */
export const OS_ONLY_WINDOWS_X8664 = 3;

/**
 * OS_ONLY_MACOS
 * ExtraFileExclusionOSRestriction: Applies to macOS devices, regardless of CPU type
 *
 * @var {number}
 */
export const OS_ONLY_MACOS = 4;

/**
 * OS_ONLY_LINUX
 * ExtraFileExclusionOSRestriction: Applies to Linux devices (including Synology DSM), regardless of CPU type
 *
 * @var {number}
 */
export const OS_ONLY_LINUX = 5;

/**
 * PASSWORD_FORMAT_PLAINTEXT
 * When resetting a password with the API, set the PasswordFormat to this value. The Comet Server will re-hash the credential automatically.
 *
 * @var {number}
 */
export const PASSWORD_FORMAT_PLAINTEXT = 0;

/**
 * PROVIDER_GENERIC
 * OidcProvider
 *
 * @var {string}
 */
export const PROVIDER_GENERIC = "oidc";

/**
 * PROVIDER_AZUREADV2
 * OidcProvider
 *
 * @var {string}
 */
export const PROVIDER_AZUREADV2 = "azure-ad-v2";

/**
 * PROVIDER_GOOGLE
 * OidcProvider
 *
 * @var {string}
 */
export const PROVIDER_GOOGLE = "google";

/**
 * PSA_TYPE_GENERIC
 * PSAType
 *
 * @var {number}
 */
export const PSA_TYPE_GENERIC = 0;

/**
 * PSA_TYPE_GRADIENT
 * PSAType
 *
 * @var {number}
 */
export const PSA_TYPE_GRADIENT = 1;

/**
 * RELEASE_CODENAME
 *
 * @var {string}
 */
export const RELEASE_CODENAME = "Voyager";

/**
 * REMOTESERVER_COMET
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_COMET = "comet";

/**
 * REMOTESERVER_COMET_STORAGE
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_COMET_STORAGE = "cometstorage";

/**
 * REMOTESERVER_LDAP
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_LDAP = "ldap";

/**
 * REMOTESERVER_OIDC
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_OIDC = "oidc";

/**
 * REMOTESERVER_B2
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_B2 = "b2";

/**
 * REMOTESERVER_WASABI
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_WASABI = "wasabi";

/**
 * REMOTESERVER_CUSTOM
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_CUSTOM = "custom";

/**
 * REMOTESERVER_S3_GENERIC
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_S3_GENERIC = "s3";

/**
 * REMOTESERVER_AWS
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_AWS = "aws";

/**
 * REMOTESERVER_STORJ
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_STORJ = "storj";

/**
 * REMOTESERVER_IDRIVEE2
 * RemoteServerType
 *
 * @var {string}
 */
export const REMOTESERVER_IDRIVEE2 = "idrivee2";

/**
 * REPLICADELETION_NONE
 * ReplicaDeletionStrategy
 *
 * @var {string}
 */
export const REPLICADELETION_NONE = "none";

/**
 * REPLICADELETION_CIRCULAR
 * ReplicaDeletionStrategy
 *
 * @var {string}
 */
export const REPLICADELETION_CIRCULAR = "circular";

/**
 * REPLICADELETION_COMPLETE
 * ReplicaDeletionStrategy
 *
 * @var {string}
 */
export const REPLICADELETION_COMPLETE = "complete";

/**
 * REPLICATOR_STATE_NONE
 * ReplicatorState
 *
 * @var {number}
 */
export const REPLICATOR_STATE_NONE = 0;

/**
 * REPLICATOR_STATE_FILE_LIST_WORKER_STARTED
 * ReplicatorState
 *
 * @var {number}
 */
export const REPLICATOR_STATE_FILE_LIST_WORKER_STARTED = 1;

/**
 * REPLICATOR_STATE_FILE_LIST_SYNC_RUNNING
 * ReplicatorState
 *
 * @var {number}
 */
export const REPLICATOR_STATE_FILE_LIST_SYNC_RUNNING = 2;

/**
 * REPLICATOR_STATE_FILE_LIST_SYNC_FINISHED
 * ReplicatorState
 *
 * @var {number}
 */
export const REPLICATOR_STATE_FILE_LIST_SYNC_FINISHED = 4;

/**
 * REPLICATOR_STATE_WORKERS_STARTED
 * ReplicatorState
 *
 * @var {number}
 */
export const REPLICATOR_STATE_WORKERS_STARTED = 8;

/**
 * REPLICATOR_DISPLAYCLASS_STORAGE
 * ReplicatorDisplayClass
 *
 * @var {number}
 */
export const REPLICATOR_DISPLAYCLASS_STORAGE = 100;

/**
 * REPLICATOR_DISPLAYCLASS_USER
 * ReplicatorDisplayClass
 *
 * @var {number}
 */
export const REPLICATOR_DISPLAYCLASS_USER = 101;

/**
 * RESTOREARCHIVEFORMAT_TAR
 * RestoreArchiveFormat: Tar file format
 *
 * @var {number}
 */
export const RESTOREARCHIVEFORMAT_TAR = 0;

/**
 * RESTOREARCHIVEFORMAT_TARGZ
 * RestoreArchiveFormat: Compressed Tar.gz (.tgz) file format
 *
 * @var {number}
 */
export const RESTOREARCHIVEFORMAT_TARGZ = 1;

/**
 * RESTOREARCHIVEFORMAT_ZIP
 * RestoreArchiveFormat: Zip file format
 *
 * @var {number}
 */
export const RESTOREARCHIVEFORMAT_ZIP = 2;

/**
 * RESTOREARCHIVEFORMAT_SQFS
 * RestoreArchiveFormat: SquashFS container
 *
 * @var {number}
 */
export const RESTOREARCHIVEFORMAT_SQFS = 3;

/**
 * RESTOREARCHIVEFORMAT_TARZSTD
 * RestoreArchiveFormat: Compressed Tar.zstd (.tzst) file format
 *
 * @var {number}
 */
export const RESTOREARCHIVEFORMAT_TARZSTD = 4;

/**
 * RESTORETYPE_INVALID
 * RestoreType
 *
 * @var {number}
 */
export const RESTORETYPE_INVALID = -1;

/**
 * RESTORETYPE_FILE
 * RestoreType: Restore as files and folders
 *
 * @var {number}
 */
export const RESTORETYPE_FILE = 0;

/**
 * RESTORETYPE_NULL
 * RestoreType: Download and reconstruct files, but do not save them (for test purposes)
 *
 * @var {number}
 */
export const RESTORETYPE_NULL = 1;

/**
 * RESTORETYPE_PROCESS_PERFILE
 * RestoreType: Stream each restored file into the target command stdin. The target command may be executed multiple times, once for each restored file.
 *
 * @var {number}
 */
export const RESTORETYPE_PROCESS_PERFILE = 2;

/**
 * RESTORETYPE_PROCESS_ARCHIVE
 * RestoreType: Stream an archive of each restored file into the target command stdin. The target command will be executed only once.
 *
 * @var {number}
 */
export const RESTORETYPE_PROCESS_ARCHIVE = 3;

/**
 * RESTORETYPE_WINDISK
 * RestoreType: Restore partitions back to the physical disk
 *
 * @var {number}
 */
export const RESTORETYPE_WINDISK = 4;

/**
 * RESTORETYPE_FILE_ARCHIVE
 * RestoreType: Restore selected files and folders as a single compressed archive
 *
 * @var {number}
 */
export const RESTORETYPE_FILE_ARCHIVE = 5;

/**
 * RESTORETYPE_OFFICE365_CLOUD
 * RestoreType: Restore selected Office 365 emails, contacts, calendars, and SharePoint/OneDrive data directly to the Office 365 cloud service
 *
 * @var {number}
 */
export const RESTORETYPE_OFFICE365_CLOUD = 6;

/**
 * RESTORETYPE_VMDK_FILE
 * RestoreType: Granular restore of single files from within a Disk Image or Hyper-V backup
 *
 * @var {number}
 */
export const RESTORETYPE_VMDK_FILE = 7;

/**
 * RESTORETYPE_VMDK_FILE_NULL
 * RestoreType: Granular restore of single files from within a Disk Image or Hyper-V backup, downloading and reconstructing files, but without saving them (for test purposes)
 *
 * @var {number}
 */
export const RESTORETYPE_VMDK_FILE_NULL = 8;

/**
 * RESTORETYPE_VMDK_FILE_ARCHIVE
 * RestoreType: Granular restore of single files from within a Disk Image or Hyper-V backup, creating an archive file of all selected files
 *
 * @var {number}
 */
export const RESTORETYPE_VMDK_FILE_ARCHIVE = 9;

/**
 * RESTORETYPE_MYSQL
 * RestoreType: Stream restore as SQL statements into a target MySQL server
 *
 * @var {number}
 */
export const RESTORETYPE_MYSQL = 10;

/**
 * RESTORETYPE_MSSQL
 * RestoreType: Stream restore as T-SQL BACKUP output into a target Microsoft SQL Server
 *
 * @var {number}
 */
export const RESTORETYPE_MSSQL = 11;

/**
 * RESTORETYPE_WINDISK_ESXI
 * RestoreType: Restore disk image backup as VMware-compatible virtual disks
 *
 * @var {number}
 */
export const RESTORETYPE_WINDISK_ESXI = 12;

/**
 * RESTORETYPE_PROCESS_TARBALL
 * RestoreType: Legacy name alias - Prefer to use RESTORETYPE_PROCESS_ARCHIVE since multiple archive file formats are supported within this single RESTORETYPE_
 *
 * @var {number}
 */
export const RESTORETYPE_PROCESS_TARBALL = 3;

/**
 * RETENTIONMODE_KEEP_EVERYTHING
 * RetentionMode: If this mode is set in a RetentionPolicy, then RetentionPolicy.Ranges should be ignored.
 *
 * @var {number}
 */
export const RETENTIONMODE_KEEP_EVERYTHING = 801;

/**
 * RETENTIONMODE_DELETE_EXCEPT
 * RetentionMode: Delete everything except for jobs matching the ranges in RetentionPolicy.Ranges.
 *
 * @var {number}
 */
export const RETENTIONMODE_DELETE_EXCEPT = 802;

/**
 * RETENTIONRANGE__LOWEST
 * RetentionRangeType
 *
 * @var {number}
 */
export const RETENTIONRANGE__LOWEST = 900;

/**
 * RETENTIONRANGE_MOST_RECENT_X_JOBS
 * RetentionRangeType: Uses Jobs
 *
 * @var {number}
 */
export const RETENTIONRANGE_MOST_RECENT_X_JOBS = 900;

/**
 * RETENTIONRANGE_NEWER_THAN_X
 * RetentionRangeType: Uses Timestamp
 *
 * @var {number}
 */
export const RETENTIONRANGE_NEWER_THAN_X = 901;

/**
 * RETENTIONRANGE_JOBS_SINCE
 * RetentionRangeType: Uses Days, Weeks, Months
 *
 * @var {number}
 */
export const RETENTIONRANGE_JOBS_SINCE = 902;

/**
 * RETENTIONRANGE_FIRST_JOB_FOR_EACH_LAST_X_DAYS
 * RetentionRangeType: Uses Days
 *
 * @var {number}
 */
export const RETENTIONRANGE_FIRST_JOB_FOR_EACH_LAST_X_DAYS = 903;

/**
 * RETENTIONRANGE__RESERVED904
 * RetentionRangeType
 *
 * @var {number}
 * @deprecated This const has been deprecated since Comet version 17.2.0
 */
export const RETENTIONRANGE__RESERVED904 = 904;

/**
 * RETENTIONRANGE_FIRST_JOB_FOR_LAST_X_MONTHS
 * RetentionRangeType: Uses Months, MonthOffset
 *
 * @var {number}
 */
export const RETENTIONRANGE_FIRST_JOB_FOR_LAST_X_MONTHS = 905;

/**
 * RETENTIONRANGE_FIRST_JOB_FOR_LAST_X_WEEKS
 * RetentionRangeType: Uses Weeks, WeekOffset
 *
 * @var {number}
 */
export const RETENTIONRANGE_FIRST_JOB_FOR_LAST_X_WEEKS = 906;

/**
 * RETENTIONRANGE_LAST_X_BACKUPS_ONE_FOR_EACH_DAY
 * RetentionRangeType: Uses Jobs
 *
 * @var {number}
 */
export const RETENTIONRANGE_LAST_X_BACKUPS_ONE_FOR_EACH_DAY = 907;

/**
 * RETENTIONRANGE_LAST_X_BACKUPS_ONE_FOR_EACH_WEEK
 * RetentionRangeType: Uses Jobs
 *
 * @var {number}
 */
export const RETENTIONRANGE_LAST_X_BACKUPS_ONE_FOR_EACH_WEEK = 908;

/**
 * RETENTIONRANGE_LAST_X_BACKUPS_ONE_FOR_EACH_MONTH
 * RetentionRangeType: Uses Jobs
 *
 * @var {number}
 */
export const RETENTIONRANGE_LAST_X_BACKUPS_ONE_FOR_EACH_MONTH = 909;

/**
 * RETENTIONRANGE__HIGHEST
 * RetentionRangeType
 *
 * @var {number}
 */
export const RETENTIONRANGE__HIGHEST = 909;

/**
 * RETENTIONRANGE_MAXINT
 *
 * @var {number}
 */
export const RETENTIONRANGE_MAXINT = 1125899906842624;

/**
 * SCHEDULE_FREQUENCY_LOWEST
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_LOWEST = 8010;

/**
 * SCHEDULE_FREQUENCY_ONCEONLY
 * SecondsPast should be a Unix timestamp, in seconds
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_ONCEONLY = 8010;

/**
 * SCHEDULE_FREQUENCY_DAILY
 * SecondsPast is the number of seconds past 00:00, in the device's local timezone.
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_DAILY = 8011;

/**
 * SCHEDULE_FREQUENCY_HOURLY
 * SecondsPast is the number of seconds past *:00, in the device's local timezone.
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_HOURLY = 8012;

/**
 * SCHEDULE_FREQUENCY_WEEKLY
 * SecondsPast is the number of seconds past 00:00 Sunday, in the device's local timezone.
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_WEEKLY = 8013;

/**
 * SCHEDULE_FREQUENCY_MONTHLY
 * SecondsPast is the number of seconds past 00:00 1st, in the device's local timezone.
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_MONTHLY = 8014;

/**
 * SCHEDULE_FREQUENCY_PERIODIC
 * SecondsPast is the number of seconds per period. Offset: Shunt seconds after unix epoch
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_PERIODIC = 8015;

/**
 * SCHEDULE_FREQUENCY_HIGHEST
 *
 * @var {number}
 */
export const SCHEDULE_FREQUENCY_HIGHEST = 8015;

/**
 * SCHEDULE_MAX_RANDOM_DELAY_SECS
 * Maximum random delay (5 hours)
 *
 * @var {number}
 */
export const SCHEDULE_MAX_RANDOM_DELAY_SECS = 18000;

/**
 * SCHEDULE_MAXINT
 *
 * @var {number}
 */
export const SCHEDULE_MAXINT = 1125899906842624;

/**
 * SEARCHCLAUSE_RULE
 * SearchClauseType: The search clause is an explicit rule
 *
 * @var {string}
 */
export const SEARCHCLAUSE_RULE = "";

/**
 * SEARCHCLAUSE_AND
 * SearchClauseType: All of the ClauseChildren must match
 *
 * @var {string}
 */
export const SEARCHCLAUSE_AND = "and";

/**
 * SEARCHCLAUSE_OR
 * SearchClauseType: At least one of the ClauseChildren must match
 *
 * @var {string}
 */
export const SEARCHCLAUSE_OR = "or";

/**
 * SEARCHCLAUSE_NOT_AND
 * SearchClauseType
 *
 * @var {string}
 */
export const SEARCHCLAUSE_NOT_AND = "not_and";

/**
 * SEARCHCLAUSE_NOT_OR
 * SearchClauseType
 *
 * @var {string}
 */
export const SEARCHCLAUSE_NOT_OR = "not_or";

/**
 * SEARCHOPERATOR_STRING_EQ
 * String equals (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_EQ = "str_eq";

/**
 * SEARCHOPERATOR_STRING_NEQ
 * String does not equal (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NEQ = "str_neq";

/**
 * SEARCHOPERATOR_STRING_CONTAINS
 * String contains anywhere (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_CONTAINS = "str_contains";

/**
 * SEARCHOPERATOR_STRING_NCONTAINS
 * String does not contain anywhere (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NCONTAINS = "str_ncontains";

/**
 * SEARCHOPERATOR_STRING_STARTSWITH
 * String starts with prefix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_STARTSWITH = "str_startswith";

/**
 * SEARCHOPERATOR_STRING_NSTARTSWITH
 * String does not start with prefix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NSTARTSWITH = "str_nstartswith";

/**
 * SEARCHOPERATOR_STRING_ENDSWITH
 * String ends with suffix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_ENDSWITH = "str_endswith";

/**
 * SEARCHOPERATOR_STRING_NENDSWITH
 * String does not end with suffix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NENDSWITH = "str_nendswith";

/**
 * SEARCHOPERATOR_STRING_EQ_CI
 * String equals (case insensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_EQ_CI = "str_eq_ci";

/**
 * SEARCHOPERATOR_STRING_NEQ_CI
 * String does not equal (case insensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NEQ_CI = "str_neq_ci";

/**
 * SEARCHOPERATOR_STRING_CONTAINS_CI
 * String contains anywhere (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_CONTAINS_CI = "str_contains_ci";

/**
 * SEARCHOPERATOR_STRING_NCONTAINS_CI
 * String does not contain anywhere (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NCONTAINS_CI = "str_ncontains_ci";

/**
 * SEARCHOPERATOR_STRING_STARTSWITH_CI
 * String starts with prefix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_STARTSWITH_CI = "str_startswith_ci";

/**
 * SEARCHOPERATOR_STRING_NSTARTSWITH_CI
 * String does not start with (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NSTARTSWITH_CI = "str_nstartswith_ci";

/**
 * SEARCHOPERATOR_STRING_ENDSWITH_CI
 * String ends with suffix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_ENDSWITH_CI = "str_endswith_ci";

/**
 * SEARCHOPERATOR_STRING_NENDSWITH_CI
 * String does not end with suffix (case sensitive)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NENDSWITH_CI = "str_nendswith_ci";

/**
 * SEARCHOPERATOR_STRING_REGEXMATCH
 * String matches provided regular expression (using Go regex syntax)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_REGEXMATCH = "str_regexmatch";

/**
 * SEARCHOPERATOR_STRING_NREGEXMATCH
 * String does not match provided regular expression (using Go regex syntax)
 *
 * @var {string}
 */
export const SEARCHOPERATOR_STRING_NREGEXMATCH = "str_nregexmatch";

/**
 * SEARCHOPERATOR_INT_EQ
 * Integer field is equal to value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_INT_EQ = "int_eq";

/**
 * SEARCHOPERATOR_INT_NEQ
 * Integer field is not equal to value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_INT_NEQ = "int_neq";

/**
 * SEARCHOPERATOR_INT_GT
 * Integer field is greater than value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_INT_GT = "int_gt";

/**
 * SEARCHOPERATOR_INT_GTE
 * Integer field is greater than or equal to value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_INT_GTE = "int_gte";

/**
 * SEARCHOPERATOR_INT_LT
 * Integer field is less than value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_INT_LT = "int_lt";

/**
 * SEARCHOPERATOR_INT_LTE
 * Integer field is less than or equal to value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_INT_LTE = "int_lte";

/**
 * SEARCHOPERATOR_BOOL_IS
 * Boolean field matches value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_BOOL_IS = "bool_is";

/**
 * SEARCHOPERATOR_BOOL_NIS
 * Boolean field does not match value
 *
 * @var {string}
 */
export const SEARCHOPERATOR_BOOL_NIS = "bool_nis";

/**
 * SERVICE_CALENDAR
 * 0000 0001. If this value is present in the bitset, then the Calendar service is selected for backup.
 *
 * @var {number}
 */
export const SERVICE_CALENDAR = 1;

/**
 * SERVICE_CONTACT
 * 0000 0010. If this value is present in the bitset, then the Contact service is selected for backup.
 *
 * @var {number}
 */
export const SERVICE_CONTACT = 2;

/**
 * SERVICE_MAIL
 * 0000 0100. If this value is present in the bitset, then the Mail service is selected for backup.
 *
 * @var {number}
 */
export const SERVICE_MAIL = 4;

/**
 * SERVICE_SHAREPOINT
 * 0000 1000. If this value is present in the bitset, then the SharePoint service is selected for backup.
 *
 * @var {number}
 */
export const SERVICE_SHAREPOINT = 8;

/**
 * SERVICE_ONEDRIVE
 * 0001 0000. If this value is present in the bitset, then the OneDrive service is selected for backup.
 *
 * @var {number}
 */
export const SERVICE_ONEDRIVE = 16;

/**
 * SETTING_SYSTEM_DEFAULT
 * DefaultSettingMode
 *
 * @var {number}
 */
export const SETTING_SYSTEM_DEFAULT = 0;

/**
 * SETTING_OPTIONAL_DEFAULT_ON
 * DefaultSettingMode
 *
 * @var {number}
 */
export const SETTING_OPTIONAL_DEFAULT_ON = 1;

/**
 * SETTING_OPTIONAL_DEFAULT_OFF
 * DefaultSettingMode
 *
 * @var {number}
 */
export const SETTING_OPTIONAL_DEFAULT_OFF = 2;

/**
 * SETTING_ENFORCED_ON
 * DefaultSettingMode
 *
 * @var {number}
 */
export const SETTING_ENFORCED_ON = 3;

/**
 * SETTING_ENFORCED_OFF
 * DefaultSettingMode
 *
 * @var {number}
 */
export const SETTING_ENFORCED_OFF = 4;

/**
 * SEVERITY_INFO
 * Severity
 *
 * @var {string}
 */
export const SEVERITY_INFO = "I";

/**
 * SEVERITY_WARNING
 * Severity
 *
 * @var {string}
 */
export const SEVERITY_WARNING = "W";

/**
 * SEVERITY_ERROR
 * Severity
 *
 * @var {string}
 */
export const SEVERITY_ERROR = "E";

/**
 * SEVT__MIN
 * StreamableEventType
 *
 * @var {number}
 */
export const SEVT__MIN = 4000;

/**
 * SEVT_META_HELLO
 * StreamableEventType: New event stream connection. Data is typically ServerMetaVersionInfo
 *
 * @var {number}
 */
export const SEVT_META_HELLO = 4000;

/**
 * SEVT_ACCOUNT_NEW
 * StreamableEventType: User created. Data is the profile object
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_NEW = 4100;

/**
 * SEVT_ACCOUNT_REMOVED
 * StreamableEventType: User deleted
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_REMOVED = 4101;

/**
 * SEVT_ACCOUNT_UPDATED
 * StreamableEventType: User updated. Data is the profile object
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_UPDATED = 4102;

/**
 * SEVT_ACCOUNT_LOGIN
 * StreamableEventType: User authentication succeeded. Only emitted for non-session requests. Resource is the requested path
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_LOGIN = 4103;

/**
 * SEVT_ACCOUNT_LOGIN_FAILED
 * StreamableEventType: User authentication failed. Only emitted if the user exists. Resource is the requested path
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_LOGIN_FAILED = 4104;

/**
 * SEVT_ACCOUNT_SESSION_START
 * StreamableEventType: User session token created. Data is the session object
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_SESSION_START = 4105;

/**
 * SEVT_ACCOUNT_SESSION_REVOKE
 * StreamableEventType: User session token deleted
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_SESSION_REVOKE = 4106;

/**
 * SEVT_ACCOUNT_SESSION_EXPIRE
 * StreamableEventType: User session token expired
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_SESSION_EXPIRE = 4107;

/**
 * SEVT_ACCOUNT_ADMIN_NEW
 * StreamableEventType: Admin created. Data is the profile object
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_NEW = 4150;

/**
 * SEVT_ACCOUNT_ADMIN_REMOVED
 * StreamableEventType: Admin deleted
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_REMOVED = 4151;

/**
 * SEVT_ACCOUNT_ADMIN_UPDATED
 * StreamableEventType: Admin updated
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_UPDATED = 4152;

/**
 * SEVT_ACCOUNT_ADMIN_LOGIN
 * StreamableEventType: Admin authentication succeeded. Only emitted for non-session requests. Resource is the requested path
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_LOGIN = 4153;

/**
 * SEVT_ACCOUNT_ADMIN_LOGIN_FAILED
 * StreamableEventType: Admin authentication failed. Only emitted if the admin exists. Resource is the request path
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_LOGIN_FAILED = 4154;

/**
 * SEVT_ACCOUNT_ADMIN_SESSION_START
 * StreamableEventType: Admin session token created. Data is the session object
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_SESSION_START = 4155;

/**
 * SEVT_ACCOUNT_ADMIN_SESSION_REVOKE
 * StreamableEventType: Admin session token deleted
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_SESSION_REVOKE = 4156;

/**
 * SEVT_ACCOUNT_ADMIN_SESSION_EXPIRE
 * StreamableEventType: Admin session token expired
 *
 * @var {number}
 */
export const SEVT_ACCOUNT_ADMIN_SESSION_EXPIRE = 4157;

/**
 * SEVT_JOB_NEW
 * StreamableEventType: New backup job started. Data is the job object
 *
 * @var {number}
 */
export const SEVT_JOB_NEW = 4200;

/**
 * SEVT_JOB_COMPLETED
 * StreamableEventType: Backup job completed. Data is the job object
 *
 * @var {number}
 */
export const SEVT_JOB_COMPLETED = 4201;

/**
 * SEVT_BUCKET_NEW
 * StreamableEventType: New bucket created
 *
 * @var {number}
 */
export const SEVT_BUCKET_NEW = 4300;

/**
 * SEVT_BUCKET_REMOVED
 * StreamableEventType: Bucket deleted
 *
 * @var {number}
 */
export const SEVT_BUCKET_REMOVED = 4301;

/**
 * SEVT_SERVER_STARTED
 * StreamableEventType: Server started
 *
 * @var {number}
 */
export const SEVT_SERVER_STARTED = 4400;

/**
 * SEVT_SERVER_RESTARTED
 * StreamableEventType: Server restarting (pending)
 *
 * @var {number}
 */
export const SEVT_SERVER_RESTARTED = 4401;

/**
 * SEVT_SERVER_SHUTDOWN
 * StreamableEventType: Server shutting down (pending)
 *
 * @var {number}
 */
export const SEVT_SERVER_SHUTDOWN = 4402;

/**
 * SEVT_SERVER_UPDATED
 * StreamableEventType: Server configuration has been updated. Data is the server config object
 *
 * @var {number}
 */
export const SEVT_SERVER_UPDATED = 4403;

/**
 * SEVT_TENANT_NEW
 * StreamableEventType: Tenant created. Data is the tenant object
 *
 * @var {number}
 */
export const SEVT_TENANT_NEW = 4500;

/**
 * SEVT_TENANT_REMOVED
 * StreamableEventType: Tenant deleted
 *
 * @var {number}
 */
export const SEVT_TENANT_REMOVED = 4501;

/**
 * SEVT_TENANT_UPDATED
 * StreamableEventType: Tenant updated. Data is the tenant object
 *
 * @var {number}
 */
export const SEVT_TENANT_UPDATED = 4502;

/**
 * SEVT_POLICY_NEW
 * StreamableEventType: Policy created. Data is the policy object
 *
 * @var {number}
 */
export const SEVT_POLICY_NEW = 4600;

/**
 * SEVT_POLICY_REMOVED
 * StreamableEventType: Policy deleted
 *
 * @var {number}
 */
export const SEVT_POLICY_REMOVED = 4601;

/**
 * SEVT_POLICY_UPDATED
 * StreamableEventType: Policy updated. Data is the policy object
 *
 * @var {number}
 */
export const SEVT_POLICY_UPDATED = 4602;

/**
 * SEVT_DEVICE_NEW
 * StreamableEventType: Device created. Data is device object
 *
 * @var {number}
 */
export const SEVT_DEVICE_NEW = 4700;

/**
 * SEVT_DEVICE_REMOVED
 * StreamableEventType: Device deleted
 *
 * @var {number}
 */
export const SEVT_DEVICE_REMOVED = 4701;

/**
 * SEVT_DEVICE_LIVE_CONNECT
 * StreamableEventType: Device live connection started
 *
 * @var {number}
 */
export const SEVT_DEVICE_LIVE_CONNECT = 4702;

/**
 * SEVT_DEVICE_LIVE_DISCONNECT
 * StreamableEventType: Device live connection ended
 *
 * @var {number}
 */
export const SEVT_DEVICE_LIVE_DISCONNECT = 4703;

/**
 * SEVT_DEVICE_LOBBY_CONNECT
 * StreamableEventType: Device connected to registration lobby
 *
 * @var {number}
 */
export const SEVT_DEVICE_LOBBY_CONNECT = 4704;

/**
 * SEVT_DEVICE_LOBBY_DISCONNECT
 * StreamableEventType: Device disconnected from registration lobby
 *
 * @var {number}
 */
export const SEVT_DEVICE_LOBBY_DISCONNECT = 4705;

/**
 * SEVT__MAX
 * StreamableEventType
 *
 * @var {number}
 */
export const SEVT__MAX = 4999;

/**
 * SSHCONNECTION_AUTHMODE__INVALID
 * SSHAuthMode
 *
 * @var {number}
 */
export const SSHCONNECTION_AUTHMODE__INVALID = 0;

/**
 * SSHCONNECTION_AUTHMODE_PASSWORD
 * SSHAuthMode
 *
 * @var {number}
 */
export const SSHCONNECTION_AUTHMODE_PASSWORD = 1;

/**
 * SSHCONNECTION_AUTHMODE_PRIVATEKEY
 * SSHAuthMode
 *
 * @var {number}
 */
export const SSHCONNECTION_AUTHMODE_PRIVATEKEY = 2;

/**
 * STOREDOBJECTTYPE_FILE
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_FILE = "file";

/**
 * STOREDOBJECTTYPE_DIRECTORY
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_DIRECTORY = "dir";

/**
 * STOREDOBJECTTYPE_SYMLINK
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_SYMLINK = "symlink";

/**
 * STOREDOBJECTTYPE_UNIXBLOCKDEVICE
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_UNIXBLOCKDEVICE = "dev";

/**
 * STOREDOBJECTTYPE_UNIXCHARDEVICE
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_UNIXCHARDEVICE = "chardev";

/**
 * STOREDOBJECTTYPE_UNIXFIFO
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_UNIXFIFO = "fifo";

/**
 * STOREDOBJECTTYPE_UNIXSOCKET
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_UNIXSOCKET = "socket";

/**
 * STOREDOBJECTTYPE_WINEFS
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_WINEFS = "winefs";

/**
 * STOREDOBJECTTYPE_EMAILMESSAGE
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_EMAILMESSAGE = "emailmessage";

/**
 * STOREDOBJECTTYPE_EMAILFOLDER
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_EMAILFOLDER = "mailfolder";

/**
 * STOREDOBJECTTYPE_OFFICECONTACT
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_OFFICECONTACT = "contact";

/**
 * STOREDOBJECTTYPE_OFFICECONTACTFOLDER
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_OFFICECONTACTFOLDER = "contactfolder";

/**
 * STOREDOBJECTTYPE_OFFICECALENDAREVENT
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_OFFICECALENDAREVENT = "calendarevent";

/**
 * STOREDOBJECTTYPE_OFFICECALENDAR
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_OFFICECALENDAR = "calendar";

/**
 * STOREDOBJECTTYPE_MSSITE
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_MSSITE = "mssite";

/**
 * STOREDOBJECTTYPE_MSSITE_TEAM
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_MSSITE_TEAM = "mssiteteam";

/**
 * STOREDOBJECTTYPE_MSSITELISTENTITY
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_MSSITELISTENTITY = "mssitelistentity";

/**
 * STOREDOBJECTTYPE_MSSITEITEMENTITY
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_MSSITEITEMENTITY = "mssiteitementity";

/**
 * STOREDOBJECTTYPE_MSSITELISTDRIVEENTITY
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_MSSITELISTDRIVEENTITY = "mssitelistdriveentity";

/**
 * STOREDOBJECTTYPE_VMDK_FILE
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VMDK_FILE = "vmdkfile";

/**
 * STOREDOBJECTTYPE_VMDK_DIRECTORY
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VMDK_DIRECTORY = "vmdkdir";

/**
 * STOREDOBJECTTYPE_VMDK_WINEFS
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VMDK_WINEFS = "vmdkwinefs";

/**
 * STOREDOBJECTTYPE_VMDK_SYMLINK
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VMDK_SYMLINK = "vmdksymlink";

/**
 * STOREDOBJECTTYPE_VIRTUALIMAGE_DISK
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VIRTUALIMAGE_DISK = "virtualimagedisk";

/**
 * STOREDOBJECTTYPE_VHDX_GPT_PARTITION
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VHDX_GPT_PARTITION = "vhdxpartitiongpt";

/**
 * STOREDOBJECTTYPE_VHDX_MBR_PARTITION
 * StoredObjectType
 *
 * @var {string}
 */
export const STOREDOBJECTTYPE_VHDX_MBR_PARTITION = "vhdxpartitionmbr";

/**
 * STREAM_LEVEL_FULL
 * StreamLevel: Event data contains full data types
 *
 * @var {string}
 */
export const STREAM_LEVEL_FULL = "full";

/**
 * STREAM_LEVEL_NONE
 * StreamLevel: Event data contains nothing
 *
 * @var {string}
 */
export const STREAM_LEVEL_NONE = "none";

/**
 * STREAMER_TYPE_INTERNAL
 * StreamerType
 *
 * @var {string}
 */
export const STREAMER_TYPE_INTERNAL = "internal";

/**
 * STREAMER_TYPE_WEBHOOK
 * StreamerType
 *
 * @var {string}
 */
export const STREAMER_TYPE_WEBHOOK = "webhook";

/**
 * STREAMER_TYPE_WEBSOCKET
 * StreamerType
 *
 * @var {string}
 */
export const STREAMER_TYPE_WEBSOCKET = "websocket";

/**
 * STREAMER_TYPE_FILE
 * StreamerType
 *
 * @var {string}
 */
export const STREAMER_TYPE_FILE = "file";

/**
 * TOTPRequiredError
 * If an API response returns in failure, but it includes this value in the CometAPIResponseMessage->Message parameter, it indicates that your supplied authentication was insufficient, and you must supply additional two-factor authentication credentials.
 *
 * @var {string}
 */
export const TOTPRequiredError = "ERR_TOTP_REQUIRED";

/**
 * UPDATESTATUS_NOT_SEEN
 * UpdateStatus
 *
 * @var {number}
 */
export const UPDATESTATUS_NOT_SEEN = 0;

/**
 * UPDATESTATUS_INELIGIBLE
 * UpdateStatus: The selected device does not meet the filter criteria from the Bulk Update Campaign's configuration.
 *
 * @var {number}
 */
export const UPDATESTATUS_INELIGIBLE = 1;

/**
 * UPDATESTATUS_PENDING
 * UpdateStatus
 *
 * @var {number}
 */
export const UPDATESTATUS_PENDING = 2;

/**
 * UPDATESTATUS_REQUEST_MADE
 * UpdateStatus: The device has made a live connection and it meets the filter criteria. A live connection message has been sent asking it to perform the software upgrade.
 *
 * @var {number}
 */
export const UPDATESTATUS_REQUEST_MADE = 3;

/**
 * UPDATESTATUS_UPDATE_FAILED
 * UpdateStatus: An update signal was sent to the device, but when it reconnected, it did not advertise the target software version. It's likely that the update failed - please check the device's Update log for more information.
 *
 * @var {number}
 */
export const UPDATESTATUS_UPDATE_FAILED = 4;

/**
 * UPDATESTATUS_UPDATE_CONFIRMED
 * UpdateStatus: The device has successfully updated to the target version.
 *
 * @var {number}
 */
export const UPDATESTATUS_UPDATE_CONFIRMED = 5;

/**
 * USERNAME_MAX_LENGTH
 *
 * @var {number}
 */
export const USERNAME_MAX_LENGTH = 255;

/**
 * UnknownDeviceError
 * If an API response returns in failure, but it includes this value in the CometAPIResponseMessage->Message parameter, it indicates that the specified Device ID was invalid or not found.
 *
 * @var {string}
 */
export const UnknownDeviceError = "ERR_UNKNOWN_DEVICE";

/**
 * UnsupportVhdxFileSystem
 *
 * @var {string}
 */
export const UnsupportVhdxFileSystem = "ERR_UNSUPPORT_VHDX_FILE_SYSTEM";

/**
 * UnsupportVmdkFileSystem
 *
 * @var {string}
 */
export const UnsupportVmdkFileSystem = "ERR_UNSUPPORT_VMDK_FILE_SYSTEM";

/**
 * VhdxPartitonReadErrMsg
 *
 * @var {string}
 */
export const VhdxPartitonReadErrMsg = "ERR_VHDX_PARTITION";

/**
 * WEBAUTHN_DEVICE_TYPE__UNKNOWN
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__UNKNOWN = 0;

/**
 * WEBAUTHN_DEVICE_TYPE__HARDWARE_TOKEN
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__HARDWARE_TOKEN = 1;

/**
 * WEBAUTHN_DEVICE_TYPE__ANDROID
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__ANDROID = 2;

/**
 * WEBAUTHN_DEVICE_TYPE__APPLE
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__APPLE = 3;

/**
 * WEBAUTHN_DEVICE_TYPE__TPM_GENERIC
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__TPM_GENERIC = 4;

/**
 * WEBAUTHN_DEVICE_TYPE__TPM_WINDOWS
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__TPM_WINDOWS = 5;

/**
 * WEBAUTHN_DEVICE_TYPE__TPM_LINUX
 * WebAuthnDeviceType
 *
 * @var {number}
 */
export const WEBAUTHN_DEVICE_TYPE__TPM_LINUX = 6;

/**
 * WINDOWSCODESIGN_METHOD_AUTO
 * WindowsCodesignMethod: When upgrading from a version of Comet Server prior to 23.3.0, this option will be automatically converted to a more specific type.
 *
 * @var {number}
 * @deprecated This const has been deprecated since Comet version 23.3.0
 */
export const WINDOWSCODESIGN_METHOD_AUTO = 0;

/**
 * WINDOWSCODESIGN_METHOD_DISABLED
 * WindowsCodesignMethod: Do not perform Authenticode codesigning
 *
 * @var {number}
 */
export const WINDOWSCODESIGN_METHOD_DISABLED = 1;

/**
 * WINDOWSCODESIGN_METHOD_PKCS12FILE
 * WindowsCodesignMethod: Use a configured PKCS#12 key file for Authenticode codesigning
 *
 * @var {number}
 */
export const WINDOWSCODESIGN_METHOD_PKCS12FILE = 2;

/**
 * WINDOWSCODESIGN_METHOD_PKCS11HSM
 * WindowsCodesignMethod: Use a configured PKCS#11 hardware security module (HSM) for Authenticode codesigning
 *
 * @var {number}
 */
export const WINDOWSCODESIGN_METHOD_PKCS11HSM = 3;

/**
 * WINDOWSCODESIGN_METHOD_AZUREKEYVAULT
 * WindowsCodesignMethod: Use a configured Azure Key Vault for Authenticode codesigning
 *
 * @var {number}
 */
export const WINDOWSCODESIGN_METHOD_AZUREKEYVAULT = 4;

// DATA TYPES


export type libcomet_AddBucketResponseMessage = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	NewBucketID: string
	NewBucketKey: string
}

export function New_Zero_libcomet_AddBucketResponseMessage(): libcomet_AddBucketResponseMessage {
	return {
		"Status": 0,
		"Message": "",
		"NewBucketID": "",
		"NewBucketKey": "",
	};
}

export function libcomet_AddBucketResponseMessage_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_AddBucketResponseMessage, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}

export function libcomet_AddBucketResponseMessage_set_embedded_libcomet_NewBucketDetail(dest: libcomet_AddBucketResponseMessage, src: libcomet_NewBucketDetail): void {
	dest.NewBucketID = src.NewBucketID;
	dest.NewBucketKey = src.NewBucketKey;
}


export type libcomet_AdminAccountPropertiesResponse = {
	OrganizationID: string
	Permissions: libcomet_AdminUserPermissions
	/**
	 * This field is available in Comet 18.9.9 and later.
	 */
	Security: libcomet_AdminSecurityOptions
}

export function New_Zero_libcomet_AdminAccountPropertiesResponse(): libcomet_AdminAccountPropertiesResponse {
	return {
		"OrganizationID": "",
		"Permissions": New_Zero_libcomet_AdminUserPermissions(),
		"Security": New_Zero_libcomet_AdminSecurityOptions(),
	};
}


export type libcomet_AdminEmailOptions = {
	FromEmail: string
	FromName: string
}

export function New_Zero_libcomet_AdminEmailOptions(): libcomet_AdminEmailOptions {
	return {
		"FromEmail": "",
		"FromName": "",
	};
}


export type libcomet_AdminResourceResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	ResourceHash: string
}

export function New_Zero_libcomet_AdminResourceResponse(): libcomet_AdminResourceResponse {
	return {
		"Status": 0,
		"Message": "",
		"ResourceHash": "",
	};
}

export function libcomet_AdminResourceResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_AdminResourceResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_AdminSecurityOptions = {
	/**
	 * One of the PASSWORD_FORMAT_ constants
	 */
	PasswordFormat: number
	Password: string
	AllowPasswordLogin: boolean
	AllowPasswordAndTOTPLogin: boolean
	/**
	 * @deprecated This member has been deprecated since Comet version 21.12.0
	 */
	AllowPasswordAndU2FLogin: boolean
	AllowPasswordAndWebAuthnLogin: boolean
	/**
	 * Omission from JSON will be interpreted as an empty array
	 * @deprecated This member has been deprecated since Comet version 21.12.0
	 */
	U2FRegistrations?: libcomet_AdminU2FRegistration[]
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	WebAuthnRegistrations?: libcomet_AdminWebAuthnRegistration[]
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TOTPKeyEncryptionFormat?: number
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	TOTPKey?: string
	/**
	 * A regular expression in Go regex syntax, for which IP addresses are allowed to authenticate as
	 * this admin account
	 * Omission from JSON will be interpreted as empty-string
	 */
	IPWhitelist?: string
}

export function New_Zero_libcomet_AdminSecurityOptions(): libcomet_AdminSecurityOptions {
	return {
		"PasswordFormat": 0,
		"Password": "",
		"AllowPasswordLogin": false,
		"AllowPasswordAndTOTPLogin": false,
		"AllowPasswordAndU2FLogin": false,
		"AllowPasswordAndWebAuthnLogin": false,
	};
}


/**
 * @deprecated This type has been deprecated since Comet version 21.12.0
 */
export type libcomet_AdminU2FRegistration = {
	Description: string
	/**
	 * Unix timestamp, in seconds.
	 */
	RegisterTime: number
	Registration: string
}

export function New_Zero_libcomet_AdminU2FRegistration(): libcomet_AdminU2FRegistration {
	return {
		"Description": "",
		"RegisterTime": 0,
		"Registration": "",
	};
}


export type libcomet_AdminUserPermissions = {
	/**
	 * Omission from JSON will be interpreted as false
	 */
	PreventEditServerSettings?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	PreventServerShutdown?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	PreventChangePassword?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	AllowEditBranding?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	AllowEditEmailOptions?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	AllowEditRemoteStorage?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	AllowEditWebhooks?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	AllowEditExternalAuthSources?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	DenyConstellationRole?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as false
	 */
	DenyViewServerHistory?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as false
	 */
	DenyViewServerInfo?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as false
	 */
	PreventRequestStorageVault?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as false
	 */
	PreventAddCustomStorageVault?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as false
	 */
	HideCloudStorageBranding?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as false
	 */
	ShouldRestrictProviderList?: boolean
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as an empty array
	 */
	AllowedProvidersWhenRestricted?: number[]
}

export function New_Zero_libcomet_AdminUserPermissions(): libcomet_AdminUserPermissions {
	return {
	};
}


export type libcomet_AdminWebAuthnRegistration = {
	Description: string
	/**
	 * Unix timestamp, in seconds.
	 */
	RegisterTime: number
	Type: number
	/**
	 * Omission from JSON will be interpreted as false
	 */
	IsLegacyU2F?: boolean
	/**
	 * In other language projections, this field may contain raw binary data. When the field is expressed as JSON, this field contains base64 content. This javascript/typescript SDK preserves the base64 version in this field.
	 * Omission from JSON will be interpreted as an empty array
	 */
	ID?: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Credential?: libcomet_WebAuthnCredential
}

export function New_Zero_libcomet_AdminWebAuthnRegistration(): libcomet_AdminWebAuthnRegistration {
	return {
		"Description": "",
		"RegisterTime": 0,
		"Type": 0,
	};
}


export type libcomet_AllowedAdminUser = {
	Username: string
	OrganizationID: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	ExternalAuthenticationSource?: string
	/**
	 * One of the PASSWORD_FORMAT_ constants
	 */
	PasswordFormat: number
	Password: string
	AllowPasswordLogin: boolean
	AllowPasswordAndTOTPLogin: boolean
	/**
	 * @deprecated This member has been deprecated since Comet version 21.12.0
	 */
	AllowPasswordAndU2FLogin: boolean
	AllowPasswordAndWebAuthnLogin: boolean
	/**
	 * Omission from JSON will be interpreted as an empty array
	 * @deprecated This member has been deprecated since Comet version 21.12.0
	 */
	U2FRegistrations?: libcomet_AdminU2FRegistration[]
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	WebAuthnRegistrations?: libcomet_AdminWebAuthnRegistration[]
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TOTPKeyEncryptionFormat?: number
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	TOTPKey?: string
	/**
	 * A regular expression in Go regex syntax, for which IP addresses are allowed to authenticate as
	 * this admin account
	 * Omission from JSON will be interpreted as empty-string
	 */
	IPWhitelist?: string
	Permissions: libcomet_AdminUserPermissions
}

export function New_Zero_libcomet_AllowedAdminUser(): libcomet_AllowedAdminUser {
	return {
		"Username": "",
		"OrganizationID": "",
		"PasswordFormat": 0,
		"Password": "",
		"AllowPasswordLogin": false,
		"AllowPasswordAndTOTPLogin": false,
		"AllowPasswordAndU2FLogin": false,
		"AllowPasswordAndWebAuthnLogin": false,
		"Permissions": New_Zero_libcomet_AdminUserPermissions(),
	};
}

export function libcomet_AllowedAdminUser_set_embedded_libcomet_AdminSecurityOptions(dest: libcomet_AllowedAdminUser, src: libcomet_AdminSecurityOptions): void {
	dest.PasswordFormat = src.PasswordFormat;
	dest.Password = src.Password;
	dest.AllowPasswordLogin = src.AllowPasswordLogin;
	dest.AllowPasswordAndTOTPLogin = src.AllowPasswordAndTOTPLogin;
	dest.AllowPasswordAndU2FLogin = src.AllowPasswordAndU2FLogin;
	dest.AllowPasswordAndWebAuthnLogin = src.AllowPasswordAndWebAuthnLogin;
	dest.U2FRegistrations = src.U2FRegistrations;
	dest.WebAuthnRegistrations = src.WebAuthnRegistrations;
	dest.TOTPKeyEncryptionFormat = src.TOTPKeyEncryptionFormat;
	dest.TOTPKey = src.TOTPKey;
	dest.IPWhitelist = src.IPWhitelist;
}


export type libcomet_AmazonAWSVirtualStorageRoleSettings = {
	MasterBucket: string
	AccessKey: string
	SecretKey: string
	/**
	 * UseObjectLock_Legacy_DoNotUse
	 */
	UseObjectLock: boolean
	ObjectLockMode: number
	ObjectLockDays: number
	RemoveDeleted: boolean
}

export function New_Zero_libcomet_AmazonAWSVirtualStorageRoleSettings(): libcomet_AmazonAWSVirtualStorageRoleSettings {
	return {
		"MasterBucket": "",
		"AccessKey": "",
		"SecretKey": "",
		"UseObjectLock": false,
		"ObjectLockMode": 0,
		"ObjectLockDays": 0,
		"RemoveDeleted": false,
	};
}


export type libcomet_AuthenticationRoleOptions = {
	RoleEnabled: boolean
	/**
	 * One of the INTEGRITYCHECK_ constants
	 */
	DatabaseCheckLevel: number
	GenerateMissedBackupEvents: boolean
	/**
	 * Unix timestamp in seconds, before which no Missed jobs are created
	 */
	NoMissedBackupEventsBefore: number
	GenerateScheduledEmails: boolean
	PruneLogsAfterDays: number
	RemoteStorage: libcomet_RemoteStorageOption[]
	ReplicateTo: libcomet_ReplicaServer[]
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	GlobalOverrides?: libcomet_GlobalOverrideOptions
}

export function New_Zero_libcomet_AuthenticationRoleOptions(): libcomet_AuthenticationRoleOptions {
	return {
		"RoleEnabled": false,
		"DatabaseCheckLevel": 0,
		"GenerateMissedBackupEvents": false,
		"NoMissedBackupEventsBefore": 0,
		"GenerateScheduledEmails": false,
		"PruneLogsAfterDays": 0,
		"RemoteStorage": [],
		"ReplicateTo": [],
	};
}


export type libcomet_AvailableDownload = {
	Category: string
	Description: string
	Recommended: boolean
}

export function New_Zero_libcomet_AvailableDownload(): libcomet_AvailableDownload {
	return {
		"Category": "",
		"Description": "",
		"Recommended": false,
	};
}


/**
 * AzureDestinationLocation allows configuring connection settings for storage locations using the
 * Azure Blob Storage API (DESTINATIONTYPE_AZURE).
 */
export type libcomet_AzureDestinationLocation = {
	AZBAccountName: string
	AZBAccountKey: string
	AZBContainer: string
	/**
	 * The base URL for the Azure Blob Storage service. Leave blank to use the global default URL.
	 */
	AZBRealm: string
	AZBPrefix: string
}

export function New_Zero_libcomet_AzureDestinationLocation(): libcomet_AzureDestinationLocation {
	return {
		"AZBAccountName": "",
		"AZBAccountKey": "",
		"AZBContainer": "",
		"AZBRealm": "",
		"AZBPrefix": "",
	};
}


/**
 * B2DestinationLocation allows configuring connection settings for storage locations using the
 * Backblaze B2 native API (DESTINATIONTYPE_B2).
 */
export type libcomet_B2DestinationLocation = {
	/**
	 * Key ID
	 * Omission from JSON will be interpreted as empty-string
	 */
	AccountID?: string
	/**
	 * Application Key
	 * Omission from JSON will be interpreted as empty-string
	 */
	Key?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Bucket?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Prefix?: string
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 * @deprecated This member has been deprecated since Comet version 21.9.7
	 */
	MaxConnections?: number
	/**
	 * Hide files instead of deleting them. This can be used for ransomware protection if (A) the B2
	 * credentials have the hideFile permission but not the deleteFile permission, and (B) you use the
	 * Backblaze B2 server-side lifecycle policies to clean up old hidden files.
	 * Omission from JSON will be interpreted as false
	 */
	HideDeletedFiles?: boolean
}

export function New_Zero_libcomet_B2DestinationLocation(): libcomet_B2DestinationLocation {
	return {
	};
}


export type libcomet_B2StorageExtraInfo = {
	TotalTransactionsInTimeInterval: {[k: number]: libcomet_B2TransactionTotals}
}

export function New_Zero_libcomet_B2StorageExtraInfo(): libcomet_B2StorageExtraInfo {
	return {
		"TotalTransactionsInTimeInterval": {},
	};
}


export type libcomet_B2TransactionTotals = {
	ClassA: number
	ClassB: number
	ClassC: number
}

export function New_Zero_libcomet_B2TransactionTotals(): libcomet_B2TransactionTotals {
	return {
		"ClassA": 0,
		"ClassB": 0,
		"ClassC": 0,
	};
}


export type libcomet_B2VirtualStorageRoleSettings = {
	MasterBucket: string
	KeyID: string
	AppKey: string
	HideDeletedFiles: boolean
}

export function New_Zero_libcomet_B2VirtualStorageRoleSettings(): libcomet_B2VirtualStorageRoleSettings {
	return {
		"MasterBucket": "",
		"KeyID": "",
		"AppKey": "",
		"HideDeletedFiles": false,
	};
}


/**
 * BackupJobAdvancedOptions control additional advanced options for running a backup job. They can
 * be specified as part of a schedule in the BackupRuleConfig type, or supplied immediately when
 * running a job.
 */
export type libcomet_BackupJobAdvancedOptions = {
	SkipAlreadyRunning: boolean
	/**
	 * If Zero: disabled
	 */
	StopAfter: number
	/**
	 * If Zero: disabled
	 */
	LimitVaultSpeedBps: number
	/**
	 * Default disabled
	 */
	ReduceDiskConcurrency: boolean
	/**
	 * Default disabled
	 */
	UseOnDiskIndexes: boolean
	/**
	 * Default disabled
	 */
	AllowZeroFilesSuccess: boolean
	/**
	 * If Zero: default Automatic (BACKUPJOBAUTORETENTION_AUTOMATIC)
	 */
	AutoRetentionLevel: number
	LogLevel: string
}

export function New_Zero_libcomet_BackupJobAdvancedOptions(): libcomet_BackupJobAdvancedOptions {
	return {
		"SkipAlreadyRunning": false,
		"StopAfter": 0,
		"LimitVaultSpeedBps": 0,
		"ReduceDiskConcurrency": false,
		"UseOnDiskIndexes": false,
		"AllowZeroFilesSuccess": false,
		"AutoRetentionLevel": 0,
		"LogLevel": "",
	};
}


export type libcomet_BackupJobDetail = {
	GUID: string
	Username: string
	Classification: number
	Status: number
	/**
	 * Unix timestamp in seconds
	 */
	StartTime: number
	/**
	 * Unix timestamp in seconds. Will be zero if the job is still running.
	 */
	EndTime: number
	/**
	 * The Protected Item that this job is for
	 */
	SourceGUID: string
	/**
	 * The Storage Vault that this job is for
	 */
	DestinationGUID: string
	DeviceID: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SnapshotID?: string
	ClientVersion: string
	TotalDirectories: number
	TotalFiles: number
	TotalSize: number
	TotalChunks: number
	UploadSize: number
	DownloadSize: number
	/**
	 * For Hyper-V and VMware backup jobs, the total number of virtual machines.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TotalVmCount?: number
	/**
	 * For Office 365 backup jobs, the total number of mailboxes.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TotalMailsCount?: number
	/**
	 * For Office 365 backup jobs, the total number of SharePoint sites.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TotalSitesCount?: number
	/**
	 * For Office 365 backup jobs, the calculated effective number of protected accounts.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TotalAccountsCount?: number
	/**
	 * For Office 365 backup jobs, the number of licensed mailboxes.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TotalLicensedMailsCount?: number
	/**
	 * For Office 365 backup jobs, the number of unlicensed mailboxes.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	TotalUnlicensedMailsCount?: number
	/**
	 * If this field is present, it is possible to request cancellation of this job via the API.
	 * Omission from JSON will be interpreted as empty-string
	 */
	CancellationID?: string
	/**
	 * If this backup job is still running, additional partial-progress information may be present in
	 * this field.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Progress?: libcomet_BackupJobProgress
	/**
	 * The size of the Storage Vault, as measured at the start of the job.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	DestinationSizeStart?: libcomet_SizeMeasurement
	/**
	 * The size of the Storage Vault, as measured at the end of the job.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	DestinationSizeEnd?: libcomet_SizeMeasurement
}

export function New_Zero_libcomet_BackupJobDetail(): libcomet_BackupJobDetail {
	return {
		"GUID": "",
		"Username": "",
		"Classification": 0,
		"Status": 0,
		"StartTime": 0,
		"EndTime": 0,
		"SourceGUID": "",
		"DestinationGUID": "",
		"DeviceID": "",
		"ClientVersion": "",
		"TotalDirectories": 0,
		"TotalFiles": 0,
		"TotalSize": 0,
		"TotalChunks": 0,
		"UploadSize": 0,
		"DownloadSize": 0,
	};
}


export type libcomet_BackupJobProgress = {
	/**
	 * This field will always increase monotonically, exactly once, for every change to the
	 * BackupJobProgress for a given backup job.
	 */
	Counter: number
	/**
	 * Unix timestamp in seconds
	 */
	SentTime: number
	/**
	 * Unix timestamp in seconds. The typo is preserved for backwards-compatibility reasons.
	 */
	RecievedTime: number
	BytesDone: number
	ItemsDone: number
}

export function New_Zero_libcomet_BackupJobProgress(): libcomet_BackupJobProgress {
	return {
		"Counter": 0,
		"SentTime": 0,
		"RecievedTime": 0,
		"BytesDone": 0,
		"ItemsDone": 0,
	};
}


/**
 * A backup rule connects one source Protected Item and one destination Storage Vault, with multiple
 * time schedules or event triggers
 */
export type libcomet_BackupRuleConfig = {
	Description: string
	/**
	 * Unix timestamp in seconds
	 */
	CreateTime: number
	/**
	 * Unix timestamp in seconds. The caller is responsible for updating this themselves.
	 */
	ModifyTime: number
	/**
	 * Custom commands to run before the job
	 */
	PreExec: string[]
	/**
	 * Custom commands to run after taking a disk snapshot
	 */
	ThawExec: string[]
	/**
	 * Custom commands to run after the job
	 */
	PostExec: string[]
	/**
	 * The source Protected Item ID to back up from, during this schedule
	 */
	Source: string
	/**
	 * The destination Storage Vault ID to back up to, during this schedule
	 */
	Destination: string
	SkipAlreadyRunning: boolean
	/**
	 * If Zero: disabled
	 */
	StopAfter: number
	/**
	 * If Zero: disabled
	 */
	LimitVaultSpeedBps: number
	/**
	 * Default disabled
	 */
	ReduceDiskConcurrency: boolean
	/**
	 * Default disabled
	 */
	UseOnDiskIndexes: boolean
	/**
	 * Default disabled
	 */
	AllowZeroFilesSuccess: boolean
	/**
	 * If Zero: default Automatic (BACKUPJOBAUTORETENTION_AUTOMATIC)
	 */
	AutoRetentionLevel: number
	LogLevel: string
	/**
	 * Scheduled start times
	 */
	Schedules: libcomet_ScheduleConfig[]
	/**
	 * Other events that will cause this scheduled job to start
	 */
	EventTriggers: libcomet_BackupRuleEventTriggers
}

export function New_Zero_libcomet_BackupRuleConfig(): libcomet_BackupRuleConfig {
	return {
		"Description": "",
		"CreateTime": 0,
		"ModifyTime": 0,
		"PreExec": [],
		"ThawExec": [],
		"PostExec": [],
		"Source": "",
		"Destination": "",
		"SkipAlreadyRunning": false,
		"StopAfter": 0,
		"LimitVaultSpeedBps": 0,
		"ReduceDiskConcurrency": false,
		"UseOnDiskIndexes": false,
		"AllowZeroFilesSuccess": false,
		"AutoRetentionLevel": 0,
		"LogLevel": "",
		"Schedules": [],
		"EventTriggers": New_Zero_libcomet_BackupRuleEventTriggers(),
	};
}

export function libcomet_BackupRuleConfig_set_embedded_libcomet_BackupJobAdvancedOptions(dest: libcomet_BackupRuleConfig, src: libcomet_BackupJobAdvancedOptions): void {
	dest.SkipAlreadyRunning = src.SkipAlreadyRunning;
	dest.StopAfter = src.StopAfter;
	dest.LimitVaultSpeedBps = src.LimitVaultSpeedBps;
	dest.ReduceDiskConcurrency = src.ReduceDiskConcurrency;
	dest.UseOnDiskIndexes = src.UseOnDiskIndexes;
	dest.AllowZeroFilesSuccess = src.AllowZeroFilesSuccess;
	dest.AutoRetentionLevel = src.AutoRetentionLevel;
	dest.LogLevel = src.LogLevel;
}


export type libcomet_BackupRuleEventTriggers = {
	/**
	 * The "When PC Starts" option
	 * Omission from JSON will be interpreted as false
	 */
	OnPCBoot?: boolean
	/**
	 * The "If the last job was Missed" option. In Comet 23.12.3 and later, this condition is evaluated
	 * when the PC starts and/or when the live connection is resumed.
	 * Omission from JSON will be interpreted as false
	 */
	OnPCBootIfLastJobMissed?: boolean
}

export function New_Zero_libcomet_BackupRuleEventTriggers(): libcomet_BackupRuleEventTriggers {
	return {
	};
}


export type libcomet_BrandingOptions = {
	/**
	 * One of the BRANDINGSTYLETYPE_ constants
	 * This field is available in Comet 23.3.3 and later.
	 */
	BrandingStyleType: number
	BrandName: string
	LogoImage: string
	TopColor: string
	AccentColor: string
	Favicon: string
	HideNewsArea: boolean
	ProductName: string
	CompanyName: string
	HelpURL: string
	HelpIsPopup: boolean
	DefaultLoginServerURL: string
	TileBackgroundColor: string
	AccountRegisterURL: string
	HideBackgroundLogo: boolean
	/**
	 * One of the CLIENTBRANDINGBUILD_ constants
	 */
	BuildMode: number
	PathIcoFile: string
	PathIcnsFile: string
	PathMenuBarIcnsFile: string
	PathEulaRtf: string
	PathTilePng: string
	PathHeaderImage: string
	PathAppIconImage: string
	PackageIdentifier: string
	/**
	 * One of the WINDOWSCODESIGN_METHOD_ constants
	 */
	WindowsCodeSignMethod: number
	WindowsCodeSignPKCS12FilePath: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS12PasswordFormat: number
	WindowsCodeSignPKCS12Password: string
	WindowsCodeSignPKCS11Engine: string
	WindowsCodeSignPKCS11Module: string
	/**
	 * This field was deprecated between 23.3.0 and 23.6.x, but is now used again.
	 */
	WindowsCodeSignPKCS11Certfile: string
	WindowsCodeSignPKCS11KeyID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS11PasswordFormat: number
	WindowsCodeSignPKCS11Password: string
	WindowsCodeSignAzureVaultName: string
	WindowsCodeSignAzureCertName: string
	WindowsCodeSignAzureAppID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignAzureAppSecretFormat: number
	WindowsCodeSignAzureAppSecret: string
	WindowsCodeSignAzureTenantID: string
	MacOSCodeSign: libcomet_MacOSCodeSignProperties
}

export function New_Zero_libcomet_BrandingOptions(): libcomet_BrandingOptions {
	return {
		"BrandingStyleType": 0,
		"BrandName": "",
		"LogoImage": "",
		"TopColor": "",
		"AccentColor": "",
		"Favicon": "",
		"HideNewsArea": false,
		"ProductName": "",
		"CompanyName": "",
		"HelpURL": "",
		"HelpIsPopup": false,
		"DefaultLoginServerURL": "",
		"TileBackgroundColor": "",
		"AccountRegisterURL": "",
		"HideBackgroundLogo": false,
		"BuildMode": 0,
		"PathIcoFile": "",
		"PathIcnsFile": "",
		"PathMenuBarIcnsFile": "",
		"PathEulaRtf": "",
		"PathTilePng": "",
		"PathHeaderImage": "",
		"PathAppIconImage": "",
		"PackageIdentifier": "",
		"WindowsCodeSignMethod": 0,
		"WindowsCodeSignPKCS12FilePath": "",
		"WindowsCodeSignPKCS12PasswordFormat": 0,
		"WindowsCodeSignPKCS12Password": "",
		"WindowsCodeSignPKCS11Engine": "",
		"WindowsCodeSignPKCS11Module": "",
		"WindowsCodeSignPKCS11Certfile": "",
		"WindowsCodeSignPKCS11KeyID": "",
		"WindowsCodeSignPKCS11PasswordFormat": 0,
		"WindowsCodeSignPKCS11Password": "",
		"WindowsCodeSignAzureVaultName": "",
		"WindowsCodeSignAzureCertName": "",
		"WindowsCodeSignAzureAppID": "",
		"WindowsCodeSignAzureAppSecretFormat": 0,
		"WindowsCodeSignAzureAppSecret": "",
		"WindowsCodeSignAzureTenantID": "",
		"MacOSCodeSign": New_Zero_libcomet_MacOSCodeSignProperties(),
	};
}

export function libcomet_BrandingOptions_set_embedded_libcomet_WebInterfaceBrandingProperties(dest: libcomet_BrandingOptions, src: libcomet_WebInterfaceBrandingProperties): void {
	dest.BrandingStyleType = src.BrandingStyleType;
	dest.BrandName = src.BrandName;
	dest.LogoImage = src.LogoImage;
	dest.TopColor = src.TopColor;
	dest.AccentColor = src.AccentColor;
	dest.Favicon = src.Favicon;
	dest.HideNewsArea = src.HideNewsArea;
}

export function libcomet_BrandingOptions_set_embedded_libcomet_BrandingProperties(dest: libcomet_BrandingOptions, src: libcomet_BrandingProperties): void {
	dest.ProductName = src.ProductName;
	dest.CompanyName = src.CompanyName;
	dest.HelpURL = src.HelpURL;
	dest.HelpIsPopup = src.HelpIsPopup;
	dest.DefaultLoginServerURL = src.DefaultLoginServerURL;
	dest.TileBackgroundColor = src.TileBackgroundColor;
	dest.AccountRegisterURL = src.AccountRegisterURL;
	dest.HideBackgroundLogo = src.HideBackgroundLogo;
	dest.BuildMode = src.BuildMode;
	dest.PathIcoFile = src.PathIcoFile;
	dest.PathIcnsFile = src.PathIcnsFile;
	dest.PathMenuBarIcnsFile = src.PathMenuBarIcnsFile;
	dest.PathEulaRtf = src.PathEulaRtf;
	dest.PathTilePng = src.PathTilePng;
	dest.PathHeaderImage = src.PathHeaderImage;
	dest.PathAppIconImage = src.PathAppIconImage;
	dest.PackageIdentifier = src.PackageIdentifier;
	dest.WindowsCodeSignMethod = src.WindowsCodeSignMethod;
	dest.WindowsCodeSignPKCS12FilePath = src.WindowsCodeSignPKCS12FilePath;
	dest.WindowsCodeSignPKCS12PasswordFormat = src.WindowsCodeSignPKCS12PasswordFormat;
	dest.WindowsCodeSignPKCS12Password = src.WindowsCodeSignPKCS12Password;
	dest.WindowsCodeSignPKCS11Engine = src.WindowsCodeSignPKCS11Engine;
	dest.WindowsCodeSignPKCS11Module = src.WindowsCodeSignPKCS11Module;
	dest.WindowsCodeSignPKCS11Certfile = src.WindowsCodeSignPKCS11Certfile;
	dest.WindowsCodeSignPKCS11KeyID = src.WindowsCodeSignPKCS11KeyID;
	dest.WindowsCodeSignPKCS11PasswordFormat = src.WindowsCodeSignPKCS11PasswordFormat;
	dest.WindowsCodeSignPKCS11Password = src.WindowsCodeSignPKCS11Password;
	dest.WindowsCodeSignAzureVaultName = src.WindowsCodeSignAzureVaultName;
	dest.WindowsCodeSignAzureCertName = src.WindowsCodeSignAzureCertName;
	dest.WindowsCodeSignAzureAppID = src.WindowsCodeSignAzureAppID;
	dest.WindowsCodeSignAzureAppSecretFormat = src.WindowsCodeSignAzureAppSecretFormat;
	dest.WindowsCodeSignAzureAppSecret = src.WindowsCodeSignAzureAppSecret;
	dest.WindowsCodeSignAzureTenantID = src.WindowsCodeSignAzureTenantID;
	dest.MacOSCodeSign = src.MacOSCodeSign;
}


export type libcomet_BrandingProperties = {
	ProductName: string
	CompanyName: string
	HelpURL: string
	HelpIsPopup: boolean
	DefaultLoginServerURL: string
	TileBackgroundColor: string
	AccountRegisterURL: string
	HideBackgroundLogo: boolean
	/**
	 * One of the CLIENTBRANDINGBUILD_ constants
	 */
	BuildMode: number
	PathIcoFile: string
	PathIcnsFile: string
	PathMenuBarIcnsFile: string
	PathEulaRtf: string
	PathTilePng: string
	PathHeaderImage: string
	PathAppIconImage: string
	PackageIdentifier: string
	/**
	 * One of the WINDOWSCODESIGN_METHOD_ constants
	 */
	WindowsCodeSignMethod: number
	WindowsCodeSignPKCS12FilePath: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS12PasswordFormat: number
	WindowsCodeSignPKCS12Password: string
	WindowsCodeSignPKCS11Engine: string
	WindowsCodeSignPKCS11Module: string
	/**
	 * This field was deprecated between 23.3.0 and 23.6.x, but is now used again.
	 */
	WindowsCodeSignPKCS11Certfile: string
	WindowsCodeSignPKCS11KeyID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS11PasswordFormat: number
	WindowsCodeSignPKCS11Password: string
	WindowsCodeSignAzureVaultName: string
	WindowsCodeSignAzureCertName: string
	WindowsCodeSignAzureAppID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignAzureAppSecretFormat: number
	WindowsCodeSignAzureAppSecret: string
	WindowsCodeSignAzureTenantID: string
	MacOSCodeSign: libcomet_MacOSCodeSignProperties
}

export function New_Zero_libcomet_BrandingProperties(): libcomet_BrandingProperties {
	return {
		"ProductName": "",
		"CompanyName": "",
		"HelpURL": "",
		"HelpIsPopup": false,
		"DefaultLoginServerURL": "",
		"TileBackgroundColor": "",
		"AccountRegisterURL": "",
		"HideBackgroundLogo": false,
		"BuildMode": 0,
		"PathIcoFile": "",
		"PathIcnsFile": "",
		"PathMenuBarIcnsFile": "",
		"PathEulaRtf": "",
		"PathTilePng": "",
		"PathHeaderImage": "",
		"PathAppIconImage": "",
		"PackageIdentifier": "",
		"WindowsCodeSignMethod": 0,
		"WindowsCodeSignPKCS12FilePath": "",
		"WindowsCodeSignPKCS12PasswordFormat": 0,
		"WindowsCodeSignPKCS12Password": "",
		"WindowsCodeSignPKCS11Engine": "",
		"WindowsCodeSignPKCS11Module": "",
		"WindowsCodeSignPKCS11Certfile": "",
		"WindowsCodeSignPKCS11KeyID": "",
		"WindowsCodeSignPKCS11PasswordFormat": 0,
		"WindowsCodeSignPKCS11Password": "",
		"WindowsCodeSignAzureVaultName": "",
		"WindowsCodeSignAzureCertName": "",
		"WindowsCodeSignAzureAppID": "",
		"WindowsCodeSignAzureAppSecretFormat": 0,
		"WindowsCodeSignAzureAppSecret": "",
		"WindowsCodeSignAzureTenantID": "",
		"MacOSCodeSign": New_Zero_libcomet_MacOSCodeSignProperties(),
	};
}

export function libcomet_BrandingProperties_set_embedded_libcomet_PublicBrandingProperties(dest: libcomet_BrandingProperties, src: libcomet_PublicBrandingProperties): void {
	dest.ProductName = src.ProductName;
	dest.CompanyName = src.CompanyName;
	dest.HelpURL = src.HelpURL;
	dest.HelpIsPopup = src.HelpIsPopup;
	dest.DefaultLoginServerURL = src.DefaultLoginServerURL;
	dest.TileBackgroundColor = src.TileBackgroundColor;
	dest.AccountRegisterURL = src.AccountRegisterURL;
	dest.HideBackgroundLogo = src.HideBackgroundLogo;
}

export function libcomet_BrandingProperties_set_embedded_libcomet_PrivateBrandingProperties(dest: libcomet_BrandingProperties, src: libcomet_PrivateBrandingProperties): void {
	dest.BuildMode = src.BuildMode;
	dest.PathIcoFile = src.PathIcoFile;
	dest.PathIcnsFile = src.PathIcnsFile;
	dest.PathMenuBarIcnsFile = src.PathMenuBarIcnsFile;
	dest.PathEulaRtf = src.PathEulaRtf;
	dest.PathTilePng = src.PathTilePng;
	dest.PathHeaderImage = src.PathHeaderImage;
	dest.PathAppIconImage = src.PathAppIconImage;
	dest.PackageIdentifier = src.PackageIdentifier;
	dest.WindowsCodeSignMethod = src.WindowsCodeSignMethod;
	dest.WindowsCodeSignPKCS12FilePath = src.WindowsCodeSignPKCS12FilePath;
	dest.WindowsCodeSignPKCS12PasswordFormat = src.WindowsCodeSignPKCS12PasswordFormat;
	dest.WindowsCodeSignPKCS12Password = src.WindowsCodeSignPKCS12Password;
	dest.WindowsCodeSignPKCS11Engine = src.WindowsCodeSignPKCS11Engine;
	dest.WindowsCodeSignPKCS11Module = src.WindowsCodeSignPKCS11Module;
	dest.WindowsCodeSignPKCS11Certfile = src.WindowsCodeSignPKCS11Certfile;
	dest.WindowsCodeSignPKCS11KeyID = src.WindowsCodeSignPKCS11KeyID;
	dest.WindowsCodeSignPKCS11PasswordFormat = src.WindowsCodeSignPKCS11PasswordFormat;
	dest.WindowsCodeSignPKCS11Password = src.WindowsCodeSignPKCS11Password;
	dest.WindowsCodeSignAzureVaultName = src.WindowsCodeSignAzureVaultName;
	dest.WindowsCodeSignAzureCertName = src.WindowsCodeSignAzureCertName;
	dest.WindowsCodeSignAzureAppID = src.WindowsCodeSignAzureAppID;
	dest.WindowsCodeSignAzureAppSecretFormat = src.WindowsCodeSignAzureAppSecretFormat;
	dest.WindowsCodeSignAzureAppSecret = src.WindowsCodeSignAzureAppSecret;
	dest.WindowsCodeSignAzureTenantID = src.WindowsCodeSignAzureTenantID;
	dest.MacOSCodeSign = src.MacOSCodeSign;
}


export type libcomet_BrowseDiskDrivesResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Disks: libcomet_DiskDrive[]
}

export function New_Zero_libcomet_BrowseDiskDrivesResponse(): libcomet_BrowseDiskDrivesResponse {
	return {
		"Status": 0,
		"Message": "",
		"Disks": [],
	};
}

export function libcomet_BrowseDiskDrivesResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseDiskDrivesResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BrowseEDBResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Databases: libcomet_EDBFileInfo[]
}

export function New_Zero_libcomet_BrowseEDBResponse(): libcomet_BrowseEDBResponse {
	return {
		"Status": 0,
		"Message": "",
		"Databases": [],
	};
}

export function libcomet_BrowseEDBResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseEDBResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BrowseHVResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	VirtualMachines: libcomet_HyperVMachineInfo[]
}

export function New_Zero_libcomet_BrowseHVResponse(): libcomet_BrowseHVResponse {
	return {
		"Status": 0,
		"Message": "",
		"VirtualMachines": [],
	};
}

export function libcomet_BrowseHVResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseHVResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BrowseOffice365ListVirtualAccountsResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Objects: libcomet_Office365MixedVirtualAccount[]
}

export function New_Zero_libcomet_BrowseOffice365ListVirtualAccountsResponse(): libcomet_BrowseOffice365ListVirtualAccountsResponse {
	return {
		"Status": 0,
		"Message": "",
		"Objects": [],
	};
}

export function libcomet_BrowseOffice365ListVirtualAccountsResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseOffice365ListVirtualAccountsResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BrowseOffice365ObjectsResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Objects: libcomet_Office365ObjectInfo[]
}

export function New_Zero_libcomet_BrowseOffice365ObjectsResponse(): libcomet_BrowseOffice365ObjectsResponse {
	return {
		"Status": 0,
		"Message": "",
		"Objects": [],
	};
}

export function libcomet_BrowseOffice365ObjectsResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseOffice365ObjectsResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BrowseSQLServerResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Objects: {[k: string]: string}
}

export function New_Zero_libcomet_BrowseSQLServerResponse(): libcomet_BrowseSQLServerResponse {
	return {
		"Status": 0,
		"Message": "",
		"Objects": {},
	};
}

export function libcomet_BrowseSQLServerResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseSQLServerResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BrowseVSSResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	VSSWriters: {[k: string]: libcomet_VSSWriterInfo}
}

export function New_Zero_libcomet_BrowseVSSResponse(): libcomet_BrowseVSSResponse {
	return {
		"Status": 0,
		"Message": "",
		"VSSWriters": {},
	};
}

export function libcomet_BrowseVSSResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_BrowseVSSResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_BucketProperties = {
	OrganizationID: string
	/**
	 * Unix timestamp, in seconds.
	 */
	CreateTime: number
	/**
	 * One of the PASSWORD_FORMAT_ constants
	 */
	ReadWriteKeyFormat: number
	ReadWriteKey: string
	Size: libcomet_SizeMeasurement
}

export function New_Zero_libcomet_BucketProperties(): libcomet_BucketProperties {
	return {
		"OrganizationID": "",
		"CreateTime": 0,
		"ReadWriteKeyFormat": 0,
		"ReadWriteKey": "",
		"Size": New_Zero_libcomet_SizeMeasurement(),
	};
}


export type libcomet_BucketUsageInfo = {
	AccessKey: string
	/**
	 * The servers where this bucket was found. The 0-based indexes here correspond to the entries
	 * inside ConstellationRoleOptions->Servers.
	 */
	ExistsOnServers: number[]
	InUseBy: libcomet_UserOnServer[]
}

export function New_Zero_libcomet_BucketUsageInfo(): libcomet_BucketUsageInfo {
	return {
		"AccessKey": "",
		"ExistsOnServers": [],
		"InUseBy": [],
	};
}


export type libcomet_CometAPIResponseMessage = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
}

export function New_Zero_libcomet_CometAPIResponseMessage(): libcomet_CometAPIResponseMessage {
	return {
		"Status": 0,
		"Message": "",
	};
}


export type libcomet_CometDestinationLocation = {
	/**
	 * The URL for the target Comet Server Storage Role, including http/https and trailing slash
	 */
	CometServer: string
	CometBucket: string
	CometBucketKey: string
}

export function New_Zero_libcomet_CometDestinationLocation(): libcomet_CometDestinationLocation {
	return {
		"CometServer": "",
		"CometBucket": "",
		"CometBucketKey": "",
	};
}


export type libcomet_ConstellationCheckReport = {
	/**
	 * Unix timestamp in seconds
	 */
	CheckStarted: number
	/**
	 * Unix timestamp in seconds
	 */
	CheckCompleted: number
	Usage: {[k: string]: libcomet_BucketUsageInfo}
}

export function New_Zero_libcomet_ConstellationCheckReport(): libcomet_ConstellationCheckReport {
	return {
		"CheckStarted": 0,
		"CheckCompleted": 0,
		"Usage": {},
	};
}


export type libcomet_ConstellationRoleOptions = {
	RoleEnabled: boolean
	DeleteUnusedData: boolean
	Servers: libcomet_RemoteServerAddress[]
}

export function New_Zero_libcomet_ConstellationRoleOptions(): libcomet_ConstellationRoleOptions {
	return {
		"RoleEnabled": false,
		"DeleteUnusedData": false,
		"Servers": [],
	};
}


export type libcomet_ConstellationStats = {
	/**
	 * Unix timestamp, in seconds.
	 */
	LastCheckStart: number
	/**
	 * The total number of Constellation bucket report scans that have been performed since this Comet
	 * Server was last restarted
	 */
	TotalChecksStarted: number
	/**
	 * The total number of buckets that Constellation has successfully deleted since this Comet Server
	 * was last restarted
	 */
	TotalBucketsDeleted: number
	ChecksCurrentlyActive: number
}

export function New_Zero_libcomet_ConstellationStats(): libcomet_ConstellationStats {
	return {
		"LastCheckStart": 0,
		"TotalChecksStarted": 0,
		"TotalBucketsDeleted": 0,
		"ChecksCurrentlyActive": 0,
	};
}


export type libcomet_ConstellationStatusAPIResponse = {
	DeletionEnabled: boolean
	Targets: string[]
	/**
	 * This field is available in Comet 18.6.2 and later.
	 * Omission from JSON will be interpreted as an empty array
	 */
	TargetNames?: string[]
	Stats: libcomet_ConstellationStats
}

export function New_Zero_libcomet_ConstellationStatusAPIResponse(): libcomet_ConstellationStatusAPIResponse {
	return {
		"DeletionEnabled": false,
		"Targets": [],
		"Stats": New_Zero_libcomet_ConstellationStats(),
	};
}


export type libcomet_ContentMeasurement = {
	/**
	 * Unix timestamp in seconds
	 */
	MeasureStarted: number
	/**
	 * Unix timestamp in seconds
	 */
	MeasureCompleted: number
	Components: libcomet_ContentMeasurementComponent[]
}

export function New_Zero_libcomet_ContentMeasurement(): libcomet_ContentMeasurement {
	return {
		"MeasureStarted": 0,
		"MeasureCompleted": 0,
		"Components": [],
	};
}


export type libcomet_ContentMeasurementComponent = {
	Bytes: number
	/**
	 * A list of strings describing which groups of snapshots rely on reaching this component of data.
	 * The strings may take the following formats:
	 * - source_id/CURRENT - this data is required by the most recent backup job snapshot for the
	 * listed Protected Item source.
	 * - source_id/HISTORIC - this data is required by an older backup job snapshot for the listed
	 * Protected Item source.
	 * - TRUNCATED/* - there are too many separate components to show, and this component represents
	 * data that is used by some other combination of components. If present, it will be the only entry
	 * in the UsedBy array.
	 * - the empty string - this amount of data is not currently referenced by any backup job
	 * snapshots. If that remains the case by the next retention pass, this much data will be deleted
	 * to free up space. If present, it will be the only entry in the UsedBy array.
	 */
	UsedBy: string[]
}

export function New_Zero_libcomet_ContentMeasurementComponent(): libcomet_ContentMeasurementComponent {
	return {
		"Bytes": 0,
		"UsedBy": [],
	};
}


export type libcomet_CountJobsResponse = {
	Count: number
}

export function New_Zero_libcomet_CountJobsResponse(): libcomet_CountJobsResponse {
	return {
		"Count": 0,
	};
}


export type libcomet_CreateGroupPolicyResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	PolicyHash: string
}

export function New_Zero_libcomet_CreateGroupPolicyResponse(): libcomet_CreateGroupPolicyResponse {
	return {
		"Status": 0,
		"Message": "",
		"PolicyHash": "",
	};
}

export function libcomet_CreateGroupPolicyResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_CreateGroupPolicyResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_CustomRemoteBucketSettings = {
	URL: string
}

export function New_Zero_libcomet_CustomRemoteBucketSettings(): libcomet_CustomRemoteBucketSettings {
	return {
		"URL": "",
	};
}


export type libcomet_DaysOfWeekConfig = {
	Sunday: boolean
	Monday: boolean
	Tuesday: boolean
	Wednesday: boolean
	Thursday: boolean
	Friday: boolean
	Saturday: boolean
}

export function New_Zero_libcomet_DaysOfWeekConfig(): libcomet_DaysOfWeekConfig {
	return {
		"Sunday": false,
		"Monday": false,
		"Tuesday": false,
		"Wednesday": false,
		"Thursday": false,
		"Friday": false,
		"Saturday": false,
	};
}


export type libcomet_DefaultEmailReportPolicy = {
	/**
	 * If true, the email reports will use the custom configuration that is defined in
	 * UserCustomEmailSettings / Reports fields.
	 * If false, the email reports will use configuration from the policy setting if present, or else
	 * from the built-in system default email report configuration.
	 */
	ShouldOverrideDefaultReports: boolean
	Reports: libcomet_EmailReportConfig[]
}

export function New_Zero_libcomet_DefaultEmailReportPolicy(): libcomet_DefaultEmailReportPolicy {
	return {
		"ShouldOverrideDefaultReports": false,
		"Reports": [],
	};
}

export function libcomet_DefaultEmailReportPolicy_set_embedded_libcomet_UserCustomEmailSettings(dest: libcomet_DefaultEmailReportPolicy, src: libcomet_UserCustomEmailSettings): void {
	dest.Reports = src.Reports;
}


export type libcomet_DefaultSourceWithOSRestriction = {
	SourceConfig: libcomet_SourceConfig
	RestrictOS: number
}

export function New_Zero_libcomet_DefaultSourceWithOSRestriction(): libcomet_DefaultSourceWithOSRestriction {
	return {
		"SourceConfig": New_Zero_libcomet_SourceConfig(),
		"RestrictOS": 0,
	};
}


export type libcomet_DestinationConfig = {
	Description: string
	/**
	 * Unix timestamp in seconds
	 */
	CreateTime: number
	/**
	 * Unix timestamp in seconds
	 */
	ModifyTime: number
	/**
	 * Custom commands to run before the job
	 */
	PreExec: string[]
	/**
	 * Custom commands to run after taking a disk snapshot
	 */
	ThawExec: string[]
	/**
	 * Custom commands to run after the job
	 */
	PostExec: string[]
	/**
	 * One of the DESTINATIONTYPE_ constants
	 */
	DestinationType: number
	/**
	 * The URL for the target Comet Server Storage Role, including http/https and trailing slash
	 */
	CometServer: string
	CometBucket: string
	CometBucketKey: string
	S3Server: string
	S3UsesTLS: boolean
	S3AccessKey: string
	S3SecretKey: string
	S3BucketName: string
	S3Subdir: string
	S3CustomRegion: string
	/**
	 * If true, use legacy v2 signing. If false (default), use modern v4 signing
	 */
	S3UsesV2Signing: boolean
	S3RemoveDeleted: boolean
	S3ObjectLockMode: number
	S3ObjectLockDays: number
	SFTPServer: string
	SFTPUsername: string
	/**
	 * The directory on the SFTP server in which data is stored.
	 */
	SFTPRemotePath: string
	/**
	 * One of the DESTINATION_SFTP_AUTHMODE_ constants
	 */
	SFTPAuthMode: number
	/**
	 * For use with DESTINATION_SFTP_AUTHMODE_PASSWORD only: the SSH password to connect with
	 */
	SFTPPassword: string
	/**
	 * For use with DESTINATION_SFTP_AUTHMODE_PRIVATEKEY only: the SSH private key to connect with, in
	 * OpenSSH format.
	 */
	SFTPPrivateKey: string
	/**
	 * If true, then the SFTPCustomAuth_KnownHostsFile will be used to verify the remote SSH server's
	 * host key, using Trust On First Use (TOFU).
	 */
	SFTPCustomAuth_UseKnownHostsFile: boolean
	/**
	 * If SFTPCustomAuth_UseKnownHostFile is true, the path to the SSH known_hosts file.
	 */
	SFTPCustomAuth_KnownHostsFile: string
	FTPServer: string
	FTPUsername: string
	FTPPassword: string
	/**
	 * If true, store data in the default home directory given by the FTP server. If false, store data
	 * in the FTPCustomBaseDirectory path.
	 */
	FTPBaseUseHomeDirectory: boolean
	/**
	 * If FTPBaseUseHomeDirectory is false, this field controls the path where data is stored.
	 */
	FTPCustomBaseDirectory: string
	/**
	 * Control whether this is plaintext FTP or secure FTPS by using one of the FTPS_MODE_ constants.
	 */
	FTPSMode: number
	FTPPort: number
	/**
	 * If set to zero, uses a system default value that is not unlimited.
	 */
	FTPMaxConnections: number
	FTPAcceptInvalidSSL: boolean
	AZBAccountName: string
	AZBAccountKey: string
	AZBContainer: string
	/**
	 * The base URL for the Azure Blob Storage service. Leave blank to use the global default URL.
	 */
	AZBRealm: string
	AZBPrefix: string
	LocalcopyPath: string
	/**
	 * If logging in to a Windows network share (SMB/CIFS) is required, enter the username here.
	 */
	LocalcopyWinSMBUsername: string
	/**
	 * If logging in to a Windows network share (SMB/CIFS) is required, enter the password here. The
	 * password may be hashed as per the LocalcopyWinSMBPasswordFormat field.
	 */
	LocalcopyWinSMBPassword: string
	/**
	 * One of the PASSWORD_FORMAT_ constants. It controls the hash format of the
	 * LocalcopyWinSMBPassword field.
	 */
	LocalcopyWinSMBPasswordFormat: number
	Swift: libcomet_SwiftDestinationLocation
	B2: libcomet_B2DestinationLocation
	/**
	 * This field is available in Comet 23.6.9 and later.
	 */
	WebDav: libcomet_WebDavDestinationLocation
	Storj: libcomet_StorjDestinationLocation
	/**
	 * A list of underlying destinations, that will be combined and presented as one.
	 */
	SpanTargets: libcomet_DestinationLocation[]
	/**
	 * If true, this Spanned destination will use a consistent hashing scheme
	 * to immediately find specific files on exactly one of the target destinations.
	 * In the Static Slots mode, the span targets cannot be moved or merged, and
	 * the files must always remain in their original location.
	 *
	 * If false, the Spanned destination system will search all targets to find
	 * the requested file. This is slightly slower, but allows you to freely merge,
	 * split, and reorder the underlying destination locations.
	 *
	 * The default option is false.
	 */
	SpanUseStaticSlots: boolean
	Tag: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	EncryptionKeyEncryptionMethod: number
	EncryptedEncryptionKey: string
	/**
	 * Unix timestamp in seconds. If zero, the Storage Vault has not yet been initialized for the first
	 * time.
	 */
	RepoInitTimestamp: number
	/**
	 * Storage Vault quota
	 */
	StorageLimitEnabled: boolean
	/**
	 * Storage Vault quota
	 */
	StorageLimitBytes: number
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Statistics?: libcomet_DestinationStatistics
	/**
	 * Configure the retention policy for this Storage Vault. The rules will be applied to any snapshot
	 * inside this Storage Vault, unless that snapshot belongs to a Protected Item source that has an
	 * overriding retention policy.
	 */
	DefaultRetention: libcomet_RetentionPolicy
	/**
	 * The "Prevent users from viewing the actual storage type" option
	 */
	RebrandStorage: boolean
}

export function New_Zero_libcomet_DestinationConfig(): libcomet_DestinationConfig {
	return {
		"Description": "",
		"CreateTime": 0,
		"ModifyTime": 0,
		"PreExec": [],
		"ThawExec": [],
		"PostExec": [],
		"DestinationType": 0,
		"CometServer": "",
		"CometBucket": "",
		"CometBucketKey": "",
		"S3Server": "",
		"S3UsesTLS": false,
		"S3AccessKey": "",
		"S3SecretKey": "",
		"S3BucketName": "",
		"S3Subdir": "",
		"S3CustomRegion": "",
		"S3UsesV2Signing": false,
		"S3RemoveDeleted": false,
		"S3ObjectLockMode": 0,
		"S3ObjectLockDays": 0,
		"SFTPServer": "",
		"SFTPUsername": "",
		"SFTPRemotePath": "",
		"SFTPAuthMode": 0,
		"SFTPPassword": "",
		"SFTPPrivateKey": "",
		"SFTPCustomAuth_UseKnownHostsFile": false,
		"SFTPCustomAuth_KnownHostsFile": "",
		"FTPServer": "",
		"FTPUsername": "",
		"FTPPassword": "",
		"FTPBaseUseHomeDirectory": false,
		"FTPCustomBaseDirectory": "",
		"FTPSMode": 0,
		"FTPPort": 0,
		"FTPMaxConnections": 0,
		"FTPAcceptInvalidSSL": false,
		"AZBAccountName": "",
		"AZBAccountKey": "",
		"AZBContainer": "",
		"AZBRealm": "",
		"AZBPrefix": "",
		"LocalcopyPath": "",
		"LocalcopyWinSMBUsername": "",
		"LocalcopyWinSMBPassword": "",
		"LocalcopyWinSMBPasswordFormat": 0,
		"Swift": New_Zero_libcomet_SwiftDestinationLocation(),
		"B2": New_Zero_libcomet_B2DestinationLocation(),
		"WebDav": New_Zero_libcomet_WebDavDestinationLocation(),
		"Storj": New_Zero_libcomet_StorjDestinationLocation(),
		"SpanTargets": [],
		"SpanUseStaticSlots": false,
		"Tag": "",
		"EncryptionKeyEncryptionMethod": 0,
		"EncryptedEncryptionKey": "",
		"RepoInitTimestamp": 0,
		"StorageLimitEnabled": false,
		"StorageLimitBytes": 0,
		"DefaultRetention": New_Zero_libcomet_RetentionPolicy(),
		"RebrandStorage": false,
	};
}

export function libcomet_DestinationConfig_set_embedded_libcomet_DestinationLocation(dest: libcomet_DestinationConfig, src: libcomet_DestinationLocation): void {
	dest.DestinationType = src.DestinationType;
	dest.CometServer = src.CometServer;
	dest.CometBucket = src.CometBucket;
	dest.CometBucketKey = src.CometBucketKey;
	dest.S3Server = src.S3Server;
	dest.S3UsesTLS = src.S3UsesTLS;
	dest.S3AccessKey = src.S3AccessKey;
	dest.S3SecretKey = src.S3SecretKey;
	dest.S3BucketName = src.S3BucketName;
	dest.S3Subdir = src.S3Subdir;
	dest.S3CustomRegion = src.S3CustomRegion;
	dest.S3UsesV2Signing = src.S3UsesV2Signing;
	dest.S3RemoveDeleted = src.S3RemoveDeleted;
	dest.S3ObjectLockMode = src.S3ObjectLockMode;
	dest.S3ObjectLockDays = src.S3ObjectLockDays;
	dest.SFTPServer = src.SFTPServer;
	dest.SFTPUsername = src.SFTPUsername;
	dest.SFTPRemotePath = src.SFTPRemotePath;
	dest.SFTPAuthMode = src.SFTPAuthMode;
	dest.SFTPPassword = src.SFTPPassword;
	dest.SFTPPrivateKey = src.SFTPPrivateKey;
	dest.SFTPCustomAuth_UseKnownHostsFile = src.SFTPCustomAuth_UseKnownHostsFile;
	dest.SFTPCustomAuth_KnownHostsFile = src.SFTPCustomAuth_KnownHostsFile;
	dest.FTPServer = src.FTPServer;
	dest.FTPUsername = src.FTPUsername;
	dest.FTPPassword = src.FTPPassword;
	dest.FTPBaseUseHomeDirectory = src.FTPBaseUseHomeDirectory;
	dest.FTPCustomBaseDirectory = src.FTPCustomBaseDirectory;
	dest.FTPSMode = src.FTPSMode;
	dest.FTPPort = src.FTPPort;
	dest.FTPMaxConnections = src.FTPMaxConnections;
	dest.FTPAcceptInvalidSSL = src.FTPAcceptInvalidSSL;
	dest.AZBAccountName = src.AZBAccountName;
	dest.AZBAccountKey = src.AZBAccountKey;
	dest.AZBContainer = src.AZBContainer;
	dest.AZBRealm = src.AZBRealm;
	dest.AZBPrefix = src.AZBPrefix;
	dest.LocalcopyPath = src.LocalcopyPath;
	dest.LocalcopyWinSMBUsername = src.LocalcopyWinSMBUsername;
	dest.LocalcopyWinSMBPassword = src.LocalcopyWinSMBPassword;
	dest.LocalcopyWinSMBPasswordFormat = src.LocalcopyWinSMBPasswordFormat;
	dest.Swift = src.Swift;
	dest.B2 = src.B2;
	dest.WebDav = src.WebDav;
	dest.Storj = src.Storj;
	dest.SpanTargets = src.SpanTargets;
	dest.SpanUseStaticSlots = src.SpanUseStaticSlots;
	dest.Tag = src.Tag;
}


/**
 * DestinationLocation describes the underlying storage location for a Storage Vault.
 * Prior to Comet 17.3.3 this was an embedded part of the DestinationConfig type.
 * This type is available in Comet 17.3.3 and later.
 */
export type libcomet_DestinationLocation = {
	/**
	 * One of the DESTINATIONTYPE_ constants
	 */
	DestinationType: number
	/**
	 * The URL for the target Comet Server Storage Role, including http/https and trailing slash
	 */
	CometServer: string
	CometBucket: string
	CometBucketKey: string
	S3Server: string
	S3UsesTLS: boolean
	S3AccessKey: string
	S3SecretKey: string
	S3BucketName: string
	S3Subdir: string
	S3CustomRegion: string
	/**
	 * If true, use legacy v2 signing. If false (default), use modern v4 signing
	 */
	S3UsesV2Signing: boolean
	S3RemoveDeleted: boolean
	S3ObjectLockMode: number
	S3ObjectLockDays: number
	SFTPServer: string
	SFTPUsername: string
	/**
	 * The directory on the SFTP server in which data is stored.
	 */
	SFTPRemotePath: string
	/**
	 * One of the DESTINATION_SFTP_AUTHMODE_ constants
	 */
	SFTPAuthMode: number
	/**
	 * For use with DESTINATION_SFTP_AUTHMODE_PASSWORD only: the SSH password to connect with
	 */
	SFTPPassword: string
	/**
	 * For use with DESTINATION_SFTP_AUTHMODE_PRIVATEKEY only: the SSH private key to connect with, in
	 * OpenSSH format.
	 */
	SFTPPrivateKey: string
	/**
	 * If true, then the SFTPCustomAuth_KnownHostsFile will be used to verify the remote SSH server's
	 * host key, using Trust On First Use (TOFU).
	 */
	SFTPCustomAuth_UseKnownHostsFile: boolean
	/**
	 * If SFTPCustomAuth_UseKnownHostFile is true, the path to the SSH known_hosts file.
	 */
	SFTPCustomAuth_KnownHostsFile: string
	FTPServer: string
	FTPUsername: string
	FTPPassword: string
	/**
	 * If true, store data in the default home directory given by the FTP server. If false, store data
	 * in the FTPCustomBaseDirectory path.
	 */
	FTPBaseUseHomeDirectory: boolean
	/**
	 * If FTPBaseUseHomeDirectory is false, this field controls the path where data is stored.
	 */
	FTPCustomBaseDirectory: string
	/**
	 * Control whether this is plaintext FTP or secure FTPS by using one of the FTPS_MODE_ constants.
	 */
	FTPSMode: number
	FTPPort: number
	/**
	 * If set to zero, uses a system default value that is not unlimited.
	 */
	FTPMaxConnections: number
	FTPAcceptInvalidSSL: boolean
	AZBAccountName: string
	AZBAccountKey: string
	AZBContainer: string
	/**
	 * The base URL for the Azure Blob Storage service. Leave blank to use the global default URL.
	 */
	AZBRealm: string
	AZBPrefix: string
	LocalcopyPath: string
	/**
	 * If logging in to a Windows network share (SMB/CIFS) is required, enter the username here.
	 */
	LocalcopyWinSMBUsername: string
	/**
	 * If logging in to a Windows network share (SMB/CIFS) is required, enter the password here. The
	 * password may be hashed as per the LocalcopyWinSMBPasswordFormat field.
	 */
	LocalcopyWinSMBPassword: string
	/**
	 * One of the PASSWORD_FORMAT_ constants. It controls the hash format of the
	 * LocalcopyWinSMBPassword field.
	 */
	LocalcopyWinSMBPasswordFormat: number
	Swift: libcomet_SwiftDestinationLocation
	B2: libcomet_B2DestinationLocation
	/**
	 * This field is available in Comet 23.6.9 and later.
	 */
	WebDav: libcomet_WebDavDestinationLocation
	Storj: libcomet_StorjDestinationLocation
	/**
	 * A list of underlying destinations, that will be combined and presented as one.
	 */
	SpanTargets: libcomet_DestinationLocation[]
	/**
	 * If true, this Spanned destination will use a consistent hashing scheme
	 * to immediately find specific files on exactly one of the target destinations.
	 * In the Static Slots mode, the span targets cannot be moved or merged, and
	 * the files must always remain in their original location.
	 *
	 * If false, the Spanned destination system will search all targets to find
	 * the requested file. This is slightly slower, but allows you to freely merge,
	 * split, and reorder the underlying destination locations.
	 *
	 * The default option is false.
	 */
	SpanUseStaticSlots: boolean
	Tag: string
}

export function New_Zero_libcomet_DestinationLocation(): libcomet_DestinationLocation {
	return {
		"DestinationType": 0,
		"CometServer": "",
		"CometBucket": "",
		"CometBucketKey": "",
		"S3Server": "",
		"S3UsesTLS": false,
		"S3AccessKey": "",
		"S3SecretKey": "",
		"S3BucketName": "",
		"S3Subdir": "",
		"S3CustomRegion": "",
		"S3UsesV2Signing": false,
		"S3RemoveDeleted": false,
		"S3ObjectLockMode": 0,
		"S3ObjectLockDays": 0,
		"SFTPServer": "",
		"SFTPUsername": "",
		"SFTPRemotePath": "",
		"SFTPAuthMode": 0,
		"SFTPPassword": "",
		"SFTPPrivateKey": "",
		"SFTPCustomAuth_UseKnownHostsFile": false,
		"SFTPCustomAuth_KnownHostsFile": "",
		"FTPServer": "",
		"FTPUsername": "",
		"FTPPassword": "",
		"FTPBaseUseHomeDirectory": false,
		"FTPCustomBaseDirectory": "",
		"FTPSMode": 0,
		"FTPPort": 0,
		"FTPMaxConnections": 0,
		"FTPAcceptInvalidSSL": false,
		"AZBAccountName": "",
		"AZBAccountKey": "",
		"AZBContainer": "",
		"AZBRealm": "",
		"AZBPrefix": "",
		"LocalcopyPath": "",
		"LocalcopyWinSMBUsername": "",
		"LocalcopyWinSMBPassword": "",
		"LocalcopyWinSMBPasswordFormat": 0,
		"Swift": New_Zero_libcomet_SwiftDestinationLocation(),
		"B2": New_Zero_libcomet_B2DestinationLocation(),
		"WebDav": New_Zero_libcomet_WebDavDestinationLocation(),
		"Storj": New_Zero_libcomet_StorjDestinationLocation(),
		"SpanTargets": [],
		"SpanUseStaticSlots": false,
		"Tag": "",
	};
}

export function libcomet_DestinationLocation_set_embedded_libcomet_CometDestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_CometDestinationLocation): void {
	dest.CometServer = src.CometServer;
	dest.CometBucket = src.CometBucket;
	dest.CometBucketKey = src.CometBucketKey;
}

export function libcomet_DestinationLocation_set_embedded_libcomet_S3DestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_S3DestinationLocation): void {
	dest.S3Server = src.S3Server;
	dest.S3UsesTLS = src.S3UsesTLS;
	dest.S3AccessKey = src.S3AccessKey;
	dest.S3SecretKey = src.S3SecretKey;
	dest.S3BucketName = src.S3BucketName;
	dest.S3Subdir = src.S3Subdir;
	dest.S3CustomRegion = src.S3CustomRegion;
	dest.S3UsesV2Signing = src.S3UsesV2Signing;
	dest.S3RemoveDeleted = src.S3RemoveDeleted;
	dest.S3ObjectLockMode = src.S3ObjectLockMode;
	dest.S3ObjectLockDays = src.S3ObjectLockDays;
}

export function libcomet_DestinationLocation_set_embedded_libcomet_SFTPDestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_SFTPDestinationLocation): void {
	dest.SFTPServer = src.SFTPServer;
	dest.SFTPUsername = src.SFTPUsername;
	dest.SFTPRemotePath = src.SFTPRemotePath;
	dest.SFTPAuthMode = src.SFTPAuthMode;
	dest.SFTPPassword = src.SFTPPassword;
	dest.SFTPPrivateKey = src.SFTPPrivateKey;
	dest.SFTPCustomAuth_UseKnownHostsFile = src.SFTPCustomAuth_UseKnownHostsFile;
	dest.SFTPCustomAuth_KnownHostsFile = src.SFTPCustomAuth_KnownHostsFile;
}

export function libcomet_DestinationLocation_set_embedded_libcomet_FTPDestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_FTPDestinationLocation): void {
	dest.FTPServer = src.FTPServer;
	dest.FTPUsername = src.FTPUsername;
	dest.FTPPassword = src.FTPPassword;
	dest.FTPBaseUseHomeDirectory = src.FTPBaseUseHomeDirectory;
	dest.FTPCustomBaseDirectory = src.FTPCustomBaseDirectory;
	dest.FTPSMode = src.FTPSMode;
	dest.FTPPort = src.FTPPort;
	dest.FTPMaxConnections = src.FTPMaxConnections;
	dest.FTPAcceptInvalidSSL = src.FTPAcceptInvalidSSL;
}

export function libcomet_DestinationLocation_set_embedded_libcomet_AzureDestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_AzureDestinationLocation): void {
	dest.AZBAccountName = src.AZBAccountName;
	dest.AZBAccountKey = src.AZBAccountKey;
	dest.AZBContainer = src.AZBContainer;
	dest.AZBRealm = src.AZBRealm;
	dest.AZBPrefix = src.AZBPrefix;
}

export function libcomet_DestinationLocation_set_embedded_libcomet_LocalDestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_LocalDestinationLocation): void {
	dest.LocalcopyPath = src.LocalcopyPath;
	dest.LocalcopyWinSMBUsername = src.LocalcopyWinSMBUsername;
	dest.LocalcopyWinSMBPassword = src.LocalcopyWinSMBPassword;
	dest.LocalcopyWinSMBPasswordFormat = src.LocalcopyWinSMBPasswordFormat;
}

export function libcomet_DestinationLocation_set_embedded_libcomet_SpannedDestinationLocation(dest: libcomet_DestinationLocation, src: libcomet_SpannedDestinationLocation): void {
	dest.SpanTargets = src.SpanTargets;
	dest.SpanUseStaticSlots = src.SpanUseStaticSlots;
}


export type libcomet_DestinationStatistics = {
	ClientProvidedSize: libcomet_SizeMeasurement
	ClientProvidedContent: libcomet_ContentMeasurement
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	LastSuccessfulDeepVerify_GUID?: string
	/**
	 * Unix timestamp in seconds
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	LastSuccessfulDeepVerify_StartTime?: number
	/**
	 * Unix timestamp in seconds
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	LastSuccessfulDeepVerify_EndTime?: number
}

export function New_Zero_libcomet_DestinationStatistics(): libcomet_DestinationStatistics {
	return {
		"ClientProvidedSize": New_Zero_libcomet_SizeMeasurement(),
		"ClientProvidedContent": New_Zero_libcomet_ContentMeasurement(),
	};
}


export type libcomet_DeviceConfig = {
	FriendlyName: string
	/**
	 * Unix timestamp in seconds
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	RegistrationTime?: number
	/**
	 * The operating system that the device uses.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	PlatformVersion?: libcomet_OSInfo
	/**
	 * Minimal information about the device's private Protected Items, so that other devices can safely
	 * run retention passes on a shared Storage Vault.
	 * Omission from JSON will be interpreted as an empty map
	 */
	Sources?: {[k: string]: libcomet_SourceBasicInfo}
	/**
	 * The device's reported timezone in IANA format.
	 * Omission from JSON will be interpreted as empty-string
	 */
	DeviceTimezone?: string
	/**
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as empty-string
	 */
	ClientVersion?: string
}

export function New_Zero_libcomet_DeviceConfig(): libcomet_DeviceConfig {
	return {
		"FriendlyName": "",
	};
}


export type libcomet_DiskDrive = {
	ID: string
	DeviceName: string
	Caption: string
	Model: string
	SerialNumber: string
	Size: number
	Partitions: libcomet_Partition[]
	Flags: number
	Cylinders: number
	Heads: number
	Sectors: number
	SectorSize: number
}

export function New_Zero_libcomet_DiskDrive(): libcomet_DiskDrive {
	return {
		"ID": "",
		"DeviceName": "",
		"Caption": "",
		"Model": "",
		"SerialNumber": "",
		"Size": 0,
		"Partitions": [],
		"Flags": 0,
		"Cylinders": 0,
		"Heads": 0,
		"Sectors": 0,
		"SectorSize": 0,
	};
}


export type libcomet_DispatcherAdminSourcesResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	ImportSources: {[k: string]: string}
}

export function New_Zero_libcomet_DispatcherAdminSourcesResponse(): libcomet_DispatcherAdminSourcesResponse {
	return {
		"Status": 0,
		"Message": "",
		"ImportSources": {},
	};
}

export function libcomet_DispatcherAdminSourcesResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_DispatcherAdminSourcesResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_DispatcherStoredObjectsResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	StoredObjects: libcomet_StoredObject[]
}

export function New_Zero_libcomet_DispatcherStoredObjectsResponse(): libcomet_DispatcherStoredObjectsResponse {
	return {
		"Status": 0,
		"Message": "",
		"StoredObjects": [],
	};
}

export function libcomet_DispatcherStoredObjectsResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_DispatcherStoredObjectsResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_DispatcherVaultSnapshotsResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Snapshots: libcomet_VaultSnapshot[]
}

export function New_Zero_libcomet_DispatcherVaultSnapshotsResponse(): libcomet_DispatcherVaultSnapshotsResponse {
	return {
		"Status": 0,
		"Message": "",
		"Snapshots": [],
	};
}

export function libcomet_DispatcherVaultSnapshotsResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_DispatcherVaultSnapshotsResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_DispatcherWindiskSnapshotResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	WindiskSnapshot: libcomet_DiskDrive[]
}

export function New_Zero_libcomet_DispatcherWindiskSnapshotResponse(): libcomet_DispatcherWindiskSnapshotResponse {
	return {
		"Status": 0,
		"Message": "",
		"WindiskSnapshot": [],
	};
}

export function libcomet_DispatcherWindiskSnapshotResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_DispatcherWindiskSnapshotResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_EDBFileInfo = {
	Name: string
	/**
	 * GUID
	 */
	Guid: string
	ServerName: string
	CircularLoggingEnabled: boolean
}

export function New_Zero_libcomet_EDBFileInfo(): libcomet_EDBFileInfo {
	return {
		"Name": "",
		"Guid": "",
		"ServerName": "",
		"CircularLoggingEnabled": false,
	};
}


export type libcomet_EmailOptions = {
	FromEmail: string
	FromName: string
	/**
	 * One of the EMAIL_DELIVERY_ constants
	 */
	Mode: string
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	EmailReportingOptions?: libcomet_EmailReportingOption[]
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SMTPHost?: string
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	SMTPPort?: number
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SMTPUsername?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SMTPPassword?: string
	/**
	 * Omission from JSON will be interpreted as false
	 */
	SMTPAllowInvalidCertificate?: boolean
	/**
	 * Omission from JSON will be interpreted as false
	 */
	SMTPAllowUnencrypted?: boolean
}

export function New_Zero_libcomet_EmailOptions(): libcomet_EmailOptions {
	return {
		"FromEmail": "",
		"FromName": "",
		"Mode": "",
	};
}

export function libcomet_EmailOptions_set_embedded_libcomet_AdminEmailOptions(dest: libcomet_EmailOptions, src: libcomet_AdminEmailOptions): void {
	dest.FromEmail = src.FromEmail;
	dest.FromName = src.FromName;
}


export type libcomet_EmailReportConfig = {
	/**
	 * One of the EMAILREPORTTYPE_ constants
	 */
	ReportType: number
	/**
	 * Used as a list of scheduled times to send
	 */
	SummaryFrequency: libcomet_ScheduleConfig[]
	/**
	 * Used to the determine the time bounds of a report
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	TimeSpan?: libcomet_TimeSpan
	Filter: libcomet_SearchClause
}

export function New_Zero_libcomet_EmailReportConfig(): libcomet_EmailReportConfig {
	return {
		"ReportType": 0,
		"SummaryFrequency": [],
		"Filter": New_Zero_libcomet_SearchClause(),
	};
}


export type libcomet_EmailReportGeneratedPreview = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	From: string
	To: string[]
	EmailSubject: string
	EmailBodyHTML: string
	EmailBodyPlaintext: string
}

export function New_Zero_libcomet_EmailReportGeneratedPreview(): libcomet_EmailReportGeneratedPreview {
	return {
		"Status": 0,
		"Message": "",
		"From": "",
		"To": [],
		"EmailSubject": "",
		"EmailBodyHTML": "",
		"EmailBodyPlaintext": "",
	};
}

export function libcomet_EmailReportGeneratedPreview_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_EmailReportGeneratedPreview, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_EmailReportingOption = {
	EmailReportConfig: libcomet_EmailReportConfig
	/**
	 * A supported language code (e.g. "en_US" or the DEFAULT_LANGUAGE constant)
	 */
	LanguageCode: string
	/**
	 * The timezone in IANA format (e.g. "Pacific/Auckland" or the DEFAULT_TIMEZONE constant)
	 */
	LocalTimezone: string
	Recipients: string[]
}

export function New_Zero_libcomet_EmailReportingOption(): libcomet_EmailReportingOption {
	return {
		"EmailReportConfig": New_Zero_libcomet_EmailReportConfig(),
		"LanguageCode": "",
		"LocalTimezone": "",
		"Recipients": [],
	};
}


export type libcomet_ExternalAuthenticationSource = {
	Type: string
	Description: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	RemoteAddress?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Username?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Password?: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	LDAP?: libcomet_ExternalLDAPAuthenticationSourceSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	OIDC?: libcomet_OidcConfig
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	B2?: libcomet_B2VirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Wasabi?: libcomet_WasabiVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Custom?: libcomet_CustomRemoteBucketSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	S3?: libcomet_S3GenericVirtualStorageRole
	/**
	 * Amazon AWS - Virtual Storage Role
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	AWS?: libcomet_AmazonAWSVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Storj?: libcomet_StorjVirtualStorageRoleSetting
	NewUserPermissions: libcomet_AdminUserPermissions
}

export function New_Zero_libcomet_ExternalAuthenticationSource(): libcomet_ExternalAuthenticationSource {
	return {
		"Type": "",
		"Description": "",
		"NewUserPermissions": New_Zero_libcomet_AdminUserPermissions(),
	};
}

export function libcomet_ExternalAuthenticationSource_set_embedded_libcomet_RemoteServerAddress(dest: libcomet_ExternalAuthenticationSource, src: libcomet_RemoteServerAddress): void {
	dest.Type = src.Type;
	dest.Description = src.Description;
	dest.RemoteAddress = src.RemoteAddress;
	dest.Username = src.Username;
	dest.Password = src.Password;
	dest.LDAP = src.LDAP;
	dest.OIDC = src.OIDC;
	dest.B2 = src.B2;
	dest.Wasabi = src.Wasabi;
	dest.Custom = src.Custom;
	dest.S3 = src.S3;
	dest.AWS = src.AWS;
	dest.Storj = src.Storj;
}


export type libcomet_ExternalAuthenticationSourceDisplay = {
	DisplayName: string
	LoginStartURL: string
}

export function New_Zero_libcomet_ExternalAuthenticationSourceDisplay(): libcomet_ExternalAuthenticationSourceDisplay {
	return {
		"DisplayName": "",
		"LoginStartURL": "",
	};
}


export type libcomet_ExternalAuthenticationSourceResponse = {
	Status: number
	Message: string
	ID: string
	Source: libcomet_ExternalAuthenticationSource
}

export function New_Zero_libcomet_ExternalAuthenticationSourceResponse(): libcomet_ExternalAuthenticationSourceResponse {
	return {
		"Status": 0,
		"Message": "",
		"ID": "",
		"Source": New_Zero_libcomet_ExternalAuthenticationSource(),
	};
}


export type libcomet_ExternalLDAPAuthenticationSourceServer = {
	Hostname: string
	Port: number
	/**
	 * One of the LDAPSECURITYMETHOD_ constants (e.g. "plain" / "ldaps" / "starttls")
	 */
	SecurityMethod: string
	AcceptInvalidSSL: boolean
}

export function New_Zero_libcomet_ExternalLDAPAuthenticationSourceServer(): libcomet_ExternalLDAPAuthenticationSourceServer {
	return {
		"Hostname": "",
		"Port": 0,
		"SecurityMethod": "",
		"AcceptInvalidSSL": false,
	};
}


export type libcomet_ExternalLDAPAuthenticationSourceSettings = {
	Hostname: string
	Port: number
	/**
	 * One of the LDAPSECURITYMETHOD_ constants (e.g. "plain" / "ldaps" / "starttls")
	 */
	SecurityMethod: string
	AcceptInvalidSSL: boolean
	FallbackServers: libcomet_ExternalLDAPAuthenticationSourceServer[]
	BindUser: string
	BindPassword: string
	SearchDN: string
	SearchFilter: string
}

export function New_Zero_libcomet_ExternalLDAPAuthenticationSourceSettings(): libcomet_ExternalLDAPAuthenticationSourceSettings {
	return {
		"Hostname": "",
		"Port": 0,
		"SecurityMethod": "",
		"AcceptInvalidSSL": false,
		"FallbackServers": [],
		"BindUser": "",
		"BindPassword": "",
		"SearchDN": "",
		"SearchFilter": "",
	};
}

export function libcomet_ExternalLDAPAuthenticationSourceSettings_set_embedded_libcomet_ExternalLDAPAuthenticationSourceServer(dest: libcomet_ExternalLDAPAuthenticationSourceSettings, src: libcomet_ExternalLDAPAuthenticationSourceServer): void {
	dest.Hostname = src.Hostname;
	dest.Port = src.Port;
	dest.SecurityMethod = src.SecurityMethod;
	dest.AcceptInvalidSSL = src.AcceptInvalidSSL;
}


export type libcomet_ExtraFileExclusion = {
	/**
	 * The glob or regular expression to exclude from backup jobs
	 */
	Exclude: string
	/**
	 * Choose whether the 'Exclude' parameter will be treated as a regular expression (true) or a glob
	 * (false)
	 */
	Regex: boolean
	/**
	 * Either OS_ANY or one of the OS_ONLY constants
	 */
	RestrictOS: number
}

export function New_Zero_libcomet_ExtraFileExclusion(): libcomet_ExtraFileExclusion {
	return {
		"Exclude": "",
		"Regex": false,
		"RestrictOS": 0,
	};
}


export type libcomet_FTPDestinationLocation = {
	FTPServer: string
	FTPUsername: string
	FTPPassword: string
	/**
	 * If true, store data in the default home directory given by the FTP server. If false, store data
	 * in the FTPCustomBaseDirectory path.
	 */
	FTPBaseUseHomeDirectory: boolean
	/**
	 * If FTPBaseUseHomeDirectory is false, this field controls the path where data is stored.
	 */
	FTPCustomBaseDirectory: string
	/**
	 * Control whether this is plaintext FTP or secure FTPS by using one of the FTPS_MODE_ constants.
	 */
	FTPSMode: number
	FTPPort: number
	/**
	 * If set to zero, uses a system default value that is not unlimited.
	 */
	FTPMaxConnections: number
	FTPAcceptInvalidSSL: boolean
}

export function New_Zero_libcomet_FTPDestinationLocation(): libcomet_FTPDestinationLocation {
	return {
		"FTPServer": "",
		"FTPUsername": "",
		"FTPPassword": "",
		"FTPBaseUseHomeDirectory": false,
		"FTPCustomBaseDirectory": "",
		"FTPSMode": 0,
		"FTPPort": 0,
		"FTPMaxConnections": 0,
		"FTPAcceptInvalidSSL": false,
	};
}


/**
 * FileOption defines the configuration for Comet Server to log live events to a file. See the SEVT_
 * constants for more information.
 * This type is available in Comet 23.3.7 and later.
 */
export type libcomet_FileOption = {
	/**
	 * The prefix for the log filename. It will be stored in the same file location as the Comet Server
	 * log files
	 */
	Filename: string
	/**
	 * Configure a subset of allowed event types (see SEVT_ constants). If the array is empty, all
	 * events will be sent
	 * Omission from JSON will be interpreted as an empty array
	 */
	AllowEventTypes?: number[]
	/**
	 * One of the STREAM_LEVEL_ constants. This controls how much data is logged into the file
	 * Omission from JSON will be interpreted as empty-string
	 */
	Level?: string
	/**
	 * Enables pruning of log files
	 * Omission from JSON will be interpreted as false
	 */
	PruningEnabled?: boolean
	/**
	 * Limit in days to keep log files when PruningEnabled is set to true. If not set or 0, uses
	 * server's PruneLogsAfterDays
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	PruningLimit?: number
}

export function New_Zero_libcomet_FileOption(): libcomet_FileOption {
	return {
		"Filename": "",
	};
}


export type libcomet_GetGroupPolicyResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Policy: libcomet_GroupPolicy
	PolicyHash: string
}

export function New_Zero_libcomet_GetGroupPolicyResponse(): libcomet_GetGroupPolicyResponse {
	return {
		"Status": 0,
		"Message": "",
		"Policy": New_Zero_libcomet_GroupPolicy(),
		"PolicyHash": "",
	};
}

export function libcomet_GetGroupPolicyResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_GetGroupPolicyResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_GetProfileAndHashResponseMessage = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	/**
	 * A hash identifier for the current state of the user's profile. If you supply this in the
	 * AdminSetUserProfileHash API, the server can safely reject your change if another change has
	 * happened concurrently. This allows you to retry the request.
	 */
	ProfileHash: string
	Profile: libcomet_UserProfileConfig
}

export function New_Zero_libcomet_GetProfileAndHashResponseMessage(): libcomet_GetProfileAndHashResponseMessage {
	return {
		"Status": 0,
		"Message": "",
		"ProfileHash": "",
		"Profile": New_Zero_libcomet_UserProfileConfig(),
	};
}

export function libcomet_GetProfileAndHashResponseMessage_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_GetProfileAndHashResponseMessage, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_GetProfileHashResponseMessage = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	ProfileHash: string
}

export function New_Zero_libcomet_GetProfileHashResponseMessage(): libcomet_GetProfileHashResponseMessage {
	return {
		"Status": 0,
		"Message": "",
		"ProfileHash": "",
	};
}

export function libcomet_GetProfileHashResponseMessage_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_GetProfileHashResponseMessage, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_GlobalOverrideOptions = {
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	RandomDelaySecs?: number
}

export function New_Zero_libcomet_GlobalOverrideOptions(): libcomet_GlobalOverrideOptions {
	return {
	};
}


export type libcomet_GroupPolicy = {
	Description: string
	OrganizationID: string
	Policy: libcomet_UserPolicy
	/**
	 * DefaultUserPolicy marks that this UserPolicy should be applied to all new users. The Comet
	 * Server will ensure that only one policy can be set as default.
	 */
	DefaultUserPolicy: boolean
	/**
	 * Unix timestamp in seconds. May be zero for Policies created prior to Comet 23.3.3.
	 */
	CreatedDate: number
	/**
	 * Unix timestamp in seconds. May be zero for Policies created prior to Comet 23.3.3.
	 */
	ModifiedDate: number
}

export function New_Zero_libcomet_GroupPolicy(): libcomet_GroupPolicy {
	return {
		"Description": "",
		"OrganizationID": "",
		"Policy": New_Zero_libcomet_UserPolicy(),
		"DefaultUserPolicy": false,
		"CreatedDate": 0,
		"ModifiedDate": 0,
	};
}


export type libcomet_HTTPConnectorOptions = {
	/**
	 * ListenAddress__DONOTUSEDIRECTLY
	 */
	ListenAddress: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SSLCertPath?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SSLIntermediate?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SSLCertKey?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	AutoSSLDomains?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SSLPfxPath?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SSLPfxPassword?: string
}

export function New_Zero_libcomet_HTTPConnectorOptions(): libcomet_HTTPConnectorOptions {
	return {
		"ListenAddress": "",
	};
}


export type libcomet_HourSchedConfig = {
	Hour: number
	Minutes: number
}

export function New_Zero_libcomet_HourSchedConfig(): libcomet_HourSchedConfig {
	return {
		"Hour": 0,
		"Minutes": 0,
	};
}


export type libcomet_HyperVMachineInfo = {
	ID: string
	/**
	 * DisplayName
	 */
	Name: string
}

export function New_Zero_libcomet_HyperVMachineInfo(): libcomet_HyperVMachineInfo {
	return {
		"ID": "",
		"Name": "",
	};
}


export type libcomet_InstallCreds = {
	Username: string
	Password: string
	TOTPCode: string
	Server: string
	AutoLogin: boolean
}

export function New_Zero_libcomet_InstallCreds(): libcomet_InstallCreds {
	return {
		"Username": "",
		"Password": "",
		"TOTPCode": "",
		"Server": "",
		"AutoLogin": false,
	};
}


export type libcomet_InstallToken = {
	Username: string
	/**
	 * The URL of the Comet Server (Auth Role) for the target user to log in to.
	 */
	Server: string
	/**
	 * The token for use with the "/TOKEN=" silent install flag.
	 */
	Token: string
	/**
	 * Unix timestamp, in seconds.
	 */
	CreateTime: number
	/**
	 * If the token has been used, it cannot be used again.
	 */
	Used: boolean
	/**
	 * Unix timestamp, in seconds.
	 */
	ExpireTime: number
}

export function New_Zero_libcomet_InstallToken(): libcomet_InstallToken {
	return {
		"Username": "",
		"Server": "",
		"Token": "",
		"CreateTime": 0,
		"Used": false,
		"ExpireTime": 0,
	};
}


export type libcomet_InstallTokenResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	InstallToken: libcomet_InstallToken
}

export function New_Zero_libcomet_InstallTokenResponse(): libcomet_InstallTokenResponse {
	return {
		"Status": 0,
		"Message": "",
		"InstallToken": New_Zero_libcomet_InstallToken(),
	};
}

export function libcomet_InstallTokenResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_InstallTokenResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


/**
 * JobEntry is a single entry within a job report.
 */
export type libcomet_JobEntry = {
	/**
	 * Unix timestamp in seconds
	 */
	Time: number
	/**
	 * One of the SEVERITY_ constants.
	 */
	Severity: string
	Message: string
}

export function New_Zero_libcomet_JobEntry(): libcomet_JobEntry {
	return {
		"Time": 0,
		"Severity": "",
		"Message": "",
	};
}


export type libcomet_LicenseOptions = {
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Email?: string
	SerialNumber: string
}

export function New_Zero_libcomet_LicenseOptions(): libcomet_LicenseOptions {
	return {
		"SerialNumber": "",
	};
}


export type libcomet_LiveUserConnection = {
	Username: string
	DeviceID: string
	/**
	 * The Comet Backup software version that this live-connected device reports that it is running. It
	 * takes the format "MAJOR.MINOR.PATCH", such as "23.2.0". See the APPLICATION_VERSION constant for
	 * more information.
	 */
	ReportedVersion: string
	/**
	 * The operating system of the device. It is one of the PLATFORM_ constants; then a forwardslash
	 * (/); then the device's GOARCH.
	 */
	ReportedPlatform: string
	/**
	 * The operating system of the device, in extended detail.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	ReportedPlatformVersion?: libcomet_OSInfo
	/**
	 * The reported timezone of the device, in IANA format.
	 * Omission from JSON will be interpreted as empty-string
	 */
	DeviceTimeZone?: string
	/**
	 * The live-connected device's remote IP address, as seen from the Comet Server.
	 * Omission from JSON will be interpreted as empty-string
	 */
	IPAddress?: string
	/**
	 * Unix timestamp, in seconds.
	 */
	ConnectionTime: number
	/**
	 * The current state of the "Allow administrator to view my files" client-side option. If this
	 * option is refused, some live-connected actions will be refused by the device.
	 */
	AllowsFilenames: boolean
}

export function New_Zero_libcomet_LiveUserConnection(): libcomet_LiveUserConnection {
	return {
		"Username": "",
		"DeviceID": "",
		"ReportedVersion": "",
		"ReportedPlatform": "",
		"ConnectionTime": 0,
		"AllowsFilenames": false,
	};
}


export type libcomet_LocalDestinationLocation = {
	LocalcopyPath: string
	/**
	 * If logging in to a Windows network share (SMB/CIFS) is required, enter the username here.
	 */
	LocalcopyWinSMBUsername: string
	/**
	 * If logging in to a Windows network share (SMB/CIFS) is required, enter the password here. The
	 * password may be hashed as per the LocalcopyWinSMBPasswordFormat field.
	 */
	LocalcopyWinSMBPassword: string
	/**
	 * One of the PASSWORD_FORMAT_ constants. It controls the hash format of the
	 * LocalcopyWinSMBPassword field.
	 */
	LocalcopyWinSMBPasswordFormat: number
}

export function New_Zero_libcomet_LocalDestinationLocation(): libcomet_LocalDestinationLocation {
	return {
		"LocalcopyPath": "",
		"LocalcopyWinSMBUsername": "",
		"LocalcopyWinSMBPassword": "",
		"LocalcopyWinSMBPasswordFormat": 0,
	};
}


export type libcomet_LocalStorageDirectory = {
	Path: string
}

export function New_Zero_libcomet_LocalStorageDirectory(): libcomet_LocalStorageDirectory {
	return {
		"Path": "",
	};
}


export type libcomet_MSSQLConnection = {
	/**
	 * One of the MSSQL_AUTH_ constants (e.g. "windows" or "native")
	 */
	Type: string
	Username: string
	Password: string
	/**
	 * @deprecated This member has been deprecated since Comet version Unused
	 */
	Hostname: string
	InstanceName: string
	/**
	 * One of the MSSQL_METHOD_ constants, to control using x86_32 or x86_64 OLEDB drivers
	 */
	Method: string
}

export function New_Zero_libcomet_MSSQLConnection(): libcomet_MSSQLConnection {
	return {
		"Type": "",
		"Username": "",
		"Password": "",
		"Hostname": "",
		"InstanceName": "",
		"Method": "",
	};
}


export type libcomet_MSSQLLoginArgs = {
	Instance: string
	AuthMode: string
	Username: string
	Password: string
	MethodIsOledb32Bit: boolean
	/**
	 * If this MSSQLLoginArgs structure is used for a restore job (RestoreJobAdvancedOptions) using
	 * RESTORETYPE_MSSQL, then, this field controls the RECOVERY / NO RECOVERY option state.
	 */
	RestoreNoRecovery: boolean
}

export function New_Zero_libcomet_MSSQLLoginArgs(): libcomet_MSSQLLoginArgs {
	return {
		"Instance": "",
		"AuthMode": "",
		"Username": "",
		"Password": "",
		"MethodIsOledb32Bit": false,
		"RestoreNoRecovery": false,
	};
}


export type libcomet_MacOSCodeSignProperties = {
	/**
	 * One of the MACOSCODESIGN_LEVEL_ constants
	 */
	Level: number
	SignLocally: boolean
	SSHServer: libcomet_SSHConnection
	/**
	 * "Developer ID Installer" certificate, either a local filepath or a resource:// URI. Used for
	 * signing the final flat *.pkg.
	 */
	CertificateName: string
	/**
	 * "Developer ID Application" certificate, either a local filepath or a resource:// URI. Used for
	 * signing internal binaries if Notary is enabled
	 */
	AppCertificateName: string
	AppleID: string
	AppleIDPass: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	AppleIDPassFormat: number
	CertificateFile: string
	AppCertificateFile: string
	PfxFilePassword: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	PfxFilePasswordFormat: number
	NotaryAPIIssuerID: string
	NotaryAPIKeyID: string
	NotaryAPIKeyFile: string
}

export function New_Zero_libcomet_MacOSCodeSignProperties(): libcomet_MacOSCodeSignProperties {
	return {
		"Level": 0,
		"SignLocally": false,
		"SSHServer": New_Zero_libcomet_SSHConnection(),
		"CertificateName": "",
		"AppCertificateName": "",
		"AppleID": "",
		"AppleIDPass": "",
		"AppleIDPassFormat": 0,
		"CertificateFile": "",
		"AppCertificateFile": "",
		"PfxFilePassword": "",
		"PfxFilePasswordFormat": 0,
		"NotaryAPIIssuerID": "",
		"NotaryAPIKeyID": "",
		"NotaryAPIKeyFile": "",
	};
}


export type libcomet_MongoDBConnection = {
	Server: string
	Port: number
	Username: string
	Password: string
	AuthenticationDB: string
	/**
	 * Prior to Comet 22.12.3, must be a filesystem path to `mongo` (n.b. not `mongosh`). In Comet >=
	 * 22.12.3, not used.
	 * @deprecated This member has been deprecated since Comet version 22.12.3
	 */
	MongoShellPath: string
	MongodumpPath: string
	ReadPreference: string
	UseReplica: boolean
	ReplicaName: string
	ReplicaMembers: string[]
	UseSSL: boolean
	ClientSSLPEMPath: string
	ServerSSLPEMPath: string
	SSLClientKeyPassword: string
	AllowInvalidCertificate: boolean
	AllowInvalidHostname: boolean
	UseSSH: boolean
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	SSHConnection?: libcomet_SSHConnection
}

export function New_Zero_libcomet_MongoDBConnection(): libcomet_MongoDBConnection {
	return {
		"Server": "",
		"Port": 0,
		"Username": "",
		"Password": "",
		"AuthenticationDB": "",
		"MongoShellPath": "",
		"MongodumpPath": "",
		"ReadPreference": "",
		"UseReplica": false,
		"ReplicaName": "",
		"ReplicaMembers": [],
		"UseSSL": false,
		"ClientSSLPEMPath": "",
		"ServerSSLPEMPath": "",
		"SSLClientKeyPassword": "",
		"AllowInvalidCertificate": false,
		"AllowInvalidHostname": false,
		"UseSSH": false,
	};
}


export type libcomet_MySQLConnection = {
	Host: string
	Port: string
	/**
	 * Optional
	 */
	Username: string
	/**
	 * Optional
	 */
	Password: string
	UseTLS: boolean
	TLSSkipVerify: boolean
	TLSCustomServerCAPath: string
	TLSCustomClientCrtPath: string
	TLSCustomClientKeyPath: string
}

export function New_Zero_libcomet_MySQLConnection(): libcomet_MySQLConnection {
	return {
		"Host": "",
		"Port": "",
		"Username": "",
		"Password": "",
		"UseTLS": false,
		"TLSSkipVerify": false,
		"TLSCustomServerCAPath": "",
		"TLSCustomClientCrtPath": "",
		"TLSCustomClientKeyPath": "",
	};
}


export type libcomet_NewBucketDetail = {
	NewBucketID: string
	NewBucketKey: string
}

export function New_Zero_libcomet_NewBucketDetail(): libcomet_NewBucketDetail {
	return {
		"NewBucketID": "",
		"NewBucketKey": "",
	};
}


export type libcomet_NewsEntry = {
	OrganizationID: string
	/**
	 * Unix timestamp, in seconds.
	 */
	DateTime: number
	TextContent: string
}

export function New_Zero_libcomet_NewsEntry(): libcomet_NewsEntry {
	return {
		"OrganizationID": "",
		"DateTime": 0,
		"TextContent": "",
	};
}


/**
 * OSInfo represents the common set of version information between all operating systems
 */
export type libcomet_OSInfo = {
	/**
	 * The primary version number (e.g. on Windows: 1703 / 2009, on Linux: 20.04 / 22.04)
	 * Version
	 * Omission from JSON will be interpreted as empty-string
	 */
	version?: string
	/**
	 * The primary presentation name (e.g. "Windows 10 Pro", "debian", "Synology DSM")
	 * Distribution
	 * Omission from JSON will be interpreted as empty-string
	 */
	distribution?: string
	/**
	 * The detailed build number (e.g. 19043)
	 * Build
	 * Omission from JSON will be interpreted as empty-string
	 */
	build?: string
	/**
	 * The GOOS value
	 * OS
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as empty-string
	 */
	os?: string
	/**
	 * The GOARCH value
	 * Arch
	 * This field is available in Comet 23.6.0 and later.
	 * Omission from JSON will be interpreted as empty-string
	 */
	arch?: string
}

export function New_Zero_libcomet_OSInfo(): libcomet_OSInfo {
	return {
	};
}


export type libcomet_Office365Connection = {
	FeatureFlag: string
	Credential: libcomet_Office365Credential
	CustomSetting: libcomet_Office365CustomSetting
	MailboxUniqueMembers: string[]
	SiteUniqueMembers: string[]
	CustomSettingV2: libcomet_Office365CustomSettingV2
}

export function New_Zero_libcomet_Office365Connection(): libcomet_Office365Connection {
	return {
		"FeatureFlag": "",
		"Credential": New_Zero_libcomet_Office365Credential(),
		"CustomSetting": New_Zero_libcomet_Office365CustomSetting(),
		"MailboxUniqueMembers": [],
		"SiteUniqueMembers": [],
		"CustomSettingV2": New_Zero_libcomet_Office365CustomSettingV2(),
	};
}


export type libcomet_Office365Credential = {
	AppID: string
	TenantID: string
	Secret: string
	AppCert: string
	Region: string
}

export function New_Zero_libcomet_Office365Credential(): libcomet_Office365Credential {
	return {
		"AppID": "",
		"TenantID": "",
		"Secret": "",
		"AppCert": "",
		"Region": "",
	};
}


/**
 * Office365CustomSetting is used in the EngineProps for an Office 365 Protected Item (see
 * ENGINE_BUILTIN_MSOFFICE).
 * If present, it will be automatically converted to the replacement Office365CustomSettingV2 type.
 * @deprecated This type has been deprecated since Comet version 21.9.xx
 */
export type libcomet_Office365CustomSetting = {
	MailboxStrategy: string
	SiteStrategy: string
	MailboxUserIDs: string[]
	MailboxGroupIDs: string[]
	SiteIDs: string[]
}

export function New_Zero_libcomet_Office365CustomSetting(): libcomet_Office365CustomSetting {
	return {
		"MailboxStrategy": "",
		"SiteStrategy": "",
		"MailboxUserIDs": [],
		"MailboxGroupIDs": [],
		"SiteIDs": [],
	};
}


/**
 * Office365CustomSettingV2 is used in the EngineProps for an Office 365 Protected Item (see
 * ENGINE_BUILTIN_MSOFFICE).
 * This type is available in Comet 21.9.xx and later.
 */
export type libcomet_Office365CustomSettingV2 = {
	/**
	 * If true, then backup the entire Office 365 Tenant except the selected members. If false, backup
	 * the selected members only.
	 */
	Organization: boolean
	/**
	 * Key can be the ID of user, group or SharePoint
	 * Value is a bitset of the SERVICE_ constants, to select which services to back up for this
	 * member.
	 * Omission from JSON will be interpreted as an empty map
	 */
	BackupOptions?: {[k: string]: number}
	/**
	 * Key must be a group ID
	 * Value is a bitset of the SERVICE_ constants, to select which services to back up for this
	 * member.
	 * Omission from JSON will be interpreted as an empty map
	 */
	MemberBackupOptions?: {[k: string]: number}
}

export function New_Zero_libcomet_Office365CustomSettingV2(): libcomet_Office365CustomSettingV2 {
	return {
		"Organization": false,
	};
}


export type libcomet_Office365MixedVirtualAccount = {
	/**
	 * ID
	 */
	id: string
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	Type?: number
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	DisplayName?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Mail?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	JobTitle?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	SiteID?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	WebID?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	WebURL?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	UserPrincipalName?: string
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	EnabledServiceOption?: number
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	Members?: string[]
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	ServiceOptions?: number
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	MemberServiceOptions?: number
	/**
	 * HasLicense
	 * Omission from JSON will be interpreted as false
	 */
	hasLicense?: boolean
}

export function New_Zero_libcomet_Office365MixedVirtualAccount(): libcomet_Office365MixedVirtualAccount {
	return {
		"id": "",
	};
}


export type libcomet_Office365ObjectInfo = {
	GUID: string
	Name: string
	Type: string
	/**
	 * May be an email address or a SharePoint site URL
	 */
	Value: string
	Members: string[]
}

export function New_Zero_libcomet_Office365ObjectInfo(): libcomet_Office365ObjectInfo {
	return {
		"GUID": "",
		"Name": "",
		"Type": "",
		"Value": "",
		"Members": [],
	};
}


export type libcomet_OidcClaim = {
	Name: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Value?: string
}

export function New_Zero_libcomet_OidcClaim(): libcomet_OidcClaim {
	return {
		"Name": "",
	};
}


export type libcomet_OidcConfig = {
	DisplayName: string
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	Hosts?: string[]
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	OrganizationID?: string
	Provider: string
	ClientID: string
	ClientSecret: string
	SkipMFA: boolean
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	Scopes?: string[]
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	RequiredClaims?: libcomet_OidcClaim[]
	/**
	 * GenericOP_DiscoveryDocumentURL
	 * Omission from JSON will be interpreted as empty-string
	 */
	DiscoveryDocumentURL?: string
	/**
	 * AzureADV2OP_TenantID
	 * Omission from JSON will be interpreted as empty-string
	 */
	AzureTenantID?: string
	/**
	 * GoogleOP_HostedDomain
	 * Omission from JSON will be interpreted as empty-string
	 */
	GoogleHostedDomain?: string
}

export function New_Zero_libcomet_OidcConfig(): libcomet_OidcConfig {
	return {
		"DisplayName": "",
		"Provider": "",
		"ClientID": "",
		"ClientSecret": "",
		"SkipMFA": false,
	};
}


export type libcomet_Organization = {
	AuditFileOptions: {[k: string]: libcomet_FileOption}
	Branding: libcomet_BrandingOptions
	ConstellationRole: libcomet_ConstellationRoleOptions
	Email: libcomet_EmailOptions
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	ExperimentalOptions?: string[]
	Hosts: string[]
	Name: string
	IsSuspended: boolean
	PSAConfigs: libcomet_PSAConfig[]
	RemoteStorage: libcomet_RemoteStorageOption[]
	SoftwareBuildRole: libcomet_SoftwareBuildRoleOptions
	WebhookOptions: {[k: string]: libcomet_WebhookOption}
}

export function New_Zero_libcomet_Organization(): libcomet_Organization {
	return {
		"AuditFileOptions": {},
		"Branding": New_Zero_libcomet_BrandingOptions(),
		"ConstellationRole": New_Zero_libcomet_ConstellationRoleOptions(),
		"Email": New_Zero_libcomet_EmailOptions(),
		"Hosts": [],
		"Name": "",
		"IsSuspended": false,
		"PSAConfigs": [],
		"RemoteStorage": [],
		"SoftwareBuildRole": New_Zero_libcomet_SoftwareBuildRoleOptions(),
		"WebhookOptions": {},
	};
}


export type libcomet_OrganizationLoginURLResponse = {
	LoginURL: string
}

export function New_Zero_libcomet_OrganizationLoginURLResponse(): libcomet_OrganizationLoginURLResponse {
	return {
		"LoginURL": "",
	};
}


export type libcomet_OrganizationResponse = {
	Status: number
	Message: string
	ID: string
	Organization: libcomet_Organization
}

export function New_Zero_libcomet_OrganizationResponse(): libcomet_OrganizationResponse {
	return {
		"Status": 0,
		"Message": "",
		"ID": "",
		"Organization": New_Zero_libcomet_Organization(),
	};
}


export type libcomet_PSAConfig = {
	/**
	 * For PSA_TYPE_GRADIENT. Defaults to enabled
	 */
	AlertsDisabled: boolean
	/**
	 * Omission from JSON will be interpreted as an empty map
	 */
	CustomHeaders?: {[k: string]: string}
	/**
	 * Specified credentials for the target PSA
	 * Omission from JSON will be interpreted as empty-string
	 */
	PartnerKey?: string
	/**
	 * One of the PSA_TYPE_ constants
	 */
	Type: number
	/**
	 * For PSA_TYPE_GENERIC
	 */
	URL: string
	GroupedBy: libcomet_PSAGroupedBy
}

export function New_Zero_libcomet_PSAConfig(): libcomet_PSAConfig {
	return {
		"AlertsDisabled": false,
		"Type": 0,
		"URL": "",
		"GroupedBy": New_Zero_libcomet_PSAGroupedBy(),
	};
}


export type libcomet_PSAGroupedBy = {
	Users: boolean
	Tenants: boolean
	AccountName: boolean
}

export function New_Zero_libcomet_PSAGroupedBy(): libcomet_PSAGroupedBy {
	return {
		"Users": false,
		"Tenants": false,
		"AccountName": false,
	};
}


export type libcomet_Partition = {
	DeviceName: string
	/**
	 * The name of the filesystem used on this partition (e.g. "NTFS")
	 */
	Filesystem: string
	VolumeName: string
	VolumeGuid: string
	VolumeSerial: string
	MountPoints: string[]
	/**
	 * Bytes. The partition's offset within the DeviceName. It will be zero if this partition has a
	 * direct DeviceName handle.
	 */
	ReadOffset: number
	/**
	 * Bytes
	 */
	Size: number
	/**
	 * Bytes. Only present for supported filesystems that are currently mounted by the OS
	 */
	UsedSize: number
	Flags: number
	BytesPerFilesystemCluster: number
}

export function New_Zero_libcomet_Partition(): libcomet_Partition {
	return {
		"DeviceName": "",
		"Filesystem": "",
		"VolumeName": "",
		"VolumeGuid": "",
		"VolumeSerial": "",
		"MountPoints": [],
		"ReadOffset": 0,
		"Size": 0,
		"UsedSize": 0,
		"Flags": 0,
		"BytesPerFilesystemCluster": 0,
	};
}


export type libcomet_PrivateBrandingProperties = {
	/**
	 * One of the CLIENTBRANDINGBUILD_ constants
	 */
	BuildMode: number
	PathIcoFile: string
	PathIcnsFile: string
	PathMenuBarIcnsFile: string
	PathEulaRtf: string
	PathTilePng: string
	PathHeaderImage: string
	PathAppIconImage: string
	PackageIdentifier: string
	/**
	 * One of the WINDOWSCODESIGN_METHOD_ constants
	 */
	WindowsCodeSignMethod: number
	WindowsCodeSignPKCS12FilePath: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS12PasswordFormat: number
	WindowsCodeSignPKCS12Password: string
	WindowsCodeSignPKCS11Engine: string
	WindowsCodeSignPKCS11Module: string
	/**
	 * This field was deprecated between 23.3.0 and 23.6.x, but is now used again.
	 */
	WindowsCodeSignPKCS11Certfile: string
	WindowsCodeSignPKCS11KeyID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS11PasswordFormat: number
	WindowsCodeSignPKCS11Password: string
	WindowsCodeSignAzureVaultName: string
	WindowsCodeSignAzureCertName: string
	WindowsCodeSignAzureAppID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignAzureAppSecretFormat: number
	WindowsCodeSignAzureAppSecret: string
	WindowsCodeSignAzureTenantID: string
	MacOSCodeSign: libcomet_MacOSCodeSignProperties
}

export function New_Zero_libcomet_PrivateBrandingProperties(): libcomet_PrivateBrandingProperties {
	return {
		"BuildMode": 0,
		"PathIcoFile": "",
		"PathIcnsFile": "",
		"PathMenuBarIcnsFile": "",
		"PathEulaRtf": "",
		"PathTilePng": "",
		"PathHeaderImage": "",
		"PathAppIconImage": "",
		"PackageIdentifier": "",
		"WindowsCodeSignMethod": 0,
		"WindowsCodeSignPKCS12FilePath": "",
		"WindowsCodeSignPKCS12PasswordFormat": 0,
		"WindowsCodeSignPKCS12Password": "",
		"WindowsCodeSignPKCS11Engine": "",
		"WindowsCodeSignPKCS11Module": "",
		"WindowsCodeSignPKCS11Certfile": "",
		"WindowsCodeSignPKCS11KeyID": "",
		"WindowsCodeSignPKCS11PasswordFormat": 0,
		"WindowsCodeSignPKCS11Password": "",
		"WindowsCodeSignAzureVaultName": "",
		"WindowsCodeSignAzureCertName": "",
		"WindowsCodeSignAzureAppID": "",
		"WindowsCodeSignAzureAppSecretFormat": 0,
		"WindowsCodeSignAzureAppSecret": "",
		"WindowsCodeSignAzureTenantID": "",
		"MacOSCodeSign": New_Zero_libcomet_MacOSCodeSignProperties(),
	};
}

export function libcomet_PrivateBrandingProperties_set_embedded_libcomet_WindowsCodeSignProperties(dest: libcomet_PrivateBrandingProperties, src: libcomet_WindowsCodeSignProperties): void {
	dest.WindowsCodeSignMethod = src.WindowsCodeSignMethod;
	dest.WindowsCodeSignPKCS12FilePath = src.WindowsCodeSignPKCS12FilePath;
	dest.WindowsCodeSignPKCS12PasswordFormat = src.WindowsCodeSignPKCS12PasswordFormat;
	dest.WindowsCodeSignPKCS12Password = src.WindowsCodeSignPKCS12Password;
	dest.WindowsCodeSignPKCS11Engine = src.WindowsCodeSignPKCS11Engine;
	dest.WindowsCodeSignPKCS11Module = src.WindowsCodeSignPKCS11Module;
	dest.WindowsCodeSignPKCS11Certfile = src.WindowsCodeSignPKCS11Certfile;
	dest.WindowsCodeSignPKCS11KeyID = src.WindowsCodeSignPKCS11KeyID;
	dest.WindowsCodeSignPKCS11PasswordFormat = src.WindowsCodeSignPKCS11PasswordFormat;
	dest.WindowsCodeSignPKCS11Password = src.WindowsCodeSignPKCS11Password;
	dest.WindowsCodeSignAzureVaultName = src.WindowsCodeSignAzureVaultName;
	dest.WindowsCodeSignAzureCertName = src.WindowsCodeSignAzureCertName;
	dest.WindowsCodeSignAzureAppID = src.WindowsCodeSignAzureAppID;
	dest.WindowsCodeSignAzureAppSecretFormat = src.WindowsCodeSignAzureAppSecretFormat;
	dest.WindowsCodeSignAzureAppSecret = src.WindowsCodeSignAzureAppSecret;
	dest.WindowsCodeSignAzureTenantID = src.WindowsCodeSignAzureTenantID;
}


export type libcomet_ProtectedItemEngineTypePolicy = {
	ShouldRestrictEngineTypeList: boolean
	AllowedEngineTypeWhenRestricted: string[]
}

export function New_Zero_libcomet_ProtectedItemEngineTypePolicy(): libcomet_ProtectedItemEngineTypePolicy {
	return {
		"ShouldRestrictEngineTypeList": false,
		"AllowedEngineTypeWhenRestricted": [],
	};
}


export type libcomet_PublicBrandingProperties = {
	ProductName: string
	CompanyName: string
	HelpURL: string
	HelpIsPopup: boolean
	DefaultLoginServerURL: string
	TileBackgroundColor: string
	AccountRegisterURL: string
	HideBackgroundLogo: boolean
}

export function New_Zero_libcomet_PublicBrandingProperties(): libcomet_PublicBrandingProperties {
	return {
		"ProductName": "",
		"CompanyName": "",
		"HelpURL": "",
		"HelpIsPopup": false,
		"DefaultLoginServerURL": "",
		"TileBackgroundColor": "",
		"AccountRegisterURL": "",
		"HideBackgroundLogo": false,
	};
}


export type libcomet_RatelimitOptions = {
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	Rules?: libcomet_RatelimitRule[]
}

export function New_Zero_libcomet_RatelimitOptions(): libcomet_RatelimitOptions {
	return {
	};
}


export type libcomet_RatelimitRule = {
	MatchRegex: string
	BytesPerSecond: number
}

export function New_Zero_libcomet_RatelimitRule(): libcomet_RatelimitRule {
	return {
		"MatchRegex": "",
		"BytesPerSecond": 0,
	};
}


export type libcomet_RegisterOfficeApplicationBeginResponse = {
	Continuation: string
	VerificationURL: string
	UserCode: string
}

export function New_Zero_libcomet_RegisterOfficeApplicationBeginResponse(): libcomet_RegisterOfficeApplicationBeginResponse {
	return {
		"Continuation": "",
		"VerificationURL": "",
		"UserCode": "",
	};
}


export type libcomet_RegisterOfficeApplicationCheckResponse = {
	Continuation: string
	Completed: boolean
	Error: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Result?: libcomet_Office365Credential
}

export function New_Zero_libcomet_RegisterOfficeApplicationCheckResponse(): libcomet_RegisterOfficeApplicationCheckResponse {
	return {
		"Continuation": "",
		"Completed": false,
		"Error": "",
	};
}


export type libcomet_RegistrationLobbyConnection = {
	DeviceID: string
	OrganizationID: string
	FriendlyName: string
	ReportedVersion: string
	ReportedPlatform: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	ReportedPlatformVersion?: libcomet_OSInfo
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	DeviceTimeZone?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	IPAddress?: string
	ConnectionTime: number
}

export function New_Zero_libcomet_RegistrationLobbyConnection(): libcomet_RegistrationLobbyConnection {
	return {
		"DeviceID": "",
		"OrganizationID": "",
		"FriendlyName": "",
		"ReportedVersion": "",
		"ReportedPlatform": "",
		"ConnectionTime": 0,
	};
}


export type libcomet_RemoteServerAddress = {
	Type: string
	Description: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	RemoteAddress?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Username?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Password?: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	LDAP?: libcomet_ExternalLDAPAuthenticationSourceSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	OIDC?: libcomet_OidcConfig
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	B2?: libcomet_B2VirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Wasabi?: libcomet_WasabiVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Custom?: libcomet_CustomRemoteBucketSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	S3?: libcomet_S3GenericVirtualStorageRole
	/**
	 * Amazon AWS - Virtual Storage Role
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	AWS?: libcomet_AmazonAWSVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Storj?: libcomet_StorjVirtualStorageRoleSetting
}

export function New_Zero_libcomet_RemoteServerAddress(): libcomet_RemoteServerAddress {
	return {
		"Type": "",
		"Description": "",
	};
}


export type libcomet_RemoteStorageOption = {
	Type: string
	Description: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	RemoteAddress?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Username?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Password?: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	LDAP?: libcomet_ExternalLDAPAuthenticationSourceSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	OIDC?: libcomet_OidcConfig
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	B2?: libcomet_B2VirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Wasabi?: libcomet_WasabiVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Custom?: libcomet_CustomRemoteBucketSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	S3?: libcomet_S3GenericVirtualStorageRole
	/**
	 * Amazon AWS - Virtual Storage Role
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	AWS?: libcomet_AmazonAWSVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Storj?: libcomet_StorjVirtualStorageRoleSetting
	StorageLimitEnabled: boolean
	StorageLimitBytes: number
	RebrandStorage: boolean
}

export function New_Zero_libcomet_RemoteStorageOption(): libcomet_RemoteStorageOption {
	return {
		"Type": "",
		"Description": "",
		"StorageLimitEnabled": false,
		"StorageLimitBytes": 0,
		"RebrandStorage": false,
	};
}

export function libcomet_RemoteStorageOption_set_embedded_libcomet_RemoteServerAddress(dest: libcomet_RemoteStorageOption, src: libcomet_RemoteServerAddress): void {
	dest.Type = src.Type;
	dest.Description = src.Description;
	dest.RemoteAddress = src.RemoteAddress;
	dest.Username = src.Username;
	dest.Password = src.Password;
	dest.LDAP = src.LDAP;
	dest.OIDC = src.OIDC;
	dest.B2 = src.B2;
	dest.Wasabi = src.Wasabi;
	dest.Custom = src.Custom;
	dest.S3 = src.S3;
	dest.AWS = src.AWS;
	dest.Storj = src.Storj;
}


export type libcomet_ReplicaServer = {
	Type: string
	Description: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	RemoteAddress?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Username?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Password?: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	LDAP?: libcomet_ExternalLDAPAuthenticationSourceSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	OIDC?: libcomet_OidcConfig
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	B2?: libcomet_B2VirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Wasabi?: libcomet_WasabiVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Custom?: libcomet_CustomRemoteBucketSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	S3?: libcomet_S3GenericVirtualStorageRole
	/**
	 * Amazon AWS - Virtual Storage Role
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	AWS?: libcomet_AmazonAWSVirtualStorageRoleSettings
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Storj?: libcomet_StorjVirtualStorageRoleSetting
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	ReplicaDeletionStrategy?: string
}

export function New_Zero_libcomet_ReplicaServer(): libcomet_ReplicaServer {
	return {
		"Type": "",
		"Description": "",
	};
}

export function libcomet_ReplicaServer_set_embedded_libcomet_RemoteServerAddress(dest: libcomet_ReplicaServer, src: libcomet_RemoteServerAddress): void {
	dest.Type = src.Type;
	dest.Description = src.Description;
	dest.RemoteAddress = src.RemoteAddress;
	dest.Username = src.Username;
	dest.Password = src.Password;
	dest.LDAP = src.LDAP;
	dest.OIDC = src.OIDC;
	dest.B2 = src.B2;
	dest.Wasabi = src.Wasabi;
	dest.Custom = src.Custom;
	dest.S3 = src.S3;
	dest.AWS = src.AWS;
	dest.Storj = src.Storj;
}


export type libcomet_ReplicatorStateAPIResponse = {
	Description: string
	RemoteServerID: string
	DisplayClass: number
	ActiveWorkers: number
	TotalWorkers: number
	State: number
	ItemsQueued: number
	BytesQueued: number
	LastWorkerSubmitTime: number
	CurrentTime: number
	ItemsReplicated: number
	BytesReplicated: number
}

export function New_Zero_libcomet_ReplicatorStateAPIResponse(): libcomet_ReplicatorStateAPIResponse {
	return {
		"Description": "",
		"RemoteServerID": "",
		"DisplayClass": 0,
		"ActiveWorkers": 0,
		"TotalWorkers": 0,
		"State": 0,
		"ItemsQueued": 0,
		"BytesQueued": 0,
		"LastWorkerSubmitTime": 0,
		"CurrentTime": 0,
		"ItemsReplicated": 0,
		"BytesReplicated": 0,
	};
}


export type libcomet_RequestStorageVaultResponseMessage = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	DestinationID: string
}

export function New_Zero_libcomet_RequestStorageVaultResponseMessage(): libcomet_RequestStorageVaultResponseMessage {
	return {
		"Status": 0,
		"Message": "",
		"DestinationID": "",
	};
}

export function libcomet_RequestStorageVaultResponseMessage_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_RequestStorageVaultResponseMessage, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_RestoreJobAdvancedOptions = {
	/**
	 * One of the RESTORETYPE_ constants
	 */
	Type: number
	/**
	 * For RESTORETYPE_FILE
	 */
	OverwriteExistingFiles: boolean
	/**
	 * For RESTORETYPE_FILE. If set, OverwriteExistingFiles must be true
	 */
	OverwriteIfNewer: boolean
	/**
	 * For RESTORETYPE_FILE. If set, DestPath must be blank
	 */
	DestIsOriginalLocation: boolean
	/**
	 * For RESTORETYPE_FILE or RESTORETYPE_PROCESS_xxx
	 */
	DestPath: string
	/**
	 * For RESTORETYPE_WINDISK only. Must have one entry for each selected restore path
	 */
	ExactDestPaths: string[]
	/**
	 * For RESTORETYPE_FILE_ARCHIVE or RESTORETYPE_PROCESS_ARCHIVE. Default 0 is *.tar, for backward
	 * compatibility
	 */
	ArchiveFormat: number
	/**
	 * Default disabled. For RESTORETYPE_FILE and RESTORETYPE_WINDISK. Used to continue the restore job
	 * when unreadable data chunks are found.
	 * Corresponds to the "Allow partial file restores (zero-out unrecoverable data)" option
	 * This field is available in Comet 23.6.4 and later.
	 */
	SkipUnreadableChunks: boolean
	/**
	 * Default disabled. Used to store the index files on disk instead of in memory.
	 * Corresponds to the "Prefer temporary files instead of RAM (slower)" option
	 * This field is available in Comet 23.6.4 and later.
	 */
	OnDiskIndexesKey: boolean
	/**
	 * For RESTORETYPE_OFFICE365_CLOUD.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Office365Credential?: libcomet_Office365Credential
	/**
	 * For RESTORETYPE_MYSQL
	 */
	Username: string
	/**
	 * For RESTORETYPE_MYSQL
	 */
	Password: string
	/**
	 * For RESTORETYPE_MYSQL
	 */
	Host: string
	/**
	 * For RESTORETYPE_MYSQL
	 */
	Port: string
	/**
	 * For RESTORETYPE_MYSQL
	 */
	UseSsl: boolean
	/**
	 * For RESTORETYPE_MYSQL i.e.: Self signed certs
	 */
	SslAllowInvalid: boolean
	/**
	 * For RESTORETYPE_MYSQL
	 */
	SslCaFile: string
	/**
	 * For RESTORETYPE_MYSQL
	 */
	SslCrtFile: string
	/**
	 * For RESTORETYPE_MYSQL
	 */
	SslKeyFile: string
	/**
	 * For RESTORETYPE_MSSQL.
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	MsSqlConnection?: libcomet_MSSQLLoginArgs
}

export function New_Zero_libcomet_RestoreJobAdvancedOptions(): libcomet_RestoreJobAdvancedOptions {
	return {
		"Type": 0,
		"OverwriteExistingFiles": false,
		"OverwriteIfNewer": false,
		"DestIsOriginalLocation": false,
		"DestPath": "",
		"ExactDestPaths": [],
		"ArchiveFormat": 0,
		"SkipUnreadableChunks": false,
		"OnDiskIndexesKey": false,
		"Username": "",
		"Password": "",
		"Host": "",
		"Port": "",
		"UseSsl": false,
		"SslAllowInvalid": false,
		"SslCaFile": "",
		"SslCrtFile": "",
		"SslKeyFile": "",
	};
}


export type libcomet_RetentionPolicy = {
	/**
	 * One of the RETENTIONMODE_ constants
	 */
	Mode: number
	Ranges: libcomet_RetentionRange[]
}

export function New_Zero_libcomet_RetentionPolicy(): libcomet_RetentionPolicy {
	return {
		"Mode": 0,
		"Ranges": [],
	};
}


/**
 * The Type field controls which fields of this data type are used. For additional information, see
 * the notes on the RETENTIONRANGE_ constants.
 */
export type libcomet_RetentionRange = {
	/**
	 * One of the RETENTIONRANGE_ constants
	 */
	Type: number
	/**
	 * Unix timestamp, in seconds. Used by RETENTIONRANGE_NEWER_THAN_X.
	 */
	Timestamp: number
	Jobs: number
	Days: number
	Weeks: number
	Months: number
	/**
	 * 0: Sunday, 6: Saturday
	 */
	WeekOffset: number
	/**
	 * 1: 1st, 31: 31st
	 * Prior to Comet version 23.6.2, 31 was treated as 30.
	 * For months that do not have a day equal to the specified offset, no backup will be retained.
	 * For example, if the offset is set to 30, no backup will be kept for February.
	 */
	MonthOffset: number
}

export function New_Zero_libcomet_RetentionRange(): libcomet_RetentionRange {
	return {
		"Type": 0,
		"Timestamp": 0,
		"Jobs": 0,
		"Days": 0,
		"Weeks": 0,
		"Months": 0,
		"WeekOffset": 0,
		"MonthOffset": 0,
	};
}


export type libcomet_S3DestinationLocation = {
	S3Server: string
	S3UsesTLS: boolean
	S3AccessKey: string
	S3SecretKey: string
	S3BucketName: string
	S3Subdir: string
	S3CustomRegion: string
	/**
	 * If true, use legacy v2 signing. If false (default), use modern v4 signing
	 */
	S3UsesV2Signing: boolean
	S3RemoveDeleted: boolean
	S3ObjectLockMode: number
	S3ObjectLockDays: number
}

export function New_Zero_libcomet_S3DestinationLocation(): libcomet_S3DestinationLocation {
	return {
		"S3Server": "",
		"S3UsesTLS": false,
		"S3AccessKey": "",
		"S3SecretKey": "",
		"S3BucketName": "",
		"S3Subdir": "",
		"S3CustomRegion": "",
		"S3UsesV2Signing": false,
		"S3RemoveDeleted": false,
		"S3ObjectLockMode": 0,
		"S3ObjectLockDays": 0,
	};
}


export type libcomet_S3GenericVirtualStorageRole = {
	S3Endpoint: string
	IAMEndpoint: string
	MasterBucket: string
	AccessKey: string
	SecretKey: string
	/**
	 * UseObjectLock_Legacy_DoNotUse
	 */
	UseObjectLock: boolean
	ObjectLockMode: number
	ObjectLockDays: number
	RemoveDeleted: boolean
}

export function New_Zero_libcomet_S3GenericVirtualStorageRole(): libcomet_S3GenericVirtualStorageRole {
	return {
		"S3Endpoint": "",
		"IAMEndpoint": "",
		"MasterBucket": "",
		"AccessKey": "",
		"SecretKey": "",
		"UseObjectLock": false,
		"ObjectLockMode": 0,
		"ObjectLockDays": 0,
		"RemoveDeleted": false,
	};
}


export type libcomet_SFTPDestinationLocation = {
	SFTPServer: string
	SFTPUsername: string
	/**
	 * The directory on the SFTP server in which data is stored.
	 */
	SFTPRemotePath: string
	/**
	 * One of the DESTINATION_SFTP_AUTHMODE_ constants
	 */
	SFTPAuthMode: number
	/**
	 * For use with DESTINATION_SFTP_AUTHMODE_PASSWORD only: the SSH password to connect with
	 */
	SFTPPassword: string
	/**
	 * For use with DESTINATION_SFTP_AUTHMODE_PRIVATEKEY only: the SSH private key to connect with, in
	 * OpenSSH format.
	 */
	SFTPPrivateKey: string
	/**
	 * If true, then the SFTPCustomAuth_KnownHostsFile will be used to verify the remote SSH server's
	 * host key, using Trust On First Use (TOFU).
	 */
	SFTPCustomAuth_UseKnownHostsFile: boolean
	/**
	 * If SFTPCustomAuth_UseKnownHostFile is true, the path to the SSH known_hosts file.
	 */
	SFTPCustomAuth_KnownHostsFile: string
}

export function New_Zero_libcomet_SFTPDestinationLocation(): libcomet_SFTPDestinationLocation {
	return {
		"SFTPServer": "",
		"SFTPUsername": "",
		"SFTPRemotePath": "",
		"SFTPAuthMode": 0,
		"SFTPPassword": "",
		"SFTPPrivateKey": "",
		"SFTPCustomAuth_UseKnownHostsFile": false,
		"SFTPCustomAuth_KnownHostsFile": "",
	};
}


export type libcomet_SSHConnection = {
	SSHServer: string
	SSHUsername: string
	/**
	 * One of the SSHCONNECTION_AUTHMODE_ constants
	 */
	SSHAuthMode: number
	/**
	 * For use with SSHCONNECTION_AUTHMODE_PASSWORD only: the SSH password to connect with
	 */
	SSHPassword: string
	/**
	 * For use with SSHCONNECTION_AUTHMODE_PRIVATEKEY only: the SSH private key to connect with, in
	 * OpenSSH format.
	 */
	SSHPrivateKey: string
	/**
	 * If true, then the SSHCustomAuth_KnownHostsFile will be used to verify the remote SSH server's
	 * host key, using Trust On First Use (TOFU).
	 */
	SSHCustomAuth_UseKnownHostsFile: boolean
	/**
	 * If SSHCustomAuth_UseKnownHostsFile is true, the path to the SSH known_hosts file.
	 */
	SSHCustomAuth_KnownHostsFile: string
}

export function New_Zero_libcomet_SSHConnection(): libcomet_SSHConnection {
	return {
		"SSHServer": "",
		"SSHUsername": "",
		"SSHAuthMode": 0,
		"SSHPassword": "",
		"SSHPrivateKey": "",
		"SSHCustomAuth_UseKnownHostsFile": false,
		"SSHCustomAuth_KnownHostsFile": "",
	};
}


export type libcomet_ScheduleConfig = {
	FrequencyType: number
	SecondsPast: number
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	Offset?: number
	RestrictRuntime: boolean
	FromTime: libcomet_HourSchedConfig
	ToTime: libcomet_HourSchedConfig
	RestrictDays: boolean
	DaysSelect: libcomet_DaysOfWeekConfig
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	RandomDelaySecs?: number
}

export function New_Zero_libcomet_ScheduleConfig(): libcomet_ScheduleConfig {
	return {
		"FrequencyType": 0,
		"SecondsPast": 0,
		"RestrictRuntime": false,
		"FromTime": New_Zero_libcomet_HourSchedConfig(),
		"ToTime": New_Zero_libcomet_HourSchedConfig(),
		"RestrictDays": false,
		"DaysSelect": New_Zero_libcomet_DaysOfWeekConfig(),
	};
}


export type libcomet_SearchClause = {
	/**
	 * One of the SEARCHCLAUSE_ constants (e.g. empty-string if this is a rule, or "and"/"or" if there
	 * are ClauseChildren)
	 */
	ClauseType: string
	/**
	 * The field name to search. Check the specific API for more information about which fields are
	 * available for searching. For use with ClauseType = SEARCHCLAUSE_RULE.
	 */
	RuleField: string
	/**
	 * One of the SEARCHOPERATOR_ constants. The operator must match the type of the particular field.
	 * For use with ClauseType = SEARCHCLAUSE_RULE.
	 */
	RuleOperator: string
	/**
	 * The value to compare the field against.
	 * - If the field is a string, any string is permissable.
	 * - If the field is an integer, the integer should be cast to a base-10 string. There is currently
	 * no support for fractional or floating-point numbers.
	 * - If the field is a boolean, the following values can be used for true ("1", "t", "T", "true",
	 * "TRUE", "True") and the following values can be used for false ("0", "f", "F", "false", "FALSE",
	 * "False").
	 * For use with ClauseType = SEARCHCLAUSE_RULE.
	 */
	RuleValue: string
	/**
	 * If ClauseType is not SEARCHCLAUSE_RULE, the child rules will be applied according to the
	 * ClauseType (e.g. "and"/"or")
	 * Omission from JSON will be interpreted as an empty array
	 */
	ClauseChildren?: libcomet_SearchClause[]
}

export function New_Zero_libcomet_SearchClause(): libcomet_SearchClause {
	return {
		"ClauseType": "",
		"RuleField": "",
		"RuleOperator": "",
		"RuleValue": "",
	};
}


/**
 * SearchResultFileInfo describes a single result entry when searching for files within a Storage
 * Vault snapshot.
 */
export type libcomet_SearchResultFileInfo = {
	/**
	 * Path to the file within the selected snapshot, using forwardslash (/) separators
	 * Path
	 */
	path: string
	/**
	 * Filename
	 * Name
	 */
	name: string
	/**
	 * One of the STOREDOBJECTTYPE_ constants
	 * Type
	 */
	type: string
	/**
	 * Mode
	 * Omission from JSON will be interpreted as empty-string
	 */
	mode?: string
	/**
	 * Timestamp in RFC3339 format with subsecond precision and time zone offset. See the Golang
	 * time.RFC3339Nano for more information.
	 * ModTime
	 * Omission from JSON will be interpreted as empty-string
	 */
	mtime?: string
	/**
	 * Timestamp in RFC3339 format with subsecond precision and time zone offset. See the Golang
	 * time.RFC3339Nano for more information.
	 * AccessTime
	 * Omission from JSON will be interpreted as empty-string
	 */
	atime?: string
	/**
	 * Timestamp in RFC3339 format with subsecond precision and time zone offset. See the Golang
	 * time.RFC3339Nano for more information.
	 * ChangeTime
	 * Omission from JSON will be interpreted as empty-string
	 */
	ctime?: string
	/**
	 * Bytes
	 * Size
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	size?: number
}

export function New_Zero_libcomet_SearchResultFileInfo(): libcomet_SearchResultFileInfo {
	return {
		"path": "",
		"name": "",
		"type": "",
	};
}


export type libcomet_SearchSnapshotsResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	SnapshotFiles: {[k: string]: libcomet_SearchResultFileInfo[]}
}

export function New_Zero_libcomet_SearchSnapshotsResponse(): libcomet_SearchSnapshotsResponse {
	return {
		"Status": 0,
		"Message": "",
		"SnapshotFiles": {},
	};
}

export function libcomet_SearchSnapshotsResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_SearchSnapshotsResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_SelfBackupExportOptions = {
	Location: libcomet_DestinationLocation
	EncryptionKey: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	EncryptionKeyFormat: number
	/**
	 * One of the COMPRESS_LVL_ constants
	 */
	Compression: number
	/**
	 * The jobs database is often the largest component of the Server Self-Backup archive. By excluding
	 * it, you could run the Server Self-Backup more often.
	 */
	ExcludeJobsDB: boolean
	IncludeServerLogs: boolean
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	RestrictToSingleOrgID?: string
	Index: number
}

export function New_Zero_libcomet_SelfBackupExportOptions(): libcomet_SelfBackupExportOptions {
	return {
		"Location": New_Zero_libcomet_DestinationLocation(),
		"EncryptionKey": "",
		"EncryptionKeyFormat": 0,
		"Compression": 0,
		"ExcludeJobsDB": false,
		"IncludeServerLogs": false,
		"Index": 0,
	};
}


export type libcomet_SelfBackupOptions = {
	Targets: libcomet_SelfBackupTarget[]
}

export function New_Zero_libcomet_SelfBackupOptions(): libcomet_SelfBackupOptions {
	return {
		"Targets": [],
	};
}


export type libcomet_SelfBackupStatistics = {
	CurrentRunStart: number
	LastRunStart: number
	LastRunEnd: number
	LastRunSuccess: boolean
	LastRunSize: number
}

export function New_Zero_libcomet_SelfBackupStatistics(): libcomet_SelfBackupStatistics {
	return {
		"CurrentRunStart": 0,
		"LastRunStart": 0,
		"LastRunEnd": 0,
		"LastRunSuccess": false,
		"LastRunSize": 0,
	};
}


export type libcomet_SelfBackupTarget = {
	Schedule: libcomet_ScheduleConfig[]
	/**
	 * Timezone in IANA format
	 */
	ScheduleTimezone: string
	RetentionPolicy: libcomet_RetentionPolicy
	Location: libcomet_DestinationLocation
	EncryptionKey: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	EncryptionKeyFormat: number
	/**
	 * One of the COMPRESS_LVL_ constants
	 */
	Compression: number
	/**
	 * The jobs database is often the largest component of the Server Self-Backup archive. By excluding
	 * it, you could run the Server Self-Backup more often.
	 */
	ExcludeJobsDB: boolean
	IncludeServerLogs: boolean
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	RestrictToSingleOrgID?: string
	Index: number
}

export function New_Zero_libcomet_SelfBackupTarget(): libcomet_SelfBackupTarget {
	return {
		"Schedule": [],
		"ScheduleTimezone": "",
		"RetentionPolicy": New_Zero_libcomet_RetentionPolicy(),
		"Location": New_Zero_libcomet_DestinationLocation(),
		"EncryptionKey": "",
		"EncryptionKeyFormat": 0,
		"Compression": 0,
		"ExcludeJobsDB": false,
		"IncludeServerLogs": false,
		"Index": 0,
	};
}

export function libcomet_SelfBackupTarget_set_embedded_libcomet_SelfBackupExportOptions(dest: libcomet_SelfBackupTarget, src: libcomet_SelfBackupExportOptions): void {
	dest.Location = src.Location;
	dest.EncryptionKey = src.EncryptionKey;
	dest.EncryptionKeyFormat = src.EncryptionKeyFormat;
	dest.Compression = src.Compression;
	dest.ExcludeJobsDB = src.ExcludeJobsDB;
	dest.IncludeServerLogs = src.IncludeServerLogs;
	dest.RestrictToSingleOrgID = src.RestrictToSingleOrgID;
	dest.Index = src.Index;
}


export type libcomet_ServerConfigOptions = {
	AdminUsers: libcomet_AllowedAdminUser[]
	AuthenticationRole: libcomet_AuthenticationRoleOptions
	Branding: libcomet_BrandingOptions
	ConstellationRole: libcomet_ConstellationRoleOptions
	/**
	 * This field is defined for compatibility with 17.x.x versions of Comet Server. Do not rely on
	 * this field. In Comet 23.2.x, if this field is defined, it is imported into the replacement
	 * 'ConstellationRole' field under the assumption that you are upgrading this Comet Server from a
	 * 17.x.x version. In Comet 23.3.x and later, this field is ignored and will not be respected
	 * during the import process.
	 * ConstellationRole_Legacy
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	OverseerRole?: libcomet_ConstellationRoleOptions
	Email: libcomet_EmailOptions
	/**
	 * An array of GUIDs that can enable additional early-access functionality
	 * Omission from JSON will be interpreted as an empty array
	 */
	ExperimentalOptions?: string[]
	ExternalAdminUserSources: {[k: string]: libcomet_ExternalAuthenticationSource}
	/**
	 * The Comet Server can enforce a bandwidth limit based on the target IP address
	 */
	IPRateLimit: libcomet_RatelimitOptions
	License: libcomet_LicenseOptions
	/**
	 * Configure ip, port, and SSL settings for this self-hosted Comet Server.
	 */
	ListenAddresses: libcomet_HTTPConnectorOptions[]
	/**
	 * Tenants
	 */
	Organizations: {[k: string]: libcomet_Organization}
	PSAConfigs: libcomet_PSAConfig[]
	/**
	 * Automatically create backup zip files of this Comet Server's configuration
	 */
	SelfBackup: libcomet_SelfBackupOptions
	/**
	 * Control how long admin accounts can remain logged in to the Comet Server web interface
	 */
	SessionSettings: libcomet_SessionOptions
	SoftwareBuildRole: libcomet_SoftwareBuildRoleOptions
	StorageRole: libcomet_StorageRoleOptions
	/**
	 * If true, the X-Forwarded-For header will be trusted for the purposes of IP allowlisting. This
	 * should only be enabled when you explicitly configure Comet Server behind a reverse proxy,
	 * otherwise it could allow malicious users to bypass the IP allowlist.
	 */
	TrustXForwardedFor: boolean
	WebhookOptions: {[k: string]: libcomet_WebhookOption}
	AuditFileOptions: {[k: string]: libcomet_FileOption}
}

export function New_Zero_libcomet_ServerConfigOptions(): libcomet_ServerConfigOptions {
	return {
		"AdminUsers": [],
		"AuthenticationRole": New_Zero_libcomet_AuthenticationRoleOptions(),
		"Branding": New_Zero_libcomet_BrandingOptions(),
		"ConstellationRole": New_Zero_libcomet_ConstellationRoleOptions(),
		"Email": New_Zero_libcomet_EmailOptions(),
		"ExternalAdminUserSources": {},
		"IPRateLimit": New_Zero_libcomet_RatelimitOptions(),
		"License": New_Zero_libcomet_LicenseOptions(),
		"ListenAddresses": [],
		"Organizations": {},
		"PSAConfigs": [],
		"SelfBackup": New_Zero_libcomet_SelfBackupOptions(),
		"SessionSettings": New_Zero_libcomet_SessionOptions(),
		"SoftwareBuildRole": New_Zero_libcomet_SoftwareBuildRoleOptions(),
		"StorageRole": New_Zero_libcomet_StorageRoleOptions(),
		"TrustXForwardedFor": false,
		"WebhookOptions": {},
		"AuditFileOptions": {},
	};
}


export type libcomet_ServerConfigOptionsBrandingFragment = {
	Branding: libcomet_BrandingOptions
}

export function New_Zero_libcomet_ServerConfigOptionsBrandingFragment(): libcomet_ServerConfigOptionsBrandingFragment {
	return {
		"Branding": New_Zero_libcomet_BrandingOptions(),
	};
}


export type libcomet_ServerConfigOptionsSoftwareBuildRoleFragment = {
	SoftwareBuildRole: libcomet_SoftwareBuildRoleOptions
}

export function New_Zero_libcomet_ServerConfigOptionsSoftwareBuildRoleFragment(): libcomet_ServerConfigOptionsSoftwareBuildRoleFragment {
	return {
		"SoftwareBuildRole": New_Zero_libcomet_SoftwareBuildRoleOptions(),
	};
}


export type libcomet_ServerMetaBrandingProperties = {
	BrandName: string
	ProductName: string
	/**
	 * If true, this Comet Server has an image configured for its main logo. You can access it from the
	 * /gen/logo.img endpoint. If false, this Comet Server has text configured for its main logo.
	 */
	HasImage: boolean
	/**
	 * A value that will change if the branding image (/gen/logo.img) changes. You can use this as a
	 * cache key.
	 */
	ImageEtag: string
	/**
	 * Colour in RGB hex format (e.g. "#FFFFFF")
	 */
	TopColor: string
	/**
	 * Colour in RGB hex format (e.g. "#FFFFFF")
	 */
	AccentColor: string
	HideNewsArea: boolean
	AllowUnauthenticatedDownloads: boolean
	AllowAuthenticatedDownloads: boolean
	PruneLogsAfterDays: number
	ExpiredInSeconds: number
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	ExternalAuthenticationSources?: libcomet_ExternalAuthenticationSourceDisplay[]
}

export function New_Zero_libcomet_ServerMetaBrandingProperties(): libcomet_ServerMetaBrandingProperties {
	return {
		"BrandName": "",
		"ProductName": "",
		"HasImage": false,
		"ImageEtag": "",
		"TopColor": "",
		"AccentColor": "",
		"HideNewsArea": false,
		"AllowUnauthenticatedDownloads": false,
		"AllowAuthenticatedDownloads": false,
		"PruneLogsAfterDays": 0,
		"ExpiredInSeconds": 0,
	};
}


export type libcomet_ServerMetaVersionInfo = {
	Version: string
	VersionCodename: string
	StorageRole: boolean
	AuthenticationRole: boolean
	SoftwareBuildRole: boolean
	/**
	 * ConstellationRole_Legacy
	 * @deprecated This member has been deprecated since Comet version 18.2.0 "Overseer Role" was the old name for the Constellation Role. This field is a duplicate of ConstellationRole for backward compatibility with earlier API consumers.
	 */
	OverseerRole: boolean
	ConstellationRole: boolean
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	ExperimentalOptions?: string[]
	/**
	 * Unix timestamp, in seconds.
	 */
	ServerStartTime: number
	/**
	 * A GUID that was randomly generated when this Comet Server started up. You can check this value
	 * to see if the Comet Server has restarted.
	 */
	ServerStartHash: string
	/**
	 * The current time on the Comet Server host machine. Unix timestamp, in seconds. You can check
	 * this value to see if clock drift is occuring.
	 */
	CurrentTime: number
	/**
	 * A hash derived from the Comet Server's serial number. You can check this value to see if two
	 * Comet Server endpoints point to an identical server.
	 */
	ServerLicenseHash: string
	ServerLicenseFeaturesAll: boolean
	ServerLicenseFeatureSet: number
	/**
	 * Unix timestamp, in seconds.
	 */
	LicenseValidUntil: number
	EmailsSentSuccessfully: number
	EmailsSentErrors: number
	EmailsWaitingInQueue: number
	ScheduledEmailThreadCurrentState: number
	ScheduledEmailThreadLastCalculateDurationNanos: number
	ScheduledEmailThreadWaitingUntil: number
	ScheduledEmailThreadLastWakeTime: number
	ScheduledEmailThreadLastWakeSentEmails: boolean
	/**
	 * This field is available in Comet 21.3.2 and later.
	 */
	SelfBackup: libcomet_SelfBackupStatistics[]
}

export function New_Zero_libcomet_ServerMetaVersionInfo(): libcomet_ServerMetaVersionInfo {
	return {
		"Version": "",
		"VersionCodename": "",
		"StorageRole": false,
		"AuthenticationRole": false,
		"SoftwareBuildRole": false,
		"OverseerRole": false,
		"ConstellationRole": false,
		"ServerStartTime": 0,
		"ServerStartHash": "",
		"CurrentTime": 0,
		"ServerLicenseHash": "",
		"ServerLicenseFeaturesAll": false,
		"ServerLicenseFeatureSet": 0,
		"LicenseValidUntil": 0,
		"EmailsSentSuccessfully": 0,
		"EmailsSentErrors": 0,
		"EmailsWaitingInQueue": 0,
		"ScheduledEmailThreadCurrentState": 0,
		"ScheduledEmailThreadLastCalculateDurationNanos": 0,
		"ScheduledEmailThreadWaitingUntil": 0,
		"ScheduledEmailThreadLastWakeTime": 0,
		"ScheduledEmailThreadLastWakeSentEmails": false,
		"SelfBackup": [],
	};
}


export type libcomet_SessionKeyRegeneratedResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	SessionKey: string
	/**
	 * e.g. "admin" or "user"
	 * This field is available in Comet 18.12.3 and later.
	 */
	SessionType: string
}

export function New_Zero_libcomet_SessionKeyRegeneratedResponse(): libcomet_SessionKeyRegeneratedResponse {
	return {
		"Status": 0,
		"Message": "",
		"SessionKey": "",
		"SessionType": "",
	};
}

export function libcomet_SessionKeyRegeneratedResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_SessionKeyRegeneratedResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_SessionOptions = {
	/**
	 * The number of seconds, after which an administrator should be automatically logged out of the
	 * Comet Server web interface. If zero, will be replaced with DEFAULT_SESSIONTIMEOUT.
	 */
	ExpiredInSeconds: number
}

export function New_Zero_libcomet_SessionOptions(): libcomet_SessionOptions {
	return {
		"ExpiredInSeconds": 0,
	};
}


export type libcomet_SingleFieldSource = {
	FieldName: string
	/**
	 * One of "bool" / "int" / "string"
	 */
	FieldType: string
	BoolVal: boolean
	IntVal: number
	StrVal: string
}

export function New_Zero_libcomet_SingleFieldSource(): libcomet_SingleFieldSource {
	return {
		"FieldName": "",
		"FieldType": "",
		"BoolVal": false,
		"IntVal": 0,
		"StrVal": "",
	};
}


export type libcomet_SizeMeasurement = {
	/**
	 * Bytes
	 */
	Size: number
	/**
	 * Unix timestamp in seconds
	 */
	MeasureStarted: number
	/**
	 * Unix timestamp in seconds
	 */
	MeasureCompleted: number
}

export function New_Zero_libcomet_SizeMeasurement(): libcomet_SizeMeasurement {
	return {
		"Size": 0,
		"MeasureStarted": 0,
		"MeasureCompleted": 0,
	};
}


export type libcomet_SoftwareBuildRoleOptions = {
	RoleEnabled: boolean
	AllowUnauthenticatedDownloads: boolean
}

export function New_Zero_libcomet_SoftwareBuildRoleOptions(): libcomet_SoftwareBuildRoleOptions {
	return {
		"RoleEnabled": false,
		"AllowUnauthenticatedDownloads": false,
	};
}


export type libcomet_SoftwareUpdateNewsResponse = {
	/**
	 * The latest "Quarterly" release version of Comet known to the account.cometbackup.com system.
	 * LatestStable
	 */
	latest_stable: string
	/**
	 * The latest "Voyager" release version of Comet known to the account.cometbackup.com system.
	 * LatestPrerelease
	 */
	latest_prerelease: string
	/**
	 * A URL linking to the Comet Server downloads page.
	 * DownloadsURL
	 */
	downloads_url: string
	/**
	 * An array of recent news items written by Comet Backup staff. Entries are english plaintext.
	 * WhatsNew
	 */
	updates_info: string[]
}

export function New_Zero_libcomet_SoftwareUpdateNewsResponse(): libcomet_SoftwareUpdateNewsResponse {
	return {
		"latest_stable": "",
		"latest_prerelease": "",
		"downloads_url": "",
		"updates_info": [],
	};
}


/**
 * SourceBasicInfo is the minimal amount of information one device knows about another device's
 * Protected Items, in order to safely perform retention passes on their behalf.
 */
export type libcomet_SourceBasicInfo = {
	Description: string
	O365AccountCount: number
	/**
	 * Bytes
	 */
	Size: number
	/**
	 * Omission from JSON will be interpreted as an empty map
	 */
	OverrideDestinationRetention?: {[k: string]: libcomet_RetentionPolicy}
}

export function New_Zero_libcomet_SourceBasicInfo(): libcomet_SourceBasicInfo {
	return {
		"Description": "",
		"O365AccountCount": 0,
		"Size": 0,
	};
}


export type libcomet_SourceConfig = {
	/**
	 * One of the ENGINE_BUILTIN_ constants
	 */
	Engine: string
	Description: string
	OwnerDevice: string
	/**
	 * Unix timestamp in seconds
	 */
	CreateTime: number
	/**
	 * Unix timestamp in seconds
	 */
	ModifyTime: number
	/**
	 * Custom commands to run before the job
	 */
	PreExec: string[]
	/**
	 * Custom commands to run after taking a disk snapshot
	 */
	ThawExec: string[]
	/**
	 * Custom commands to run after the job
	 */
	PostExec: string[]
	/**
	 * Configuration for the selected Protected Item type. Each "Engine" supports
	 * different configuration options for the EngineProps values.
	 *
	 * For engine1/file, Comet understands the following EngineProp keys:
	 *
	 * - Any key starting with INCLUDE: A path that is included
	 * - Any key starting with EXCLUDE: An exclusion (glob format)
	 * - Any key starting with REXCLUDE: An exclusion (regular expression format)
	 * - Any key starting with PINCLUDE: A SourceIncludePattern type encoded in JSON format, describing
	 * an advanced inclusion in glob format
	 * - Any key starting with RINCLUDE: A SourceIncludePattern type encoded in JSON format, describing
	 * an advanced inclusion in regular expression format
	 * - Any key starting with SMBAUTH: A set of Windows network share credentials in WinSMBAuth JSON
	 * format
	 * - USE_WIN_VSS: If present, the 'Take filesystem snapshot' checkbox is checked
	 * - CONFIRM_EFS: If present, the 'Dismiss EFS warning' checkbox is checked
	 * - RESCAN_UNCHANGED: If present, the 'Rescan unchanged files' checkbox is checked
	 *
	 * For engine1/mssql, Comet understands the following EngineProp keys:
	 *
	 * - ALL_DATABASES: If present, include all databases with specified exclusions. If not present,
	 * only back up the specified inclusions
	 * - Any key starting with DATABASE- : A database that is included. Only valid if ALL_DATABASES is
	 * not present.
	 * - Any key starting with EXCEPT-DATABASE- : A database that is excluded. Only valid if
	 * ALL_DATABASES is present.
	 * - INSTANCE: The Microsoft SQL Server instance name
	 * - USERNAME: The username to connect to Microsoft SQL Server
	 * - PASSWORD: The password to connect to Microsoft SQL Server
	 * - AUTHMODE: Either "windows" or "native" (corresponding to the declared MSSQL_AUTH_WINDOWS and
	 * MSSQL_AUTH_NATIVE constant values). If not present, use native authentication if the USERNAME
	 * and/or PASSWORD fields are filled in, use windows authentication if they are blank
	 * - METHOD: Either "OLEDB_NATIVE" or "OLEDB_32" (corresponding to the declared
	 * MSSQL_METHOD_OLEDB_NATIVE and MSSQL_METHOD_OLEDB_32 constant values). If not present, defaults
	 * to Native
	 * - DIFFBASE: If present, take a "Full (base image)" backup job. Otherwise, take a "Full (copy
	 * only)" backup job.
	 * - DIFFERENTIAL: If present, take a "Differential increment" backup job. Otherwise, take a "Full
	 * (copy only)" backup job.
	 * - LOGTRUNC: If present, take a "Log (truncating)" backup job. Otherwise, take a "Full (copy
	 * only)" backup job.
	 * - LOGNOTRUNC: If present, take a "Log (no truncation)" backup job. Otherwise, take a "Full (copy
	 * only)" backup job.
	 *
	 */
	EngineProps: {[k: string]: string}
	/**
	 * If set, this SourceConfig was added from a Policy with the specified ID.
	 * This field is available in Comet 23.6.0 and later.
	 */
	PolicySourceID: string
	/**
	 * For a Policy-defined SourceConfig, this field controls whether the Protected Item will stay
	 * linked with the policy.
	 * This field is available in Comet 23.6.0 and later.
	 */
	ExistingUserUpdate: boolean
	/**
	 * By default, backup jobs from this Protected Item will be subject
	 * to the overall retention policy for the Storage Vault. You can override the policy
	 * for specific Storage Vaults by putting their destination ID as a key here.
	 * Omission from JSON will be interpreted as an empty map
	 */
	OverrideDestinationRetention?: {[k: string]: libcomet_RetentionPolicy}
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Statistics?: libcomet_SourceStatistics
}

export function New_Zero_libcomet_SourceConfig(): libcomet_SourceConfig {
	return {
		"Engine": "",
		"Description": "",
		"OwnerDevice": "",
		"CreateTime": 0,
		"ModifyTime": 0,
		"PreExec": [],
		"ThawExec": [],
		"PostExec": [],
		"EngineProps": {},
		"PolicySourceID": "",
		"ExistingUserUpdate": false,
	};
}


/**
 * SourceIncludePattern is used for pattern inclusions for File and Folder Protected Items
 * (ENGINE_BUILTIN_FILE).
 * It should be marshalled as JSON and then stored in the PINCLUDE / RINCLUDE EngineProp keys.
 */
export type libcomet_SourceIncludePattern = {
	/**
	 * The filesystem path to search within, for matches
	 */
	TopDirectory: string
	/**
	 * The pattern (glob or regex format) to match
	 */
	Value: string
}

export function New_Zero_libcomet_SourceIncludePattern(): libcomet_SourceIncludePattern {
	return {
		"TopDirectory": "",
		"Value": "",
	};
}


export type libcomet_SourceStatistics = {
	LastBackupJob: libcomet_BackupJobDetail
	LastSuccessfulBackupJob: libcomet_BackupJobDetail
}

export function New_Zero_libcomet_SourceStatistics(): libcomet_SourceStatistics {
	return {
		"LastBackupJob": New_Zero_libcomet_BackupJobDetail(),
		"LastSuccessfulBackupJob": New_Zero_libcomet_BackupJobDetail(),
	};
}


export type libcomet_SpannedDestinationLocation = {
	/**
	 * A list of underlying destinations, that will be combined and presented as one.
	 */
	SpanTargets: libcomet_DestinationLocation[]
	/**
	 * If true, this Spanned destination will use a consistent hashing scheme
	 * to immediately find specific files on exactly one of the target destinations.
	 * In the Static Slots mode, the span targets cannot be moved or merged, and
	 * the files must always remain in their original location.
	 *
	 * If false, the Spanned destination system will search all targets to find
	 * the requested file. This is slightly slower, but allows you to freely merge,
	 * split, and reorder the underlying destination locations.
	 *
	 * The default option is false.
	 */
	SpanUseStaticSlots: boolean
}

export function New_Zero_libcomet_SpannedDestinationLocation(): libcomet_SpannedDestinationLocation {
	return {
		"SpanTargets": [],
		"SpanUseStaticSlots": false,
	};
}


export type libcomet_SpannedStorageExtraInfo = {
	Targets: libcomet_StorageFreeSpaceInfo[]
}

export function New_Zero_libcomet_SpannedStorageExtraInfo(): libcomet_SpannedStorageExtraInfo {
	return {
		"Targets": [],
	};
}


export type libcomet_StatResult = {
	Buckets: number
	Users: number
	Devices: number
	Boosters: number
	NetworkDevices: number
}

export function New_Zero_libcomet_StatResult(): libcomet_StatResult {
	return {
		"Buckets": 0,
		"Users": 0,
		"Devices": 0,
		"Boosters": 0,
		"NetworkDevices": 0,
	};
}


export type libcomet_StorageFreeSpaceInfo = {
	Unlimited: boolean
	UsedPercent: number
	AvailableBytes: number
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Spanned?: libcomet_SpannedStorageExtraInfo
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	B2?: libcomet_B2StorageExtraInfo
}

export function New_Zero_libcomet_StorageFreeSpaceInfo(): libcomet_StorageFreeSpaceInfo {
	return {
		"Unlimited": false,
		"UsedPercent": 0,
		"AvailableBytes": 0,
	};
}


export type libcomet_StorageRoleOptions = {
	RoleEnabled: boolean
	Storage: libcomet_DestinationLocation
	/**
	 * LocalStorage_Legacy
	 * Omission from JSON will be interpreted as an empty array
	 * @deprecated This member has been deprecated since Comet version 17.3.5
	 */
	LocalStorage?: libcomet_LocalStorageDirectory[]
	ReplicateTo: libcomet_ReplicaServer[]
}

export function New_Zero_libcomet_StorageRoleOptions(): libcomet_StorageRoleOptions {
	return {
		"RoleEnabled": false,
		"Storage": New_Zero_libcomet_DestinationLocation(),
		"ReplicateTo": [],
	};
}


export type libcomet_StorageVaultProviderPolicy = {
	ShouldRestrictProviderList: boolean
	AllowedProvidersWhenRestricted: number[]
}

export function New_Zero_libcomet_StorageVaultProviderPolicy(): libcomet_StorageVaultProviderPolicy {
	return {
		"ShouldRestrictProviderList": false,
		"AllowedProvidersWhenRestricted": [],
	};
}


export type libcomet_StoredObject = {
	/**
	 * The name of the stored object. It is unique within this directory tree.
	 * Name
	 */
	name: string
	/**
	 * Unix timestamp in seconds
	 * ModifyTime
	 */
	mtime: number
	/**
	 * One of the STOREDOBJECTTYPE_... constant values
	 * Type
	 */
	type: string
	/**
	 * If this StoredObject represents a directory, this value can be used to recursively select the
	 * directory contents.
	 * Subtree
	 */
	subtree: string
	/**
	 * Bytes
	 * Size
	 */
	size: number
	/**
	 * DisplayName
	 * Omission from JSON will be interpreted as empty-string
	 */
	dname?: string
	/**
	 * ItemClass
	 * Omission from JSON will be interpreted as empty-string
	 */
	itemClass?: string
	/**
	 * From
	 * Omission from JSON will be interpreted as empty-string
	 */
	from?: string
	/**
	 * To
	 * Omission from JSON will be interpreted as empty-string
	 */
	to?: string
	/**
	 * ReceivedDateTime
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	rtime?: number
	/**
	 * HasAttachments
	 * Omission from JSON will be interpreted as false
	 */
	has_attachments?: boolean
	/**
	 * Unix timestamp in seconds
	 * StartTime
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	stime?: number
	/**
	 * Unix timestamp in seconds
	 * EndTime
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	etime?: number
	/**
	 * RecursiveCountKnown
	 * Omission from JSON will be interpreted as false
	 */
	r?: boolean
	/**
	 * RecursiveFiles
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	f?: number
	/**
	 * RecursiveBytes
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	b?: number
	/**
	 * RecursiveFolders
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	d?: number
}

export function New_Zero_libcomet_StoredObject(): libcomet_StoredObject {
	return {
		"name": "",
		"mtime": 0,
		"type": "",
		"subtree": "",
		"size": 0,
	};
}


export type libcomet_StorjDestinationLocation = {
	SatelliteAddress: string
	APIKey: string
	Passphrase: string
	StorjBucket: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	StorjBucketPrefix?: string
}

export function New_Zero_libcomet_StorjDestinationLocation(): libcomet_StorjDestinationLocation {
	return {
		"SatelliteAddress": "",
		"APIKey": "",
		"Passphrase": "",
		"StorjBucket": "",
	};
}


export type libcomet_StorjVirtualStorageRoleSetting = {
	SatelliteAddress: string
	APIKey: string
	Passphrase: string
	Bucket: string
}

export function New_Zero_libcomet_StorjVirtualStorageRoleSetting(): libcomet_StorjVirtualStorageRoleSetting {
	return {
		"SatelliteAddress": "",
		"APIKey": "",
		"Passphrase": "",
		"Bucket": "",
	};
}


export type libcomet_StreamableEvent = {
	Actor: string
	OwnerOrganizationID: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	ResourceID?: string
	Type: number
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	Timestamp?: number
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	TypeString?: string
	/**
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	Data?: any
}

export function New_Zero_libcomet_StreamableEvent(): libcomet_StreamableEvent {
	return {
		"Actor": "",
		"OwnerOrganizationID": "",
		"Type": 0,
	};
}


export type libcomet_SwiftDestinationLocation = {
	/**
	 * Username or UserID or Application Credential name or Application Credential ID, or blank for
	 * token authentication
	 * Omission from JSON will be interpreted as empty-string
	 */
	Username?: string
	/**
	 * User Password, or Application Credential Key, or token if the Username field is blank
	 * Omission from JSON will be interpreted as empty-string
	 */
	APIKey?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Region?: string
	/**
	 * Mandatory
	 * Omission from JSON will be interpreted as empty-string
	 */
	AuthURL?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Domain?: string
	/**
	 * Tenant name (v2) or Project name (v3)
	 * Omission from JSON will be interpreted as empty-string
	 */
	Tenant?: string
	/**
	 * Project domain name (v3)
	 * Omission from JSON will be interpreted as empty-string
	 */
	TenantDomain?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	TenantID?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	TrustID?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 * @deprecated This member has been deprecated since Comet version 17.8.0
	 */
	AuthToken?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Prefix?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	Container?: string
	/**
	 * Omission from JSON will be interpreted as empty-string
	 */
	DefaultContainerPolicy?: string
}

export function New_Zero_libcomet_SwiftDestinationLocation(): libcomet_SwiftDestinationLocation {
	return {
	};
}


export type libcomet_TestResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	Exists: boolean
}

export function New_Zero_libcomet_TestResponse(): libcomet_TestResponse {
	return {
		"Status": 0,
		"Message": "",
		"Exists": false,
	};
}

export function libcomet_TestResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_TestResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_TimeSpan = {
	/**
	 * SCHEDULE_FREQUENCY_<TYPE>
	 */
	FrequencyType: number
	/**
	 * Used for Periodic and Once Only
	 */
	Seconds: number
}

export function New_Zero_libcomet_TimeSpan(): libcomet_TimeSpan {
	return {
		"FrequencyType": 0,
		"Seconds": 0,
	};
}


export type libcomet_TotpRegeneratedResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	/**
	 * A data URI of an image of a TOTP code (e.g. "data:image/png;base64,AAA...")
	 */
	Image: string
	/**
	 * This field is available in Comet 18.9.9 and later.
	 */
	URL: string
	/**
	 * This field is available in Comet 20.3.2 and later.
	 */
	ProfileHash: string
}

export function New_Zero_libcomet_TotpRegeneratedResponse(): libcomet_TotpRegeneratedResponse {
	return {
		"Status": 0,
		"Message": "",
		"Image": "",
		"URL": "",
		"ProfileHash": "",
	};
}

export function libcomet_TotpRegeneratedResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_TotpRegeneratedResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


/**
 * @deprecated This type has been deprecated since Comet version 21.12.0
 */
export type libcomet_U2FRegisterRequest = {
	Challenge: string
	Version: string
}

export function New_Zero_libcomet_U2FRegisterRequest(): libcomet_U2FRegisterRequest {
	return {
		"Challenge": "",
		"Version": "",
	};
}


/**
 * @deprecated This type has been deprecated since Comet version 21.12.0
 */
export type libcomet_U2FRegisteredKey = {
	AppID: string
	KeyHandle: string
	Version: string
}

export function New_Zero_libcomet_U2FRegisteredKey(): libcomet_U2FRegisteredKey {
	return {
		"AppID": "",
		"KeyHandle": "",
		"Version": "",
	};
}


/**
 * @deprecated This type has been deprecated since Comet version 21.12.0
 */
export type libcomet_U2FRegistrationChallengeResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	ChallengeID: string
	AppID: string
	RegisteredKeys: libcomet_U2FRegisteredKey[]
	RegisterRequests: libcomet_U2FRegisterRequest[]
}

export function New_Zero_libcomet_U2FRegistrationChallengeResponse(): libcomet_U2FRegistrationChallengeResponse {
	return {
		"Status": 0,
		"Message": "",
		"ChallengeID": "",
		"AppID": "",
		"RegisteredKeys": [],
		"RegisterRequests": [],
	};
}

export function libcomet_U2FRegistrationChallengeResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_U2FRegistrationChallengeResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


/**
 * @deprecated This type has been deprecated since Comet version 21.12.0
 */
export type libcomet_U2FSignRequest = {
	ChallengeID: string
	ChallengeData: string
	AppID: string
	RegisteredKeys: libcomet_U2FRegisteredKey[]
}

export function New_Zero_libcomet_U2FSignRequest(): libcomet_U2FSignRequest {
	return {
		"ChallengeID": "",
		"ChallengeData": "",
		"AppID": "",
		"RegisteredKeys": [],
	};
}


/**
 * @deprecated This type has been deprecated since Comet version 21.12.0
 */
export type libcomet_U2FSignResponse = {
	ChallengeID: string
	KeyHandle: string
	Signature: string
	ClientData: string
}

export function New_Zero_libcomet_U2FSignResponse(): libcomet_U2FSignResponse {
	return {
		"ChallengeID": "",
		"KeyHandle": "",
		"Signature": "",
		"ClientData": "",
	};
}


/**
 * UninstallConfig allows configuring whether the target device will be uninstalled or not.
 */
export type libcomet_UninstallConfig = {
	/**
	 * If this option is true, the target device will receive a message asking it to uninstall the
	 * Comet Backup app.
	 */
	UninstallFlag: boolean
	/**
	 * This controls the "Remove all user settings from this device" option.
	 */
	RemoveConfigFile: boolean
}

export function New_Zero_libcomet_UninstallConfig(): libcomet_UninstallConfig {
	return {
		"UninstallFlag": false,
		"RemoveConfigFile": false,
	};
}


export type libcomet_UpdateCampaignDeviceStatus = {
	/**
	 * One of the UPDATESTATUS_ constants
	 */
	Status: number
}

export function New_Zero_libcomet_UpdateCampaignDeviceStatus(): libcomet_UpdateCampaignDeviceStatus {
	return {
		"Status": 0,
	};
}


/**
 * This data structure describes which devices should receive a remote software upgrade. Both the
 * target version criteria (UpgradeOlder/ReinstallCurrentVer/DowngradeNewer) and the target device
 * criteria (ApplyDeviceFilter/DeviceFilter) must be met in order for the remote upgrade to be
 * applied.
 */
export type libcomet_UpdateCampaignOptions = {
	Active: boolean
	UpgradeOlder: boolean
	ReinstallCurrentVer: boolean
	DowngradeNewer: boolean
	/**
	 * Choose whether this bulk upgrade campaign is allowed to interrupt a running backup job.
	 */
	ForceUpgradeRunning: boolean
	/**
	 * If true, then the UserFilter will be used to restrict which accounts and devices will be
	 * eligible for the software update. If false, all users and devices will be eligible for the
	 * software update.
	 */
	ApplyDeviceFilter: boolean
	DeviceFilter: libcomet_SearchClause
}

export function New_Zero_libcomet_UpdateCampaignOptions(): libcomet_UpdateCampaignOptions {
	return {
		"Active": false,
		"UpgradeOlder": false,
		"ReinstallCurrentVer": false,
		"DowngradeNewer": false,
		"ForceUpgradeRunning": false,
		"ApplyDeviceFilter": false,
		"DeviceFilter": New_Zero_libcomet_SearchClause(),
	};
}


export type libcomet_UpdateCampaignProperties = {
	Active: boolean
	UpgradeOlder: boolean
	ReinstallCurrentVer: boolean
	DowngradeNewer: boolean
	/**
	 * Choose whether this bulk upgrade campaign is allowed to interrupt a running backup job.
	 */
	ForceUpgradeRunning: boolean
	/**
	 * If true, then the UserFilter will be used to restrict which accounts and devices will be
	 * eligible for the software update. If false, all users and devices will be eligible for the
	 * software update.
	 */
	ApplyDeviceFilter: boolean
	DeviceFilter: libcomet_SearchClause
	/**
	 * Unix timestamp, in seconds
	 */
	StartTime: number
	TargetVersion: string
}

export function New_Zero_libcomet_UpdateCampaignProperties(): libcomet_UpdateCampaignProperties {
	return {
		"Active": false,
		"UpgradeOlder": false,
		"ReinstallCurrentVer": false,
		"DowngradeNewer": false,
		"ForceUpgradeRunning": false,
		"ApplyDeviceFilter": false,
		"DeviceFilter": New_Zero_libcomet_SearchClause(),
		"StartTime": 0,
		"TargetVersion": "",
	};
}

export function libcomet_UpdateCampaignProperties_set_embedded_libcomet_UpdateCampaignOptions(dest: libcomet_UpdateCampaignProperties, src: libcomet_UpdateCampaignOptions): void {
	dest.Active = src.Active;
	dest.UpgradeOlder = src.UpgradeOlder;
	dest.ReinstallCurrentVer = src.ReinstallCurrentVer;
	dest.DowngradeNewer = src.DowngradeNewer;
	dest.ForceUpgradeRunning = src.ForceUpgradeRunning;
	dest.ApplyDeviceFilter = src.ApplyDeviceFilter;
	dest.DeviceFilter = src.DeviceFilter;
}


export type libcomet_UpdateCampaignStatus = {
	Active: boolean
	UpgradeOlder: boolean
	ReinstallCurrentVer: boolean
	DowngradeNewer: boolean
	/**
	 * Choose whether this bulk upgrade campaign is allowed to interrupt a running backup job.
	 */
	ForceUpgradeRunning: boolean
	/**
	 * If true, then the UserFilter will be used to restrict which accounts and devices will be
	 * eligible for the software update. If false, all users and devices will be eligible for the
	 * software update.
	 */
	ApplyDeviceFilter: boolean
	DeviceFilter: libcomet_SearchClause
	/**
	 * Unix timestamp, in seconds
	 */
	StartTime: number
	TargetVersion: string
	Devices: libcomet_UpdateCampaignStatusDeviceEntry[]
}

export function New_Zero_libcomet_UpdateCampaignStatus(): libcomet_UpdateCampaignStatus {
	return {
		"Active": false,
		"UpgradeOlder": false,
		"ReinstallCurrentVer": false,
		"DowngradeNewer": false,
		"ForceUpgradeRunning": false,
		"ApplyDeviceFilter": false,
		"DeviceFilter": New_Zero_libcomet_SearchClause(),
		"StartTime": 0,
		"TargetVersion": "",
		"Devices": [],
	};
}

export function libcomet_UpdateCampaignStatus_set_embedded_libcomet_UpdateCampaignProperties(dest: libcomet_UpdateCampaignStatus, src: libcomet_UpdateCampaignProperties): void {
	dest.Active = src.Active;
	dest.UpgradeOlder = src.UpgradeOlder;
	dest.ReinstallCurrentVer = src.ReinstallCurrentVer;
	dest.DowngradeNewer = src.DowngradeNewer;
	dest.ForceUpgradeRunning = src.ForceUpgradeRunning;
	dest.ApplyDeviceFilter = src.ApplyDeviceFilter;
	dest.DeviceFilter = src.DeviceFilter;
	dest.StartTime = src.StartTime;
	dest.TargetVersion = src.TargetVersion;
}


export type libcomet_UpdateCampaignStatusDeviceEntry = {
	Username: string
	DeviceID: string
	/**
	 * One of the UPDATESTATUS_ constants
	 */
	Status: number
}

export function New_Zero_libcomet_UpdateCampaignStatusDeviceEntry(): libcomet_UpdateCampaignStatusDeviceEntry {
	return {
		"Username": "",
		"DeviceID": "",
		"Status": 0,
	};
}

export function libcomet_UpdateCampaignStatusDeviceEntry_set_embedded_libcomet_UpdateCampaignDeviceStatus(dest: libcomet_UpdateCampaignStatusDeviceEntry, src: libcomet_UpdateCampaignDeviceStatus): void {
	dest.Status = src.Status;
}


export type libcomet_UserCustomEmailSettings = {
	Reports: libcomet_EmailReportConfig[]
}

export function New_Zero_libcomet_UserCustomEmailSettings(): libcomet_UserCustomEmailSettings {
	return {
		"Reports": [],
	};
}


export type libcomet_UserOnServer = {
	/**
	 * The server where this user was found. The 0-based indexes here correspond to the entries inside
	 * ConstellationRoleOptions->Servers.
	 */
	ServerID: number
	Username: string
}

export function New_Zero_libcomet_UserOnServer(): libcomet_UserOnServer {
	return {
		"ServerID": 0,
		"Username": "",
	};
}


export type libcomet_UserPolicy = {
	PreventRequestStorageVault: boolean
	PreventAddCustomStorageVault: boolean
	PreventEditStorageVault: boolean
	HideCloudStorageBranding: boolean
	PreventDeleteStorageVault: boolean
	StorageVaultProviders: libcomet_StorageVaultProviderPolicy
	PreventNewProtectedItem: boolean
	PreventEditProtectedItem: boolean
	PreventDeleteProtectedItem: boolean
	ProtectedItemEngineTypes: libcomet_ProtectedItemEngineTypePolicy
	/**
	 * Omission from JSON will be interpreted as an empty array
	 */
	FileAndFolderMandatoryExclusions?: libcomet_ExtraFileExclusion[]
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	ModeScheduleSkipAlreadyRunning?: number
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	ModeAdminResetPassword?: number
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	ModeAdminViewFilenames?: number
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	ModeRequireUserResetPassword?: number
	PreventDeleteSingleSnapshots: boolean
	PreventChangeAccountPassword: boolean
	PreventChangeEmailSettings: boolean
	PreventChangeAccountName: boolean
	PreventOpenAppUI: boolean
	RequirePasswordOpenAppUI: boolean
	HideAppImport: boolean
	HideAppVersion: boolean
	PreventOpenWebUI: boolean
	PreventViewDeviceNames: boolean
	DefaultEmailReports: libcomet_DefaultEmailReportPolicy
	DefaultStorageVaultRetention: libcomet_RetentionPolicy
	EnforceStorageVaultRetention: boolean
	PreventProtectedItemRetention: boolean
	AllowEditObjectLockRetention: boolean
	DefaultSources: {[k: string]: libcomet_SourceConfig}
	DefaultSourcesBackupRules: {[k: string]: libcomet_BackupRuleConfig}
	DefaultSourcesWithOSRestriction: {[k: string]: libcomet_DefaultSourceWithOSRestriction}
	DefaultBackupRules: {[k: string]: libcomet_BackupRuleConfig}
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	RandomDelaySecs?: number
}

export function New_Zero_libcomet_UserPolicy(): libcomet_UserPolicy {
	return {
		"PreventRequestStorageVault": false,
		"PreventAddCustomStorageVault": false,
		"PreventEditStorageVault": false,
		"HideCloudStorageBranding": false,
		"PreventDeleteStorageVault": false,
		"StorageVaultProviders": New_Zero_libcomet_StorageVaultProviderPolicy(),
		"PreventNewProtectedItem": false,
		"PreventEditProtectedItem": false,
		"PreventDeleteProtectedItem": false,
		"ProtectedItemEngineTypes": New_Zero_libcomet_ProtectedItemEngineTypePolicy(),
		"PreventDeleteSingleSnapshots": false,
		"PreventChangeAccountPassword": false,
		"PreventChangeEmailSettings": false,
		"PreventChangeAccountName": false,
		"PreventOpenAppUI": false,
		"RequirePasswordOpenAppUI": false,
		"HideAppImport": false,
		"HideAppVersion": false,
		"PreventOpenWebUI": false,
		"PreventViewDeviceNames": false,
		"DefaultEmailReports": New_Zero_libcomet_DefaultEmailReportPolicy(),
		"DefaultStorageVaultRetention": New_Zero_libcomet_RetentionPolicy(),
		"EnforceStorageVaultRetention": false,
		"PreventProtectedItemRetention": false,
		"AllowEditObjectLockRetention": false,
		"DefaultSources": {},
		"DefaultSourcesBackupRules": {},
		"DefaultSourcesWithOSRestriction": {},
		"DefaultBackupRules": {},
	};
}


/**
 * This is the main data structure for a user's profile.
 */
export type libcomet_UserProfileConfig = {
	/**
	 * The name for this account. It uniquely identifies this UserProfileConfig across the entire Comet
	 * Server. It cannot be changed directly.
	 */
	Username: string
	/**
	 * A longer descriptive name for this account. It is not necessarily unique to the Comet Server.
	 * The end-user might be able to change it inside the Comet Backup desktop app.
	 */
	AccountName: string
	/**
	 * Timezone in IANA format. Individual devices may declare a more specific timezone in the Devices
	 * field.
	 */
	LocalTimezone: string
	/**
	 * One of the supported languages, such as en_US (DEFAULT_LANGUAGE).
	 */
	LanguageCode: string
	/**
	 * Tenant
	 * Omission from JSON will be interpreted as empty-string
	 */
	OrganizationID?: string
	/**
	 * A list of email addresses to send reports to.
	 */
	Emails: string[]
	/**
	 * By default, all the email addresses in the Emails field will receieve the policy-default or
	 * server-wide-default style of email report. Add an override for a specific email address in here
	 * to allow customizing the email report that will be received.
	 */
	OverrideEmailSettings: {[k: string]: libcomet_UserCustomEmailSettings}
	/**
	 * This option can be used to control whether any email reports are sent.
	 */
	SendEmailReports: boolean
	/**
	 * Storage Vaults
	 * The string keys can be any unique key. Using a GUID is recommended, but optional.
	 */
	Destinations: {[k: string]: libcomet_DestinationConfig}
	/**
	 * Protected Items
	 * The string keys can be any unique key. Using a GUID is recommended, but optional.
	 */
	Sources: {[k: string]: libcomet_SourceConfig}
	/**
	 * Schedules
	 * The string keys can be any unique key. Using a GUID is recommended, but optional.
	 */
	BackupRules: {[k: string]: libcomet_BackupRuleConfig}
	/**
	 * Devices
	 * The string keys are the device's ID. The device ID is generated automatically based on a mix of
	 * hardware and software identifiers on the installed PC.
	 * To revoke a device, use the AdminRevokeDevice API instead of accessing these fields directly.
	 * This API can also remove associated Protected Items, uninstall the remote device, and disconnect
	 * its live connection.
	 */
	Devices: {[k: string]: libcomet_DeviceConfig}
	IsSuspended: boolean
	/**
	 * Unix timestamp in seconds. Zero if the device is not suspended.
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	LastSuspended?: number
	/**
	 * A limit on the total Size of all Protected Items in this account. The number of bytes should be
	 * configured in AllProtectedItemsQuotaBytes.
	 */
	AllProtectedItemsQuotaEnabled: boolean
	/**
	 * A limit on the total Size of all Protected Items in this account. It is enforced if
	 * AllProtectedItemsQuotaEnabled is true.
	 */
	AllProtectedItemsQuotaBytes: number
	/**
	 * A limit on the total number of devices registered in this account. Set to zero to allow
	 * unlimited devices.
	 */
	MaximumDevices: number
	/**
	 * A limit on the total number of Office 365 Protected Accounts across all Office 365 Protected
	 * Items in this account. Set to zero to allow unlimited Office 365 Protected Accounts.
	 */
	QuotaOffice365ProtectedAccounts: number
	/**
	 * If the PolicyID field is set to a non-empty string, the Comet Server will enforce the contents
	 * of the Policy field based on the matching server's policy. Otherwise if the PolicyID field is
	 * set to an empty string, the administrator may configure any custom values in the Policy field.
	 */
	PolicyID: string
	/**
	 * The Policy field contains a read-only copy of the effective Policy that is applied to this user
	 * account.
	 */
	Policy: libcomet_UserPolicy
	/**
	 * One of the PASSWORD_FORMAT_ constants
	 * To change the user's password, use the AdminResetUserPassword API instead of accessing these
	 * fields directly. Otherwise, other encrypted fields in the user profile may become corrupted.
	 */
	PasswordFormat: number
	PasswordHash: string
	/**
	 * If this field is empty, the "Allow administrator to reset my password" feature is turned off. If
	 * this field is filled, it contains a cryptographic root of trust that can decrypt and re-encrypt
	 * other secrets in this profile.
	 * Omission from JSON will be interpreted as empty-string
	 */
	PasswordRecovery?: string
	AllowPasswordLogin: boolean
	/**
	 * If true, then TOTP is required to open the desktop app or the Comet Server web interface with
	 * this user's credentials.
	 */
	AllowPasswordAndTOTPLogin: boolean
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	TOTPKeyEncryptionFormat: number
	TOTPKey: string
	/**
	 * This field is available in Comet 20.3.4 and later.
	 */
	RequirePasswordChange: boolean
	/**
	 * Unix timestamp in seconds
	 */
	CreateTime: number
	/**
	 * A random GUID that is allocated when the user profile is created for the first time. You can use
	 * this to help disambiguate users with the same username across multiple Comet Servers.
	 */
	CreationGUID: string
	/**
	 * Additional server-wide settings that are enforced for this user profile
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	ServerConfig?: libcomet_UserServerConfig
}

export function New_Zero_libcomet_UserProfileConfig(): libcomet_UserProfileConfig {
	return {
		"Username": "",
		"AccountName": "",
		"LocalTimezone": "",
		"LanguageCode": "",
		"Emails": [],
		"OverrideEmailSettings": {},
		"SendEmailReports": false,
		"Destinations": {},
		"Sources": {},
		"BackupRules": {},
		"Devices": {},
		"IsSuspended": false,
		"AllProtectedItemsQuotaEnabled": false,
		"AllProtectedItemsQuotaBytes": 0,
		"MaximumDevices": 0,
		"QuotaOffice365ProtectedAccounts": 0,
		"PolicyID": "",
		"Policy": New_Zero_libcomet_UserPolicy(),
		"PasswordFormat": 0,
		"PasswordHash": "",
		"AllowPasswordLogin": false,
		"AllowPasswordAndTOTPLogin": false,
		"TOTPKeyEncryptionFormat": 0,
		"TOTPKey": "",
		"RequirePasswordChange": false,
		"CreateTime": 0,
		"CreationGUID": "",
	};
}


/**
 * @deprecated This type has been deprecated since Comet version 23.3.5
 */
export type libcomet_UserProfileFragment = {
	Username: string
}

export function New_Zero_libcomet_UserProfileFragment(): libcomet_UserProfileFragment {
	return {
		"Username": "",
	};
}


export type libcomet_UserServerConfig = {
	/**
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	RandomDelaySecs?: number
}

export function New_Zero_libcomet_UserServerConfig(): libcomet_UserServerConfig {
	return {
	};
}


export type libcomet_VMDKSnapshotViewOptions = {
	/**
	 * Request a list of stored objects in vmdk file. It should be always true for restoring single
	 * files from vmdk file
	 */
	Enabled: boolean
	/**
	 * The vmdk filename inside subdirectory of disk image, should be end with .vmdk
	 */
	PartitionGUID: string
	/**
	 * Browse objects' paths inside vmdk file
	 */
	ListPath: string
	PartitionName: string
}

export function New_Zero_libcomet_VMDKSnapshotViewOptions(): libcomet_VMDKSnapshotViewOptions {
	return {
		"Enabled": false,
		"PartitionGUID": "",
		"ListPath": "",
		"PartitionName": "",
	};
}


export type libcomet_VSSComponent = {
	Path: string
	Name: string
	/**
	 * "VSS_CT_DATABASE" or "VSS_CT_FILEGROUP"
	 */
	CType: string
	Selectable: boolean
}

export function New_Zero_libcomet_VSSComponent(): libcomet_VSSComponent {
	return {
		"Path": "",
		"Name": "",
		"CType": "",
		"Selectable": false,
	};
}


export type libcomet_VSSWriterInfo = {
	DisplayName: string
	Components: libcomet_VSSComponent[]
}

export function New_Zero_libcomet_VSSWriterInfo(): libcomet_VSSWriterInfo {
	return {
		"DisplayName": "",
		"Components": [],
	};
}


export type libcomet_VaultSnapshot = {
	Snapshot: string
	Source: string
	CreateTime: number
	/**
	 * This field is available in Comet 20.12.4 and later.
	 */
	HasOriginalPathInfo: boolean
}

export function New_Zero_libcomet_VaultSnapshot(): libcomet_VaultSnapshot {
	return {
		"Snapshot": "",
		"Source": "",
		"CreateTime": 0,
		"HasOriginalPathInfo": false,
	};
}


export type libcomet_WasabiVirtualStorageRoleSettings = {
	MasterBucket: string
	AccessKey: string
	SecretKey: string
	/**
	 * UseObjectLock_Legacy_DoNotUse
	 */
	UseObjectLock: boolean
	ObjectLockMode: number
	ObjectLockDays: number
	RemoveDeleted: boolean
}

export function New_Zero_libcomet_WasabiVirtualStorageRoleSettings(): libcomet_WasabiVirtualStorageRoleSettings {
	return {
		"MasterBucket": "",
		"AccessKey": "",
		"SecretKey": "",
		"UseObjectLock": false,
		"ObjectLockMode": 0,
		"ObjectLockDays": 0,
		"RemoveDeleted": false,
	};
}


export type libcomet_WebAuthnAuthenticatorSelection = {
	/**
	 * AuthenticatorAttachment
	 * Omission from JSON will be interpreted as empty-string
	 */
	authenticatorAttachment?: string
	/**
	 * RequireResidentKey
	 * Omission from JSON will be interpreted as false
	 */
	requireResidentKey?: boolean
	/**
	 * ResidentKey
	 * Omission from JSON will be interpreted as empty-string
	 */
	residentKey?: string
	/**
	 * UserVerification
	 * Omission from JSON will be interpreted as empty-string
	 */
	userVerification?: string
}

export function New_Zero_libcomet_WebAuthnAuthenticatorSelection(): libcomet_WebAuthnAuthenticatorSelection {
	return {
	};
}


export type libcomet_WebAuthnCredential = {
	PublicKey: string
	AttestationType: string
	AAGUID: string
	SignCount: number
	CloneWarning: boolean
}

export function New_Zero_libcomet_WebAuthnCredential(): libcomet_WebAuthnCredential {
	return {
		"PublicKey": "",
		"AttestationType": "",
		"AAGUID": "",
		"SignCount": 0,
		"CloneWarning": false,
	};
}


export type libcomet_WebAuthnCredentialAssertion = {
	/**
	 * Response
	 */
	publicKey: libcomet_WebAuthnPublicKeyCredentialRequestOptions
}

export function New_Zero_libcomet_WebAuthnCredentialAssertion(): libcomet_WebAuthnCredentialAssertion {
	return {
		"publicKey": New_Zero_libcomet_WebAuthnPublicKeyCredentialRequestOptions(),
	};
}


export type libcomet_WebAuthnCredentialDescriptor = {
	/**
	 * Type
	 */
	type: string
	/**
	 * CredentialID
	 * In other language projections, this field may contain raw binary data. When the field is expressed as JSON, this field contains base64 content. This javascript/typescript SDK preserves the base64 version in this field.
	 */
	id: string
	/**
	 * Transport
	 * Omission from JSON will be interpreted as an empty array
	 */
	transports?: string[]
}

export function New_Zero_libcomet_WebAuthnCredentialDescriptor(): libcomet_WebAuthnCredentialDescriptor {
	return {
		"type": "",
		"id": "",
	};
}


export type libcomet_WebAuthnCredentialEntity = {
	/**
	 * Name
	 */
	name: string
	/**
	 * Icon
	 * Omission from JSON will be interpreted as empty-string
	 */
	icon?: string
}

export function New_Zero_libcomet_WebAuthnCredentialEntity(): libcomet_WebAuthnCredentialEntity {
	return {
		"name": "",
	};
}


export type libcomet_WebAuthnCredentialParameter = {
	/**
	 * Type
	 */
	type: string
	/**
	 * Algorithm
	 */
	alg: number
}

export function New_Zero_libcomet_WebAuthnCredentialParameter(): libcomet_WebAuthnCredentialParameter {
	return {
		"type": "",
		"alg": 0,
	};
}


export type libcomet_WebAuthnPublicKeyCredentialCreationOptions = {
	/**
	 * Challenge
	 * In other language projections, this field may contain raw binary data. When the field is expressed as JSON, this field contains base64 content. This javascript/typescript SDK preserves the base64 version in this field.
	 */
	challenge: string
	/**
	 * RelyingParty
	 */
	rp: libcomet_WebAuthnRelyingPartyEntity
	/**
	 * User
	 */
	user: libcomet_WebAuthnUserEntity
	/**
	 * Parameters
	 * Omission from JSON will be interpreted as an empty array
	 */
	pubKeyCredParams?: libcomet_WebAuthnCredentialParameter[]
	/**
	 * AuthenticatorSelection
	 * Omission from JSON will be interpreted as the zero value for this field type
	 */
	authenticatorSelection?: libcomet_WebAuthnAuthenticatorSelection
	/**
	 * Timeout
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	timeout?: number
	/**
	 * CredentialExcludeList
	 * Omission from JSON will be interpreted as an empty array
	 */
	excludeCredentials?: libcomet_WebAuthnCredentialDescriptor[]
	/**
	 * Extensions
	 * Omission from JSON will be interpreted as an empty map
	 */
	extensions?: {[k: string]: any}
	/**
	 * Attestation
	 * Omission from JSON will be interpreted as empty-string
	 */
	attestation?: string
}

export function New_Zero_libcomet_WebAuthnPublicKeyCredentialCreationOptions(): libcomet_WebAuthnPublicKeyCredentialCreationOptions {
	return {
		"challenge": "",
		"rp": New_Zero_libcomet_WebAuthnRelyingPartyEntity(),
		"user": New_Zero_libcomet_WebAuthnUserEntity(),
	};
}


export type libcomet_WebAuthnPublicKeyCredentialRequestOptions = {
	/**
	 * Challenge
	 * In other language projections, this field may contain raw binary data. When the field is expressed as JSON, this field contains base64 content. This javascript/typescript SDK preserves the base64 version in this field.
	 */
	challenge: string
	/**
	 * Timeout
	 * Omission from JSON will be interpreted as 0 (zero)
	 */
	timeout?: number
	/**
	 * RelyingPartyID
	 * Omission from JSON will be interpreted as empty-string
	 */
	rpId?: string
	/**
	 * AllowedCredentials
	 * Omission from JSON will be interpreted as an empty array
	 */
	allowCredentials?: libcomet_WebAuthnCredentialDescriptor[]
	/**
	 * UserVerification
	 * Omission from JSON will be interpreted as empty-string
	 */
	userVerification?: string
	/**
	 * Extensions
	 * Omission from JSON will be interpreted as an empty map
	 */
	extensions?: {[k: string]: any}
}

export function New_Zero_libcomet_WebAuthnPublicKeyCredentialRequestOptions(): libcomet_WebAuthnPublicKeyCredentialRequestOptions {
	return {
		"challenge": "",
	};
}


export type libcomet_WebAuthnRegistrationChallengeResponse = {
	/**
	 * If the operation was successful, the status will be in the 200-299 range.
	 */
	Status: number
	Message: string
	ChallengeID: string
	CredentialCreationOptions: libcomet_WebAuthnPublicKeyCredentialCreationOptions
}

export function New_Zero_libcomet_WebAuthnRegistrationChallengeResponse(): libcomet_WebAuthnRegistrationChallengeResponse {
	return {
		"Status": 0,
		"Message": "",
		"ChallengeID": "",
		"CredentialCreationOptions": New_Zero_libcomet_WebAuthnPublicKeyCredentialCreationOptions(),
	};
}

export function libcomet_WebAuthnRegistrationChallengeResponse_set_embedded_libcomet_CometAPIResponseMessage(dest: libcomet_WebAuthnRegistrationChallengeResponse, src: libcomet_CometAPIResponseMessage): void {
	dest.Status = src.Status;
	dest.Message = src.Message;
}


export type libcomet_WebAuthnRelyingPartyEntity = {
	/**
	 * Name
	 */
	name: string
	/**
	 * Icon
	 * Omission from JSON will be interpreted as empty-string
	 */
	icon?: string
	/**
	 * ID
	 */
	id: string
}

export function New_Zero_libcomet_WebAuthnRelyingPartyEntity(): libcomet_WebAuthnRelyingPartyEntity {
	return {
		"name": "",
		"id": "",
	};
}

export function libcomet_WebAuthnRelyingPartyEntity_set_embedded_libcomet_WebAuthnCredentialEntity(dest: libcomet_WebAuthnRelyingPartyEntity, src: libcomet_WebAuthnCredentialEntity): void {
	dest.name = src.name;
	dest.icon = src.icon;
}


export type libcomet_WebAuthnSignRequest = {
	ChallengeID: string
	Assertion: libcomet_WebAuthnCredentialAssertion
}

export function New_Zero_libcomet_WebAuthnSignRequest(): libcomet_WebAuthnSignRequest {
	return {
		"ChallengeID": "",
		"Assertion": New_Zero_libcomet_WebAuthnCredentialAssertion(),
	};
}


export type libcomet_WebAuthnSignResponse = {
	ChallengeID: string
	CredentialJSON: string
}

export function New_Zero_libcomet_WebAuthnSignResponse(): libcomet_WebAuthnSignResponse {
	return {
		"ChallengeID": "",
		"CredentialJSON": "",
	};
}


export type libcomet_WebAuthnUserEntity = {
	/**
	 * Name
	 */
	name: string
	/**
	 * Icon
	 * Omission from JSON will be interpreted as empty-string
	 */
	icon?: string
	/**
	 * DisplayName
	 * Omission from JSON will be interpreted as empty-string
	 */
	displayName?: string
	/**
	 * ID
	 * In other language projections, this field may contain raw binary data. When the field is expressed as JSON, this field contains base64 content. This javascript/typescript SDK preserves the base64 version in this field.
	 */
	id: string
}

export function New_Zero_libcomet_WebAuthnUserEntity(): libcomet_WebAuthnUserEntity {
	return {
		"name": "",
		"id": "",
	};
}

export function libcomet_WebAuthnUserEntity_set_embedded_libcomet_WebAuthnCredentialEntity(dest: libcomet_WebAuthnUserEntity, src: libcomet_WebAuthnCredentialEntity): void {
	dest.name = src.name;
	dest.icon = src.icon;
}


/**
 * This type is available in Comet 23.6.9 and later.
 */
export type libcomet_WebDavDestinationLocation = {
	/**
	 * The URL of the WebDAV server, including http/https and any custom port
	 * Omission from JSON will be interpreted as empty-string
	 */
	DavServer?: string
	/**
	 * The username for logging in to the WebDAV server
	 * Omission from JSON will be interpreted as empty-string
	 */
	UserName?: string
	/**
	 * The password for logging in to the WebDAV server
	 * Omission from JSON will be interpreted as empty-string
	 */
	AccessKey?: string
	/**
	 * The target directory path within the WebDAV server
	 * Omission from JSON will be interpreted as empty-string
	 */
	Path?: string
}

export function New_Zero_libcomet_WebDavDestinationLocation(): libcomet_WebDavDestinationLocation {
	return {
	};
}


export type libcomet_WebInterfaceBrandingProperties = {
	/**
	 * One of the BRANDINGSTYLETYPE_ constants
	 * This field is available in Comet 23.3.3 and later.
	 */
	BrandingStyleType: number
	BrandName: string
	LogoImage: string
	TopColor: string
	AccentColor: string
	Favicon: string
	HideNewsArea: boolean
}

export function New_Zero_libcomet_WebInterfaceBrandingProperties(): libcomet_WebInterfaceBrandingProperties {
	return {
		"BrandingStyleType": 0,
		"BrandName": "",
		"LogoImage": "",
		"TopColor": "",
		"AccentColor": "",
		"Favicon": "",
		"HideNewsArea": false,
	};
}


/**
 * WebhookOption defines the configuration of a webhook target. The Comet Server will send a live
 * HTTP POST event to the webhook URL when certain events happen.
 */
export type libcomet_WebhookOption = {
	/**
	 * The target URL to POST the event data to
	 */
	URL: string
	/**
	 * CustomHeaders allows specifying custom headers which are added to the outgoing POST request
	 * from Comet Server. Custom headers are specified as (header name, header value) pairs. If a
	 * custom header conflicts with a header required by HTTP or the Comet tracing ID header
	 * (`x-Comet-Tracing-Id`), it will be ignored.
	 */
	CustomHeaders: {[k: string]: string}
	/**
	 * One of the STREAM_LEVEL_ constants. This controls how much data is sent in the webhook event.
	 */
	Level: string
	/**
	 * Configure a subset of allowed event types (see SEVT_ constants). If the array is empty, all
	 * events will be sent
	 */
	WhiteListedEventTypes: number[]
}

export function New_Zero_libcomet_WebhookOption(): libcomet_WebhookOption {
	return {
		"URL": "",
		"CustomHeaders": {},
		"Level": "",
		"WhiteListedEventTypes": [],
	};
}


export type libcomet_WinSMBAuth = {
	/**
	 * The UNC path for the Windows network share (SMB).
	 */
	SharePath: string
	/**
	 * The username to log in to the Windows network share (SMB).
	 */
	Username: string
	/**
	 * The password might be hashed. To set this in cleartext, set PasswordFormat to 0
	 * (PASSWORD_FORMAT_PLAINTEXT).
	 */
	Password: string
	/**
	 * The hash algorithm that is used for the Password field. It is one of the PASSWORD_FORMAT_
	 * constants.
	 */
	PasswordFormat: number
}

export function New_Zero_libcomet_WinSMBAuth(): libcomet_WinSMBAuth {
	return {
		"SharePath": "",
		"Username": "",
		"Password": "",
		"PasswordFormat": 0,
	};
}


export type libcomet_WindowsCodeSignProperties = {
	/**
	 * One of the WINDOWSCODESIGN_METHOD_ constants
	 */
	WindowsCodeSignMethod: number
	WindowsCodeSignPKCS12FilePath: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS12PasswordFormat: number
	WindowsCodeSignPKCS12Password: string
	WindowsCodeSignPKCS11Engine: string
	WindowsCodeSignPKCS11Module: string
	/**
	 * This field was deprecated between 23.3.0 and 23.6.x, but is now used again.
	 */
	WindowsCodeSignPKCS11Certfile: string
	WindowsCodeSignPKCS11KeyID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignPKCS11PasswordFormat: number
	WindowsCodeSignPKCS11Password: string
	WindowsCodeSignAzureVaultName: string
	WindowsCodeSignAzureCertName: string
	WindowsCodeSignAzureAppID: string
	/**
	 * One of the ENCRYPTIONMETHOD_ constants
	 */
	WindowsCodeSignAzureAppSecretFormat: number
	WindowsCodeSignAzureAppSecret: string
	WindowsCodeSignAzureTenantID: string
}

export function New_Zero_libcomet_WindowsCodeSignProperties(): libcomet_WindowsCodeSignProperties {
	return {
		"WindowsCodeSignMethod": 0,
		"WindowsCodeSignPKCS12FilePath": "",
		"WindowsCodeSignPKCS12PasswordFormat": 0,
		"WindowsCodeSignPKCS12Password": "",
		"WindowsCodeSignPKCS11Engine": "",
		"WindowsCodeSignPKCS11Module": "",
		"WindowsCodeSignPKCS11Certfile": "",
		"WindowsCodeSignPKCS11KeyID": "",
		"WindowsCodeSignPKCS11PasswordFormat": 0,
		"WindowsCodeSignPKCS11Password": "",
		"WindowsCodeSignAzureVaultName": "",
		"WindowsCodeSignAzureCertName": "",
		"WindowsCodeSignAzureAppID": "",
		"WindowsCodeSignAzureAppSecretFormat": 0,
		"WindowsCodeSignAzureAppSecret": "",
		"WindowsCodeSignAzureTenantID": "",
	};
}

// METHODS

export default abstract class CometServerAPIBase {

    _server_url: string;

    /**
     * Construct a new CometServerAPIBase instance.
     *
     * @param {string} server_url
     */
    constructor(server_url: string) {
        this._server_url = server_url;
    }

    /**
     * Perform a network request. Must be overridden by a child class.
     *
     * @param {string} call The endpoint URI
     * @param {Object.<string,string>} params The POST data parameters
     * @return {Promise}
     */
    abstract _requestP(call: string, params: {[x: string]: string}): Promise<any>;

	/**
	 * AdminAccountProperties
	 * Retrieve properties about the current admin account
	 * Some key parameters are obscured, but the obscured values are safely recognised by the corresponding AdminAccountSetProperties API.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<libcomet_AdminAccountPropertiesResponse>}
	 */
	async AdminAccountPropertiesP(): Promise<libcomet_AdminAccountPropertiesResponse> {
		return await this._requestP("api/v1/admin/account/properties", {});
	}

	/**
	 * AdminAccountRegenerateTotp
	 * Generate a new TOTP secret
	 * The secret is returned as a `data-uri` image of a QR code. The new secret is immediately applied to the current admin account.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<libcomet_TotpRegeneratedResponse>}
	 */
	async AdminAccountRegenerateTotpP(): Promise<libcomet_TotpRegeneratedResponse> {
		return await this._requestP("api/v1/admin/account/regenerate-totp", {});
	}

	/**
	 * AdminAccountSessionRevoke
	 * Revoke a session key (log out)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAccountSessionRevokeP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/admin/account/session-revoke", {});
	}

	/**
	 * AdminAccountSessionStart
	 * Generate a session key (log in)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string|null} SelfAddress External URL of this server
	 * @return {Promise<libcomet_SessionKeyRegeneratedResponse>}
	 */
	async AdminAccountSessionStartP(SelfAddress: string|null = null): Promise<libcomet_SessionKeyRegeneratedResponse> {
		const params: { [s: string]: string; } = {};
		if (SelfAddress === null) {
			params["SelfAddress"] = this._server_url;
		} else {
			params["SelfAddress"] = SelfAddress;
		}
		return await this._requestP("api/v1/admin/account/session-start", params);
	}

	/**
	 * AdminAccountSessionStartAsUser
	 * Generate a session key for an end-user (log in as end-user)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} TargetUser Target account username
	 * @return {Promise<libcomet_SessionKeyRegeneratedResponse>}
	 */
	async AdminAccountSessionStartAsUserP(TargetUser: string): Promise<libcomet_SessionKeyRegeneratedResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/account/session-start-as-user", params);
	}

	/**
	 * AdminAccountSessionUpgrade
	 * Upgrade a session key which is pending an MFA upgrade to a full session key
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} SessionKey The session key to upgrade
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAccountSessionUpgradeP(SessionKey: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["SessionKey"] = SessionKey;
		return await this._requestP("api/v1/admin/account/session-upgrade", params);
	}

	/**
	 * AdminAccountSetProperties
	 * Update settings for your own admin account
	 * Updating your account password requires you to supply your current password.
	 * To set a new plaintext password, use a password format of 0 (PASSWORD_FORMAT_PLAINTEXT).
	 * This API does not currently allow you to modify your TOTP secret or IP whitelist.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {libcomet_AdminSecurityOptions} Security Updated account properties
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAccountSetPropertiesP(Security: libcomet_AdminSecurityOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Security"] = JSON.stringify(Security);
		return await this._requestP("api/v1/admin/account/set-properties", params);
	}

	/**
	 * AdminAccountU2fRequestRegistrationChallenge
	 * Register a new FIDO U2F token
	 * Browser support for U2F is ending in February 2022. WebAuthn is backwards
	 * compatible with U2F keys, and Comet will automatically migrate existing U2F keys
	 * to allow their use with the WebAuthn endpoints.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} SelfAddress External URL of this server, used as U2F AppID and Facet
	 * @return {Promise<libcomet_U2FRegistrationChallengeResponse>}
	 */
	async AdminAccountU2fRequestRegistrationChallengeP(SelfAddress: string): Promise<libcomet_U2FRegistrationChallengeResponse> {
		const params: { [s: string]: string; } = {};
		params["SelfAddress"] = SelfAddress;
		return await this._requestP("api/v1/admin/account/u2f/request-registration-challenge", params);
	}

	/**
	 * AdminAccountU2fSubmitChallengeResponse
	 * Register a new FIDO U2F token
	 * Browser support for U2F is ending in February 2022. WebAuthn is backwards
	 * compatible with U2F keys, and Comet will automatically migrate existing U2F keys
	 * to allow their use with the WebAuthn endpoints.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} U2FChallengeID Associated value from AdminAccountU2fRequestRegistrationChallenge API
	 * @param {string} U2FClientData U2F response data supplied by hardware token
	 * @param {string} U2FRegistrationData U2F response data supplied by hardware token
	 * @param {string} U2FVersion U2F response data supplied by hardware token
	 * @param {string|null} Description Description of the token
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAccountU2fSubmitChallengeResponseP(U2FChallengeID: string, U2FClientData: string, U2FRegistrationData: string, U2FVersion: string, Description: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["U2FChallengeID"] = U2FChallengeID;
		params["U2FClientData"] = U2FClientData;
		params["U2FRegistrationData"] = U2FRegistrationData;
		params["U2FVersion"] = U2FVersion;
		if (Description !== null) {
			params["Description"] = Description;
		}
		return await this._requestP("api/v1/admin/account/u2f/submit-challenge-response", params);
	}

	/**
	 * AdminAccountValidateTotp
	 * Validate the TOTP code before turning 2fa(TOTP) on
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} TOTPCode Six-digit code after scanning barcode image
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAccountValidateTotpP(TOTPCode: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TOTPCode"] = TOTPCode;
		return await this._requestP("api/v1/admin/account/validate-totp", params);
	}

	/**
	 * AdminAccountWebauthnRequestRegistrationChallenge
	 * Register a new FIDO2 WebAuthn token
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} SelfAddress External URL of this server, used as WebAuthn ID
	 * @return {Promise<libcomet_WebAuthnRegistrationChallengeResponse>}
	 */
	async AdminAccountWebauthnRequestRegistrationChallengeP(SelfAddress: string): Promise<libcomet_WebAuthnRegistrationChallengeResponse> {
		const params: { [s: string]: string; } = {};
		params["SelfAddress"] = SelfAddress;
		return await this._requestP("api/v1/admin/account/webauthn/request-registration-challenge", params);
	}

	/**
	 * AdminAccountWebauthnSubmitChallengeResponse
	 * Register a new FIDO2 WebAuthn token
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} SelfAddress External URL of this server, used as WebAuthn ID
	 * @param {string} ChallengeID Associated value from AdminAccountWebAuthnRequestRegistrationChallenge API
	 * @param {string} Credential JSON-encoded credential
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAccountWebauthnSubmitChallengeResponseP(SelfAddress: string, ChallengeID: string, Credential: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["SelfAddress"] = SelfAddress;
		params["ChallengeID"] = ChallengeID;
		params["Credential"] = Credential;
		return await this._requestP("api/v1/admin/account/webauthn/submit-challenge-response", params);
	}

	/**
	 * AdminAddUser
	 * Add a new user account
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser New account username
	 * @param {string} TargetPassword New account password
	 * @param {number|null} StoreRecoveryCode If set to 1, store and keep a password recovery code for the generated user (>= 18.3.9)
	 * @param {number|null} RequirePasswordChange If set to 1, require to reset password at the first login for the generated user (>= 20.3.4)
	 * @param {string|null} TargetOrganization If present, create the user account on behalf of another organization. Only allowed for administrator accounts in the top-level organization. (>= 22.3.7)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAddUserP(TargetUser: string, TargetPassword: string, StoreRecoveryCode: number|null = null, RequirePasswordChange: number|null = null, TargetOrganization: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["TargetPassword"] = TargetPassword;
		if (StoreRecoveryCode !== null) {
			params["StoreRecoveryCode"] = ""+StoreRecoveryCode;
		}
		if (RequirePasswordChange !== null) {
			params["RequirePasswordChange"] = ""+RequirePasswordChange;
		}
		if (TargetOrganization !== null) {
			params["TargetOrganization"] = TargetOrganization;
		}
		return await this._requestP("api/v1/admin/add-user", params);
	}

	/**
	 * AdminAddUserFromProfile
	 * Add a new user account (with all information)
	 * This allows you to create a new account and set all its properties at once (e.g. during account replication). Developers creating a signup form may find it simpler to use the AdminAddUser and AdminGetUserProfile / AdminSetUserProfile APIs separately.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser New account username
	 * @param {libcomet_UserProfileConfig} ProfileData New account profile
	 * @param {string|null} TargetOrganization If present, create the user account on behalf of another organization. Only allowed for administrator accounts in the top-level organization. (>= 22.3.7)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAddUserFromProfileP(TargetUser: string, ProfileData: libcomet_UserProfileConfig, TargetOrganization: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["ProfileData"] = JSON.stringify(ProfileData);
		if (TargetOrganization !== null) {
			params["TargetOrganization"] = TargetOrganization;
		}
		return await this._requestP("api/v1/admin/add-user-from-profile", params);
	}

	/**
	 * AdminAdminUserDelete
	 * Delete an administrator
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {string} TargetUser the username of the admin to be deleted
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAdminUserDeleteP(TargetUser: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/admin-user/delete", params);
	}

	/**
	 * AdminAdminUserList
	 * List administrators
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<libcomet_AllowedAdminUser[]>}
	 */
	async AdminAdminUserListP(): Promise<libcomet_AllowedAdminUser[]> {
		return await this._requestP("api/v1/admin/admin-user/list", {});
	}

	/**
	 * AdminAdminUserNew
	 * Add a new administrator
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {string} TargetUser the username for this new admin
	 * @param {string} TargetPassword the password for this new admin user
	 * @param {string|null} TargetOrgID provide the organization ID for this user, it will default to the org of the authenticating user otherwise
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminAdminUserNewP(TargetUser: string, TargetPassword: string, TargetOrgID: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["TargetPassword"] = TargetPassword;
		if (TargetOrgID !== null) {
			params["TargetOrgID"] = TargetOrgID;
		}
		return await this._requestP("api/v1/admin/admin-user/new", params);
	}

	/**
	 * AdminBrandingAvailablePlatforms
	 * List available software download platforms
	 *
	 * This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated software downloads.
	 * This API requires the Software Build Role to be enabled.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: number]: libcomet_AvailableDownload}>}
	 */
	async AdminBrandingAvailablePlatformsP(): Promise<{[k: number]: libcomet_AvailableDownload}> {
		return await this._requestP("api/v1/admin/branding/available-platforms", {});
	}

	/**
	 * AdminBrandingGenerateClientTest
	 * Check if a software download is available
	 *
	 * This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated software downloads.
	 * This API requires the Software Build Role to be enabled.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {number} Platform The selected download platform, from the AdminBrandingAvailablePlatforms API
	 * @param {string|null} SelfAddress The external URL of this server, used to resolve conflicts
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminBrandingGenerateClientTestP(Platform: number, SelfAddress: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Platform"] = ""+Platform;
		if (SelfAddress === null) {
			params["SelfAddress"] = this._server_url;
		} else {
			params["SelfAddress"] = SelfAddress;
		}
		return await this._requestP("api/v1/admin/branding/generate-client/test", params);
	}

	/**
	 * AdminBulletinSubmit
	 * Send an email bulletin to all users
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} Subject Bulletin subject line
	 * @param {string} Content Bulletin message content
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminBulletinSubmitP(Subject: string, Content: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Subject"] = Subject;
		params["Content"] = Content;
		return await this._requestP("api/v1/admin/bulletin/submit", params);
	}

	/**
	 * AdminConstellationLastReport
	 * Get Constellation bucket usage report (cached)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Constellation Role to be enabled.
	 *
	 * @return {Promise<libcomet_ConstellationCheckReport>}
	 */
	async AdminConstellationLastReportP(): Promise<libcomet_ConstellationCheckReport> {
		return await this._requestP("api/v1/admin/constellation/last-report", {});
	}

	/**
	 * AdminConstellationNewReport
	 * Get Constellation bucket usage report (regenerate)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Constellation Role to be enabled.
	 *
	 * @return {Promise<libcomet_ConstellationCheckReport>}
	 */
	async AdminConstellationNewReportP(): Promise<libcomet_ConstellationCheckReport> {
		return await this._requestP("api/v1/admin/constellation/new-report", {});
	}

	/**
	 * AdminConstellationPruneNow
	 * Prune unused buckets
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 * This API requires the Constellation Role to be enabled.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminConstellationPruneNowP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/admin/constellation/prune-now", {});
	}

	/**
	 * AdminConstellationStatus
	 * Get Constellation status
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Constellation Role to be enabled.
	 *
	 * @return {Promise<libcomet_ConstellationStatusAPIResponse>}
	 */
	async AdminConstellationStatusP(): Promise<libcomet_ConstellationStatusAPIResponse> {
		return await this._requestP("api/v1/admin/constellation/status", {});
	}

	/**
	 * AdminCountJobsForCustomSearch
	 * Count jobs (for custom search)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {libcomet_SearchClause} Query (No description available)
	 * @return {Promise<libcomet_CountJobsResponse>}
	 */
	async AdminCountJobsForCustomSearchP(Query: libcomet_SearchClause): Promise<libcomet_CountJobsResponse> {
		const params: { [s: string]: string; } = {};
		params["Query"] = JSON.stringify(Query);
		return await this._requestP("api/v1/admin/count-jobs-for-custom-search", params);
	}

	/**
	 * AdminCreateInstallToken
	 * Create token for silent installation
	 * Currently only supported for Windows & macOS only
	 * Provide the installation token to silently install the client on windows `install.exe /TOKEN=<installtoken>`
	 * Provide the installation token to silently install the client on Mac OS `sudo launchctl setenv BACKUP_APP_TOKEN "installtoken" && sudo /usr/sbin/installer -allowUntrusted -pkg "Comet Backup.pkg" -target /`
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {string} TargetPassword Selected account password
	 * @param {string|null} Server External URL of the authentication server that is different from the current server
	 * @return {Promise<libcomet_InstallTokenResponse>}
	 */
	async AdminCreateInstallTokenP(TargetUser: string, TargetPassword: string, Server: string|null = null): Promise<libcomet_InstallTokenResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["TargetPassword"] = TargetPassword;
		if (Server !== null) {
			params["Server"] = Server;
		}
		return await this._requestP("api/v1/admin/create-install-token", params);
	}

	/**
	 * AdminDeleteUser
	 * Delete user account
	 * This does not remove any storage buckets. Unused storage buckets will be cleaned up by the Constellation Role.
	 * Any stored data can not be decrypted without the user profile. Misuse can cause data loss!
	 * This also allows to uninstall software from active devices under the user account
	 * This also removes all job history for the user account.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {libcomet_UninstallConfig|null} UninstallConfig Uninstall software configuration (>= 20.3.5)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDeleteUserP(TargetUser: string, UninstallConfig: libcomet_UninstallConfig|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		if (UninstallConfig !== null) {
			params["UninstallConfig"] = JSON.stringify(UninstallConfig);
		}
		return await this._requestP("api/v1/admin/delete-user", params);
	}

	/**
	 * AdminDisableUserTotp
	 * Disable user account 2FA(TOTP) authentication
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDisableUserTotpP(TargetUser: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/disable-user-totp", params);
	}

	/**
	 * AdminDispatcherApplyRetentionRules
	 * Instruct a live connected device to apply retention rules now
	 * This command is understood by Comet Backup 17.6.9 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherApplyRetentionRulesP(TargetID: string, Destination: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		return await this._requestP("api/v1/admin/dispatcher/apply-retention-rules", params);
	}

	/**
	 * AdminDispatcherDeepverifyStorageVault
	 * Instruct a live connected device to deeply verify Storage Vault content
	 * This command is understood by Comet Backup 18.8.2 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherDeepverifyStorageVaultP(TargetID: string, Destination: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		return await this._requestP("api/v1/admin/dispatcher/deepverify-storage-vault", params);
	}

	/**
	 * AdminDispatcherDeleteSnapshot
	 * Instruct a live connected device to delete a stored snapshot
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} DestinationID The Storage Vault GUID
	 * @param {string} SnapshotID The backup job snapshot ID to delete
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherDeleteSnapshotP(TargetID: string, DestinationID: string, SnapshotID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["DestinationID"] = DestinationID;
		params["SnapshotID"] = SnapshotID;
		return await this._requestP("api/v1/admin/dispatcher/delete-snapshot", params);
	}

	/**
	 * AdminDispatcherDeleteSnapshots
	 * Instruct a live connected device to delete multiple stored snapshots
	 * The target device must be running Comet 20.9.10 or later.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} DestinationID The Storage Vault GUID
	 * @param {string[]} SnapshotIDs The backup job snapshot IDs to delete
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherDeleteSnapshotsP(TargetID: string, DestinationID: string, SnapshotIDs: string[]): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["DestinationID"] = DestinationID;
		params["SnapshotIDs"] = JSON.stringify(SnapshotIDs);
		return await this._requestP("api/v1/admin/dispatcher/delete-snapshots", params);
	}

	/**
	 * AdminDispatcherDropConnection
	 * Disconnect a live connected device
	 * The device will almost certainly attempt to reconnect.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherDropConnectionP(TargetID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/drop-connection", params);
	}

	/**
	 * AdminDispatcherEmailPreview
	 * Request HTML content of an email
	 * The remote device must have given consent for an MSP to browse their mail
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Snapshot where the email belongs to
	 * @param {string} Destination The Storage Vault ID
	 * @param {string} Path of the email to view
	 * @return {Promise<libcomet_EmailReportGeneratedPreview>}
	 */
	async AdminDispatcherEmailPreviewP(TargetID: string, Snapshot: string, Destination: string, Path: string): Promise<libcomet_EmailReportGeneratedPreview> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Snapshot"] = Snapshot;
		params["Destination"] = Destination;
		params["Path"] = Path;
		return await this._requestP("api/v1/admin/dispatcher/email-preview", params);
	}

	/**
	 * AdminDispatcherGetDefaultLoginUrl
	 * Get the default login URL for a tenant
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {string} OrganizationID Target organization
	 * @return {Promise<libcomet_OrganizationLoginURLResponse>}
	 */
	async AdminDispatcherGetDefaultLoginUrlP(OrganizationID: string): Promise<libcomet_OrganizationLoginURLResponse> {
		const params: { [s: string]: string; } = {};
		params["OrganizationID"] = OrganizationID;
		return await this._requestP("api/v1/admin/dispatcher/get-default-login-url", params);
	}

	/**
	 * AdminDispatcherImportApply
	 * Instruct a live connected device to import settings from an installed product
	 * This command is understood by Comet Backup 17.12.0 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} ImportSourceID The selected import source, as found by the AdminDispatcherRequestImportSources API
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherImportApplyP(TargetID: string, ImportSourceID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["ImportSourceID"] = ImportSourceID;
		return await this._requestP("api/v1/admin/dispatcher/import-apply", params);
	}

	/**
	 * AdminDispatcherKillProcess
	 * Instruct a live connected device to disconnect
	 * The device will terminate its live-connection process and will not reconnect.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherKillProcessP(TargetID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/kill-process", params);
	}

	/**
	 * AdminDispatcherListActive
	 * List live connected devices
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string|null} UserNameFilter User name filter string
	 * @return {Promise<{[k: string]: libcomet_LiveUserConnection}>}
	 */
	async AdminDispatcherListActiveP(UserNameFilter: string|null = null): Promise<{[k: string]: libcomet_LiveUserConnection}> {
		const params: { [s: string]: string; } = {};
		if (UserNameFilter !== null) {
			params["UserNameFilter"] = UserNameFilter;
		}
		return await this._requestP("api/v1/admin/dispatcher/list-active", params);
	}

	/**
	 * AdminDispatcherOffice365ListVirtualAccounts
	 * Request a list of Office365 Resources (groups, sites, teams groups and users)
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_Office365Credential} Credentials The Office365 account credential
	 * @return {Promise<libcomet_BrowseOffice365ListVirtualAccountsResponse>}
	 */
	async AdminDispatcherOffice365ListVirtualAccountsP(TargetID: string, Credentials: libcomet_Office365Credential): Promise<libcomet_BrowseOffice365ListVirtualAccountsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/admin/dispatcher/office365-list-virtual-accounts", params);
	}

	/**
	 * AdminDispatcherPingDestination
	 * Test the connection to the storage bucket
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_DestinationLocation} ExtraData The destination location settings
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherPingDestinationP(TargetID: string, ExtraData: libcomet_DestinationLocation): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["ExtraData"] = JSON.stringify(ExtraData);
		return await this._requestP("api/v1/admin/dispatcher/ping-destination", params);
	}

	/**
	 * AdminDispatcherRefetchProfile
	 * Instruct a live connected device to refresh their profile
	 * This command is understood by Comet Backup 17.12.0 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherRefetchProfileP(TargetID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/refetch-profile", params);
	}

	/**
	 * AdminDispatcherRegisterOfficeApplicationBegin
	 * Begin the process of registering a new Azure AD application that can access Office 365 for backup
	 * After calling this API, you should supply the login details to the end-user, and then begin polling the AdminDispatcherRegisterOfficeApplicationCheck with the supplied "Continuation" parameter to check on the registration process.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} EmailAddress The email address of the Azure AD administrator
	 * @return {Promise<libcomet_RegisterOfficeApplicationBeginResponse>}
	 */
	async AdminDispatcherRegisterOfficeApplicationBeginP(TargetID: string, EmailAddress: string): Promise<libcomet_RegisterOfficeApplicationBeginResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["EmailAddress"] = EmailAddress;
		return await this._requestP("api/v1/admin/dispatcher/register-office-application/begin", params);
	}

	/**
	 * AdminDispatcherRegisterOfficeApplicationCheck
	 * Check the process of registering a new Azure AD application that can access Office 365 for backup
	 * You should begin the process by calling AdminDispatcherRegisterOfficeApplicationBegin and asking the end-user to complete the Azure authentication steps.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Continuation The ID returned from the AdminDispatcherRegisterOfficeApplicationBegin endpoint
	 * @return {Promise<libcomet_RegisterOfficeApplicationCheckResponse>}
	 */
	async AdminDispatcherRegisterOfficeApplicationCheckP(TargetID: string, Continuation: string): Promise<libcomet_RegisterOfficeApplicationCheckResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Continuation"] = Continuation;
		return await this._requestP("api/v1/admin/dispatcher/register-office-application/check", params);
	}

	/**
	 * AdminDispatcherReindexStorageVault
	 * Instruct a live connected device to rebuild Storage Vault indexes now
	 * This command is understood by Comet Backup 18.6.9 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherReindexStorageVaultP(TargetID: string, Destination: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		return await this._requestP("api/v1/admin/dispatcher/reindex-storage-vault", params);
	}

	/**
	 * AdminDispatcherRequestBrowseDiskDrives
	 * Request a list of physical disk drive information from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseDiskDrivesResponse>}
	 */
	async AdminDispatcherRequestBrowseDiskDrivesP(TargetID: string): Promise<libcomet_BrowseDiskDrivesResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/request-browse-disk-drives", params);
	}

	/**
	 * AdminDispatcherRequestBrowseExchangeEdb
	 * Request a list of Exchange EDB databases from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseEDBResponse>}
	 */
	async AdminDispatcherRequestBrowseExchangeEdbP(TargetID: string): Promise<libcomet_BrowseEDBResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/request-browse-exchange-edb", params);
	}

	/**
	 * AdminDispatcherRequestBrowseHyperv
	 * Request a list of Hyper-V virtual machines from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseHVResponse>}
	 */
	async AdminDispatcherRequestBrowseHypervP(TargetID: string): Promise<libcomet_BrowseHVResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/request-browse-hyperv", params);
	}

	/**
	 * AdminDispatcherRequestBrowseMongodb
	 * Request a list of tables in MongoDB database
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_MongoDBConnection} Credentials The Mongo database authentication settings
	 * @return {Promise<libcomet_BrowseSQLServerResponse>}
	 */
	async AdminDispatcherRequestBrowseMongodbP(TargetID: string, Credentials: libcomet_MongoDBConnection): Promise<libcomet_BrowseSQLServerResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/admin/dispatcher/request-browse-mongodb", params);
	}

	/**
	 * AdminDispatcherRequestBrowseMssql
	 * Request a list of tables in MSSQL database
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_MSSQLConnection} Credentials The MSSQL database authentication settings
	 * @return {Promise<libcomet_BrowseSQLServerResponse>}
	 */
	async AdminDispatcherRequestBrowseMssqlP(TargetID: string, Credentials: libcomet_MSSQLConnection): Promise<libcomet_BrowseSQLServerResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/admin/dispatcher/request-browse-mssql", params);
	}

	/**
	 * AdminDispatcherRequestBrowseMysql
	 * Request a list of tables in MySQL database
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_MySQLConnection} Credentials The MySQL database authentication settings
	 * @return {Promise<libcomet_BrowseSQLServerResponse>}
	 */
	async AdminDispatcherRequestBrowseMysqlP(TargetID: string, Credentials: libcomet_MySQLConnection): Promise<libcomet_BrowseSQLServerResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/admin/dispatcher/request-browse-mysql", params);
	}

	/**
	 * AdminDispatcherRequestBrowseVssAaw
	 * Request a list of installed VSS Writers (Application-Aware Writers) from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseVSSResponse>}
	 */
	async AdminDispatcherRequestBrowseVssAawP(TargetID: string): Promise<libcomet_BrowseVSSResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/request-browse-vss-aaw", params);
	}

	/**
	 * AdminDispatcherRequestFilesystemObjects
	 * Request a list of filesystem objects from a live connected device
	 * The device must have granted the administrator permission to view its filenames.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string|null} Path Browse objects inside this path. If empty or not present, returns the top-level device paths
	 * @return {Promise<libcomet_DispatcherStoredObjectsResponse>}
	 */
	async AdminDispatcherRequestFilesystemObjectsP(TargetID: string, Path: string|null = null): Promise<libcomet_DispatcherStoredObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		if (Path !== null) {
			params["Path"] = Path;
		}
		return await this._requestP("api/v1/admin/dispatcher/request-filesystem-objects", params);
	}

	/**
	 * AdminDispatcherRequestImportSources
	 * Request a list of import sources from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_DispatcherAdminSourcesResponse>}
	 */
	async AdminDispatcherRequestImportSourcesP(TargetID: string): Promise<libcomet_DispatcherAdminSourcesResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/admin/dispatcher/request-import-sources", params);
	}

	/**
	 * AdminDispatcherRequestOffice365Accounts
	 * Request a list of Office365 mailbox accounts
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_Office365Credential} Credentials The Office365 account credential
	 * @return {Promise<libcomet_BrowseOffice365ObjectsResponse>}
	 */
	async AdminDispatcherRequestOffice365AccountsP(TargetID: string, Credentials: libcomet_Office365Credential): Promise<libcomet_BrowseOffice365ObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/admin/dispatcher/request-office365-accounts", params);
	}

	/**
	 * AdminDispatcherRequestOffice365Sites
	 * Request a list of Office365 sites
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_Office365Credential} Credentials The Office365 account credential
	 * @return {Promise<libcomet_BrowseOffice365ObjectsResponse>}
	 */
	async AdminDispatcherRequestOffice365SitesP(TargetID: string, Credentials: libcomet_Office365Credential): Promise<libcomet_BrowseOffice365ObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/admin/dispatcher/request-office365-sites", params);
	}

	/**
	 * AdminDispatcherRequestStoredObjects
	 * Request a list of stored objects inside an existing backup job
	 * The remote device must have given consent for an MSP to browse their files.
	 * To service this request, the remote device must connect to the Storage Vault and load index data. There may be a small delay. If the remote device is running Comet 20.12.0 or later, the necessary index data is cached when this API is first called, for 15 minutes after the last repeated call. This can improve performance for interactively browsing an entire tree of stored objects.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault ID
	 * @param {string} SnapshotID The selected backup job snapshot
	 * @param {string|null} TreeID Browse objects inside subdirectory of backup snapshot. If it is for VMDK single file restore, it should be the disk image's subtree ID.
	 * @param {libcomet_VMDKSnapshotViewOptions|null} Options Request a list of stored objects in vmdk file
	 * @return {Promise<libcomet_DispatcherStoredObjectsResponse>}
	 */
	async AdminDispatcherRequestStoredObjectsP(TargetID: string, Destination: string, SnapshotID: string, TreeID: string|null = null, Options: libcomet_VMDKSnapshotViewOptions|null = null): Promise<libcomet_DispatcherStoredObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		params["SnapshotID"] = SnapshotID;
		if (TreeID !== null) {
			params["TreeID"] = TreeID;
		}
		if (Options !== null) {
			params["Options"] = JSON.stringify(Options);
		}
		return await this._requestP("api/v1/admin/dispatcher/request-stored-objects", params);
	}

	/**
	 * AdminDispatcherRequestVaultSnapshots
	 * Request a list of Storage Vault snapshots from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault ID
	 * @return {Promise<libcomet_DispatcherVaultSnapshotsResponse>}
	 */
	async AdminDispatcherRequestVaultSnapshotsP(TargetID: string, Destination: string): Promise<libcomet_DispatcherVaultSnapshotsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		return await this._requestP("api/v1/admin/dispatcher/request-vault-snapshots", params);
	}

	/**
	 * AdminDispatcherRequestWindiskSnapshot
	 * Request a Disk Image snapshot with the windiskbrowse-style from a live connected device
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault ID
	 * @param {string} SnapshotID The Snapshot ID
	 * @return {Promise<libcomet_DispatcherWindiskSnapshotResponse>}
	 */
	async AdminDispatcherRequestWindiskSnapshotP(TargetID: string, Destination: string, SnapshotID: string): Promise<libcomet_DispatcherWindiskSnapshotResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		params["SnapshotID"] = SnapshotID;
		return await this._requestP("api/v1/admin/dispatcher/request-windisk-snapshot", params);
	}

	/**
	 * AdminDispatcherRunBackup
	 * Instruct a live connected device to run a scheduled backup
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} BackupRule The schedule GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherRunBackupP(TargetID: string, BackupRule: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["BackupRule"] = BackupRule;
		return await this._requestP("api/v1/admin/dispatcher/run-backup", params);
	}

	/**
	 * AdminDispatcherRunBackupCustom
	 * Instruct a live connected device to run a backup
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Source The Protected Item GUID
	 * @param {string} Destination The Storage Vault GUID
	 * @param {libcomet_BackupJobAdvancedOptions|null} Options Extra job parameters (>= 19.3.6)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherRunBackupCustomP(TargetID: string, Source: string, Destination: string, Options: libcomet_BackupJobAdvancedOptions|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Source"] = Source;
		params["Destination"] = Destination;
		if (Options !== null) {
			params["Options"] = JSON.stringify(Options);
		}
		return await this._requestP("api/v1/admin/dispatcher/run-backup-custom", params);
	}

	/**
	 * AdminDispatcherRunRestore
	 * Instruct a live connected device to perform a local restore
	 * This command is understood by Comet Backup 17.9.3 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Path The local path to restore to
	 * @param {string} Source The Protected Item ID
	 * @param {string} Destination The Storage Vault ID
	 * @param {string|null} Snapshot If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the selected Protected Item + Storage Vault pair
	 * @param {string[]|null} Paths If present, restore these paths only. Otherwise, restore all data (>= 19.3.0)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherRunRestoreP(TargetID: string, Path: string, Source: string, Destination: string, Snapshot: string|null = null, Paths: string[]|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Path"] = Path;
		params["Source"] = Source;
		params["Destination"] = Destination;
		if (Snapshot !== null) {
			params["Snapshot"] = Snapshot;
		}
		if (Paths !== null) {
			params["Paths"] = JSON.stringify(Paths);
		}
		return await this._requestP("api/v1/admin/dispatcher/run-restore", params);
	}

	/**
	 * AdminDispatcherRunRestoreCustom
	 * Instruct a live connected device to perform a local restore
	 * This command is understood by Comet Backup 18.6.0 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Source The Protected Item ID
	 * @param {string} Destination The Storage Vault ID
	 * @param {libcomet_RestoreJobAdvancedOptions} Options Restore targets
	 * @param {string|null} Snapshot If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the selected Protected Item + Storage Vault pair
	 * @param {string[]|null} Paths If present, restore these paths only. Otherwise, restore all data
	 * @param {number|null} KnownFileCount The number of files to restore, if known. Supplying this means we don't need to walk the entire tree just to find the file count and will speed up the restoration process.
	 * @param {number|null} KnownByteCount The total size in bytes of files to restore, if known. Supplying this means we don't need to walk the entire tree just to find the total file size and will speed up the restoration process.
	 * @param {number|null} KnownDirCount The number of directories to restore, if known. Supplying this means we don't need to walk the entire tree just to find the number of directories and will speed up the restoration process.
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherRunRestoreCustomP(TargetID: string, Source: string, Destination: string, Options: libcomet_RestoreJobAdvancedOptions, Snapshot: string|null = null, Paths: string[]|null = null, KnownFileCount: number|null = null, KnownByteCount: number|null = null, KnownDirCount: number|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Source"] = Source;
		params["Destination"] = Destination;
		params["Options"] = JSON.stringify(Options);
		if (Snapshot !== null) {
			params["Snapshot"] = Snapshot;
		}
		if (Paths !== null) {
			params["Paths"] = JSON.stringify(Paths);
		}
		if (KnownFileCount !== null) {
			params["KnownFileCount"] = ""+KnownFileCount;
		}
		if (KnownByteCount !== null) {
			params["KnownByteCount"] = ""+KnownByteCount;
		}
		if (KnownDirCount !== null) {
			params["KnownDirCount"] = ""+KnownDirCount;
		}
		return await this._requestP("api/v1/admin/dispatcher/run-restore-custom", params);
	}

	/**
	 * AdminDispatcherSearchSnapshots
	 * Search storage vault snapshots
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} DestinationID The Storage Vault GUID
	 * @param {string[]} SnapshotIDs Snapshots to search
	 * @param {libcomet_SearchClause} Filter The search filter
	 * @return {Promise<libcomet_SearchSnapshotsResponse>}
	 */
	async AdminDispatcherSearchSnapshotsP(TargetID: string, DestinationID: string, SnapshotIDs: string[], Filter: libcomet_SearchClause): Promise<libcomet_SearchSnapshotsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["DestinationID"] = DestinationID;
		params["SnapshotIDs"] = JSON.stringify(SnapshotIDs);
		params["Filter"] = JSON.stringify(Filter);
		return await this._requestP("api/v1/admin/dispatcher/search-snapshots", params);
	}

	/**
	 * AdminDispatcherUninstallSoftware
	 * Instruct a live connected device to self-uninstall the software
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {boolean} RemoveConfigFile Determine if the config.dat file will be deleted at the same time
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherUninstallSoftwareP(TargetID: string, RemoveConfigFile: boolean): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["RemoveConfigFile"] = (RemoveConfigFile ? "1" : "0");
		return await this._requestP("api/v1/admin/dispatcher/uninstall-software", params);
	}

	/**
	 * AdminDispatcherUnlock
	 * Instruct a live connected device to remove lock files from a Storage Vault
	 * Misuse can cause data loss!
	 * This command is understood by Comet Backup 17.9.4 and newer.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherUnlockP(TargetID: string, Destination: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		return await this._requestP("api/v1/admin/dispatcher/unlock", params);
	}

	/**
	 * AdminDispatcherUpdateLoginUrl
	 * Instruct a live connected device to update its login server URL
	 * The device will attempt to connect to the new Auth Role Comet Server using its current username and password. If the test connection succeeds, the device migrates its saved connection settings and live connections to the new server. If the device is not registered on the new URL, or if the credentials are incorrect, the device remains on the current Auth Role server.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} NewURL The new external URL of this server
	 * @param {boolean|null} Force No checks will be done using previous URL
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherUpdateLoginUrlP(TargetID: string, NewURL: string, Force: boolean|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["NewURL"] = NewURL;
		if (Force !== null) {
			params["Force"] = (Force ? "1" : "0");
		}
		return await this._requestP("api/v1/admin/dispatcher/update-login-url", params);
	}

	/**
	 * AdminDispatcherUpdateSoftware
	 * Instruct a live connected device to download a software update
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 * This API requires the Software Build Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string|null} SelfAddress The external URL of this server, used to resolve conflicts (>= 19.3.11)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminDispatcherUpdateSoftwareP(TargetID: string, SelfAddress: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		if (SelfAddress === null) {
			params["SelfAddress"] = this._server_url;
		} else {
			params["SelfAddress"] = SelfAddress;
		}
		return await this._requestP("api/v1/admin/dispatcher/update-software", params);
	}

	/**
	 * AdminExternalAuthSourcesDelete
	 * Delete an external admin authentication source
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {string} SourceID (No description available)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminExternalAuthSourcesDeleteP(SourceID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["SourceID"] = SourceID;
		return await this._requestP("api/v1/admin/external-auth-sources/delete", params);
	}

	/**
	 * AdminExternalAuthSourcesGet
	 * Get a map of all external admin authentication sources
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<{[k: string]: libcomet_ExternalAuthenticationSource}>}
	 */
	async AdminExternalAuthSourcesGetP(): Promise<{[k: string]: libcomet_ExternalAuthenticationSource}> {
		return await this._requestP("api/v1/admin/external-auth-sources/get", {});
	}

	/**
	 * AdminExternalAuthSourcesNew
	 * Create an external admin authentication source
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {libcomet_ExternalAuthenticationSource} Source (No description available)
	 * @param {string|null} SourceID (No description available)
	 * @return {Promise<libcomet_ExternalAuthenticationSourceResponse>}
	 */
	async AdminExternalAuthSourcesNewP(Source: libcomet_ExternalAuthenticationSource, SourceID: string|null = null): Promise<libcomet_ExternalAuthenticationSourceResponse> {
		const params: { [s: string]: string; } = {};
		params["Source"] = JSON.stringify(Source);
		if (SourceID !== null) {
			params["SourceID"] = SourceID;
		}
		return await this._requestP("api/v1/admin/external-auth-sources/new", params);
	}

	/**
	 * AdminExternalAuthSourcesSet
	 * Updates the current tenant's external admin authentication sources. This will set all
	 * sources for the tenant; none will be preserved.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {{[k: string]: libcomet_ExternalAuthenticationSource}} Sources (No description available)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminExternalAuthSourcesSetP(Sources: {[k: string]: libcomet_ExternalAuthenticationSource}): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Sources"] = JSON.stringify(Sources);
		return await this._requestP("api/v1/admin/external-auth-sources/set", params);
	}

	/**
	 * AdminGetJobLog
	 * Get the report log entries for a single job, in plaintext format
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Selected job ID
	 * @return {Promise<string>}
	 */
	async AdminGetJobLogP(JobID: string): Promise<string> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		return await this._requestP("api/v1/admin/get-job-log", params);
	}

	/**
	 * AdminGetJobLogEntries
	 * Get the report log entries for a single job
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Selected job ID
	 * @param {string|null} MinSeverity Return only job log entries with equal or higher severity
	 * @param {string|null} MessageContains Return only job log entries that contain exact string
	 * @return {Promise<libcomet_JobEntry[]>}
	 */
	async AdminGetJobLogEntriesP(JobID: string, MinSeverity: string|null = null, MessageContains: string|null = null): Promise<libcomet_JobEntry[]> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		if (MinSeverity !== null) {
			params["MinSeverity"] = MinSeverity;
		}
		if (MessageContains !== null) {
			params["MessageContains"] = MessageContains;
		}
		return await this._requestP("api/v1/admin/get-job-log-entries", params);
	}

	/**
	 * AdminGetJobProperties
	 * Get properties of a single job
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Selected job ID
	 * @return {Promise<libcomet_BackupJobDetail>}
	 */
	async AdminGetJobPropertiesP(JobID: string): Promise<libcomet_BackupJobDetail> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		return await this._requestP("api/v1/admin/get-job-properties", params);
	}

	/**
	 * AdminGetJobsAll
	 * Get jobs (All)
	 * The jobs are returned in an unspecified order.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async AdminGetJobsAllP(): Promise<libcomet_BackupJobDetail[]> {
		return await this._requestP("api/v1/admin/get-jobs-all", {});
	}

	/**
	 * AdminGetJobsForCustomSearch
	 * Get jobs (for custom search)
	 * The jobs are returned in an unspecified order.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {libcomet_SearchClause} Query (No description available)
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async AdminGetJobsForCustomSearchP(Query: libcomet_SearchClause): Promise<libcomet_BackupJobDetail[]> {
		const params: { [s: string]: string; } = {};
		params["Query"] = JSON.stringify(Query);
		return await this._requestP("api/v1/admin/get-jobs-for-custom-search", params);
	}

	/**
	 * AdminGetJobsForDateRange
	 * Get jobs (for date range)
	 * The jobs are returned in an unspecified order.
	 *
	 * If the `Start` parameter is later than `End`, they will be swapped.
	 *
	 * This API will return all jobs that either started or ended within the supplied range.
	 *
	 * Incomplete jobs have an end time of `0`. You can use this API to find only incomplete jobs by setting both `Start` and `End` to `0`.
	 *
	 * Prior to Comet Server 22.6.0, additional Incomplete jobs may have been returned if you specified non-zero arguments for both `Start` and `End`.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {number} Start Timestamp (Unix)
	 * @param {number} End Timestamp (Unix)
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async AdminGetJobsForDateRangeP(Start: number, End: number): Promise<libcomet_BackupJobDetail[]> {
		const params: { [s: string]: string; } = {};
		params["Start"] = ""+Start;
		params["End"] = ""+End;
		return await this._requestP("api/v1/admin/get-jobs-for-date-range", params);
	}

	/**
	 * AdminGetJobsForUser
	 * Get jobs (for user)
	 * The jobs are returned in an unspecified order.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected username
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async AdminGetJobsForUserP(TargetUser: string): Promise<libcomet_BackupJobDetail[]> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/get-jobs-for-user", params);
	}

	/**
	 * AdminGetJobsRecent
	 * Get jobs (Recent and incomplete)
	 * The jobs are returned in an unspecified order.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async AdminGetJobsRecentP(): Promise<libcomet_BackupJobDetail[]> {
		return await this._requestP("api/v1/admin/get-jobs-recent", {});
	}

	/**
	 * AdminGetUserProfile
	 * Get user account profile
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @return {Promise<libcomet_UserProfileConfig>}
	 */
	async AdminGetUserProfileP(TargetUser: string): Promise<libcomet_UserProfileConfig> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/get-user-profile", params);
	}

	/**
	 * AdminGetUserProfileAndHash
	 * Get user account profile (atomic)
	 * The resulting hash parameter can be passed to the corresponding update API, to atomically ensure that no changes occur between get/set operations.
	 * The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve current hash values.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @return {Promise<libcomet_GetProfileAndHashResponseMessage>}
	 */
	async AdminGetUserProfileAndHashP(TargetUser: string): Promise<libcomet_GetProfileAndHashResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/get-user-profile-and-hash", params);
	}

	/**
	 * AdminGetUserProfileHash
	 * Get user account profile (hash)
	 * The profile hash can be used to determine if a user account profile has changed.
	 * The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve current hash values.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @return {Promise<libcomet_GetProfileHashResponseMessage>}
	 */
	async AdminGetUserProfileHashP(TargetUser: string): Promise<libcomet_GetProfileHashResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		return await this._requestP("api/v1/admin/get-user-profile-hash", params);
	}

	/**
	 * AdminInstallationDispatchDropConnection
	 * Instruct a live connected device to disconnect
	 * The device will terminate its live-connection process and will not reconnect.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} DeviceID The live connection Device GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminInstallationDispatchDropConnectionP(DeviceID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["DeviceID"] = DeviceID;
		return await this._requestP("api/v1/admin/installation/dispatch/drop-connection", params);
	}

	/**
	 * AdminInstallationDispatchRegisterDevice
	 * Instruct an unregistered device to authenticate with a given user
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} DeviceID The live connection Device GUID
	 * @param {string} TargetUser Selected account username
	 * @param {string} TargetPassword Selected account password
	 * @param {string|null} TargetTOTPCode Selected account TOTP code
	 * @return {Promise<string>}
	 */
	async AdminInstallationDispatchRegisterDeviceP(DeviceID: string, TargetUser: string, TargetPassword: string, TargetTOTPCode: string|null = null): Promise<string> {
		const params: { [s: string]: string; } = {};
		params["DeviceID"] = DeviceID;
		params["TargetUser"] = TargetUser;
		params["TargetPassword"] = TargetPassword;
		if (TargetTOTPCode !== null) {
			params["TargetTOTPCode"] = TargetTOTPCode;
		}
		return await this._requestP("api/v1/admin/installation/dispatch/register-device", params);
	}

	/**
	 * AdminInstallationListActive
	 * List live connected devices in lobby mode
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: libcomet_RegistrationLobbyConnection}>}
	 */
	async AdminInstallationListActiveP(): Promise<{[k: string]: libcomet_RegistrationLobbyConnection}> {
		return await this._requestP("api/v1/admin/installation/list-active", {});
	}

	/**
	 * AdminJobAbandon
	 * Mark a running job as abandoned
	 * This will change the status of a running job to abandoned.
	 * This is intended to be used on jobs which are definitely no longer running but are stuck in the running state; it will not attempt to cancel the job. If the job is detected to still be running after being marked as abandoned, it will be revived.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Username
	 * @param {string} JobID Job ID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminJobAbandonP(TargetUser: string, JobID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["JobID"] = JobID;
		return await this._requestP("api/v1/admin/job/abandon", params);
	}

	/**
	 * AdminJobCancel
	 * Cancel a running job
	 * A request is sent to the live-connected device, asking it to cancel the operation. This may fail if there is no live-connection.
	 * Only jobs from Comet 18.3.5 or newer can be cancelled. A job can only be cancelled if it has a non-empty CancellationID field in its properties.
	 * If the device is running Comet 21.9.5 or later, this API will wait up to ten seconds for a confirmation from the client.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Username
	 * @param {string} JobID Job ID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminJobCancelP(TargetUser: string, JobID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["JobID"] = JobID;
		return await this._requestP("api/v1/admin/job/cancel", params);
	}

	/**
	 * AdminListUsers
	 * List all user accounts
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<string[]>}
	 */
	async AdminListUsersP(): Promise<string[]> {
		return await this._requestP("api/v1/admin/list-users", {});
	}

	/**
	 * AdminListUsersFull
	 * List all user account profiles
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: libcomet_UserProfileConfig}>}
	 */
	async AdminListUsersFullP(): Promise<{[k: string]: libcomet_UserProfileConfig}> {
		return await this._requestP("api/v1/admin/list-users-full", {});
	}

	/**
	 * AdminMetaBrandingConfigGet
	 * Get Branding configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<libcomet_ServerConfigOptionsBrandingFragment>}
	 */
	async AdminMetaBrandingConfigGetP(): Promise<libcomet_ServerConfigOptionsBrandingFragment> {
		return await this._requestP("api/v1/admin/meta/branding-config/get", {});
	}

	/**
	 * AdminMetaBrandingConfigSet
	 * Set Branding configuration
	 * Note that file resources must be provided using a resource URI, i.e `"resource://05ba0b90ee66bda433169581188aba8d29faa938f9464cccd651a02fdf2e5b57"`. See AdminMetaResourceNew for the API documentation to create new file resources.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_BrandingOptions} BrandingConfig Updated configuration content
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaBrandingConfigSetP(BrandingConfig: libcomet_BrandingOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["BrandingConfig"] = JSON.stringify(BrandingConfig);
		return await this._requestP("api/v1/admin/meta/branding-config/set", params);
	}

	/**
	 * AdminMetaBuildConfigGet
	 * Get Software Build Role configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<libcomet_ServerConfigOptionsSoftwareBuildRoleFragment>}
	 */
	async AdminMetaBuildConfigGetP(): Promise<libcomet_ServerConfigOptionsSoftwareBuildRoleFragment> {
		return await this._requestP("api/v1/admin/meta/build-config/get", {});
	}

	/**
	 * AdminMetaBuildConfigSet
	 * Set Build Role configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_SoftwareBuildRoleOptions} SoftwareBuildRoleConfig Updated configuration content
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaBuildConfigSetP(SoftwareBuildRoleConfig: libcomet_SoftwareBuildRoleOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["SoftwareBuildRoleConfig"] = JSON.stringify(SoftwareBuildRoleConfig);
		return await this._requestP("api/v1/admin/meta/build-config/set", params);
	}

	/**
	 * AdminMetaConstellationConfigGet
	 * Get Constellation configuration for the current organization
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Constellation Role to be enabled.
	 *
	 * @return {Promise<libcomet_ConstellationRoleOptions>}
	 */
	async AdminMetaConstellationConfigGetP(): Promise<libcomet_ConstellationRoleOptions> {
		return await this._requestP("api/v1/admin/meta/constellation/config/get", {});
	}

	/**
	 * AdminMetaConstellationConfigSet
	 * Set Constellation configuration for the current organization
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Constellation Role to be enabled.
	 *
	 * @param {libcomet_ConstellationRoleOptions} ConstellationRoleOptions Constellation role options to set
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaConstellationConfigSetP(ConstellationRoleOptions: libcomet_ConstellationRoleOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["ConstellationRoleOptions"] = JSON.stringify(ConstellationRoleOptions);
		return await this._requestP("api/v1/admin/meta/constellation/config/set", params);
	}

	/**
	 * AdminMetaEmailOptionsGet
	 * Get the email options
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<libcomet_EmailOptions>}
	 */
	async AdminMetaEmailOptionsGetP(): Promise<libcomet_EmailOptions> {
		return await this._requestP("api/v1/admin/meta/email-options/get", {});
	}

	/**
	 * AdminMetaEmailOptionsSet
	 * Set the email options
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_EmailOptions} EmailOptions The replacement email reporting options.
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaEmailOptionsSetP(EmailOptions: libcomet_EmailOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["EmailOptions"] = JSON.stringify(EmailOptions);
		return await this._requestP("api/v1/admin/meta/email-options/set", params);
	}

	/**
	 * AdminMetaListAvailableLogDays
	 * Get log files
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<number[]>}
	 */
	async AdminMetaListAvailableLogDaysP(): Promise<number[]> {
		return await this._requestP("api/v1/admin/meta/list-available-log-days", {});
	}

	/**
	 * AdminMetaPsaConfigListGet
	 * Get the server PSA configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<libcomet_PSAConfig[]>}
	 */
	async AdminMetaPsaConfigListGetP(): Promise<libcomet_PSAConfig[]> {
		return await this._requestP("api/v1/admin/meta/psa-config-list/get", {});
	}

	/**
	 * AdminMetaPsaConfigListSet
	 * Update the server PSA configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {libcomet_PSAConfig[]} PSAConfigList The replacement PSA configuration list
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaPsaConfigListSetP(PSAConfigList: libcomet_PSAConfig[]): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["PSAConfigList"] = JSON.stringify(PSAConfigList);
		return await this._requestP("api/v1/admin/meta/psa-config-list/set", params);
	}

	/**
	 * AdminMetaPsaConfigListSyncNow
	 * Synchronize all PSA services now
	 * This API applies to the current Organization's PSAConfig's only.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaPsaConfigListSyncNowP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/admin/meta/psa-config-list/sync-now", {});
	}

	/**
	 * AdminMetaReadLogs
	 * Get log file content
	 * On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in 18.3.2.
	 * This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed line-endings.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {number} Log A log day, selected from the options returned by the Get Log Files API
	 * @return {Promise<string>}
	 */
	async AdminMetaReadLogsP(Log: number): Promise<string> {
		const params: { [s: string]: string; } = {};
		params["Log"] = ""+Log;
		return await this._requestP("api/v1/admin/meta/read-logs", params);
	}

	/**
	 * AdminMetaRemoteStorageVaultGet
	 * Get Requesting Remote Storage Vault Config
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<libcomet_RemoteStorageOption[]>}
	 */
	async AdminMetaRemoteStorageVaultGetP(): Promise<libcomet_RemoteStorageOption[]> {
		return await this._requestP("api/v1/admin/meta/remote-storage-vault/get", {});
	}

	/**
	 * AdminMetaRemoteStorageVaultSet
	 * Set Storage template vault options
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_RemoteStorageOption[]} RemoteStorageOptions Updated configuration content
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaRemoteStorageVaultSetP(RemoteStorageOptions: libcomet_RemoteStorageOption[]): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["RemoteStorageOptions"] = JSON.stringify(RemoteStorageOptions);
		return await this._requestP("api/v1/admin/meta/remote-storage-vault/set", params);
	}

	/**
	 * AdminMetaRemoteStorageVaultTest
	 * Test the connection to the storage template
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_RemoteStorageOption} TemplateOptions Storage Template Vault Options
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaRemoteStorageVaultTestP(TemplateOptions: libcomet_RemoteStorageOption): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TemplateOptions"] = JSON.stringify(TemplateOptions);
		return await this._requestP("api/v1/admin/meta/remote-storage-vault/test", params);
	}

	/**
	 * AdminMetaRestartService
	 * Restart server
	 * The Comet Server process will exit. The service manager should restart the server automatically.
	 *
	 * Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it returns a successful response before shutting down.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaRestartServiceP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/admin/meta/restart-service", {});
	}

	/**
	 * AdminMetaSendTestEmail
	 * Send a test email message
	 * This allows the Comet Server web interface to support testing different email credentials during setup.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_EmailOptions} EmailOptions Updated configuration content
	 * @param {string} Recipient Target email address to send test email
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaSendTestEmailP(EmailOptions: libcomet_EmailOptions, Recipient: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["EmailOptions"] = JSON.stringify(EmailOptions);
		params["Recipient"] = Recipient;
		return await this._requestP("api/v1/admin/meta/send-test-email", params);
	}

	/**
	 * AdminMetaSendTestReport
	 * Send a test admin email report
	 * This allows a user to send a test email report
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {libcomet_EmailReportingOption} EmailReportingOption Test email reporting option for sending
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaSendTestReportP(EmailReportingOption: libcomet_EmailReportingOption): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["EmailReportingOption"] = JSON.stringify(EmailReportingOption);
		return await this._requestP("api/v1/admin/meta/send-test-report", params);
	}

	/**
	 * AdminMetaServerConfigGet
	 * Get server configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<libcomet_ServerConfigOptions>}
	 */
	async AdminMetaServerConfigGetP(): Promise<libcomet_ServerConfigOptions> {
		return await this._requestP("api/v1/admin/meta/server-config/get", {});
	}

	/**
	 * AdminMetaServerConfigNetworkInterfaces
	 * List the available network interfaces on the PC running Comet Server
	 * Any IPv6 addresses are listed in compressed form without square-brackets.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<string[]>}
	 */
	async AdminMetaServerConfigNetworkInterfacesP(): Promise<string[]> {
		return await this._requestP("api/v1/admin/meta/server-config/network-interfaces", {});
	}

	/**
	 * AdminMetaServerConfigSet
	 * Set server configuration
	 * The Comet Server process will exit. The service manager should restart the server automatically.
	 *
	 * Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it returns a successful response before shutting down.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {libcomet_ServerConfigOptions} Config Updated configuration content
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaServerConfigSetP(Config: libcomet_ServerConfigOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Config"] = JSON.stringify(Config);
		return await this._requestP("api/v1/admin/meta/server-config/set", params);
	}

	/**
	 * AdminMetaShutdownService
	 * Shut down server
	 * The Comet Server process will exit.
	 *
	 * Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it returns a successful response before shutting down.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaShutdownServiceP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/admin/meta/shutdown-service", {});
	}

	/**
	 * AdminMetaSoftwareUpdateNews
	 * Get software update news from the software provider
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<libcomet_SoftwareUpdateNewsResponse>}
	 */
	async AdminMetaSoftwareUpdateNewsP(): Promise<libcomet_SoftwareUpdateNewsResponse> {
		return await this._requestP("api/v1/admin/meta/software-update-news", {});
	}

	/**
	 * AdminMetaStats
	 * Get Comet Server historical statistics
	 * The returned key-value map is not necessarily ordered. Client-side code should sort the result before display.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @param {boolean} Simple Remove redundant statistics
	 * @return {Promise<{[k: number]: libcomet_StatResult}>}
	 */
	async AdminMetaStatsP(Simple: boolean): Promise<{[k: number]: libcomet_StatResult}> {
		const params: { [s: string]: string; } = {};
		params["Simple"] = (Simple ? "1" : "0");
		return await this._requestP("api/v1/admin/meta/stats", params);
	}

	/**
	 * AdminMetaVersion
	 * Get server properties
	 * Retrieve the version number and basic properties about the server.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 *
	 * @return {Promise<libcomet_ServerMetaVersionInfo>}
	 */
	async AdminMetaVersionP(): Promise<libcomet_ServerMetaVersionInfo> {
		return await this._requestP("api/v1/admin/meta/version", {});
	}

	/**
	 * AdminMetaWebhookOptionsGet
	 * Get the server webhook configuration
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @return {Promise<{[k: string]: libcomet_WebhookOption}>}
	 */
	async AdminMetaWebhookOptionsGetP(): Promise<{[k: string]: libcomet_WebhookOption}> {
		return await this._requestP("api/v1/admin/meta/webhook-options/get", {});
	}

	/**
	 * AdminMetaWebhookOptionsSet
	 * Update the server webhook configuration
	 * Calling this endpoint will interrupt any messages currently queued for existing webhook destinations.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 *
	 * @param {{[k: string]: libcomet_WebhookOption}} WebhookOptions The replacement webhook target options.
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminMetaWebhookOptionsSetP(WebhookOptions: {[k: string]: libcomet_WebhookOption}): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["WebhookOptions"] = JSON.stringify(WebhookOptions);
		return await this._requestP("api/v1/admin/meta/webhook-options/set", params);
	}

	/**
	 * AdminNewsGetAll
	 * Get News entries (Admin)
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: libcomet_NewsEntry}>}
	 */
	async AdminNewsGetAllP(): Promise<{[k: string]: libcomet_NewsEntry}> {
		return await this._requestP("api/v1/admin/news/get-all", {});
	}

	/**
	 * AdminNewsRemove
	 * Remove news item
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} NewsItem Selected news item GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminNewsRemoveP(NewsItem: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["NewsItem"] = NewsItem;
		return await this._requestP("api/v1/admin/news/remove", params);
	}

	/**
	 * AdminNewsSubmit
	 * Submit news item
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} NewsContent Content of news item
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminNewsSubmitP(NewsContent: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["NewsContent"] = NewsContent;
		return await this._requestP("api/v1/admin/news/submit", params);
	}

	/**
	 * AdminOrganizationDelete
	 * Delete an organization and all related users
	 *
	 * Prior to Comet 22.6.0, this API was documented as returning the OrganizationResponse type. However, it always has returned only a CometAPIResponseMessage.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {string|null} OrganizationID (No description available)
	 * @param {libcomet_UninstallConfig|null} UninstallConfig Uninstall software configuration
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminOrganizationDeleteP(OrganizationID: string|null = null, UninstallConfig: libcomet_UninstallConfig|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		if (OrganizationID !== null) {
			params["OrganizationID"] = OrganizationID;
		}
		if (UninstallConfig !== null) {
			params["UninstallConfig"] = JSON.stringify(UninstallConfig);
		}
		return await this._requestP("api/v1/admin/organization/delete", params);
	}

	/**
	 * AdminOrganizationExport
	 * Run self-backup for a specific tenant
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {libcomet_SelfBackupExportOptions} Options The export config options
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminOrganizationExportP(Options: libcomet_SelfBackupExportOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Options"] = JSON.stringify(Options);
		return await this._requestP("api/v1/admin/organization/export", params);
	}

	/**
	 * AdminOrganizationList
	 * List Organizations
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<{[k: string]: libcomet_Organization}>}
	 */
	async AdminOrganizationListP(): Promise<{[k: string]: libcomet_Organization}> {
		return await this._requestP("api/v1/admin/organization/list", {});
	}

	/**
	 * AdminOrganizationSet
	 * Create or Update an Organization
	 *
	 * Prior to Comet 22.6.0, the 'ID' and 'Organization' fields were not present in the response.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {string|null} OrganizationID (No description available)
	 * @param {libcomet_Organization|null} Organization (No description available)
	 * @return {Promise<libcomet_OrganizationResponse>}
	 */
	async AdminOrganizationSetP(OrganizationID: string|null = null, Organization: libcomet_Organization|null = null): Promise<libcomet_OrganizationResponse> {
		const params: { [s: string]: string; } = {};
		if (OrganizationID !== null) {
			params["OrganizationID"] = OrganizationID;
		}
		if (Organization !== null) {
			params["Organization"] = JSON.stringify(Organization);
		}
		return await this._requestP("api/v1/admin/organization/set", params);
	}

	/**
	 * AdminPoliciesDelete
	 * Delete an existing policy object
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} PolicyID The policy ID to update or create
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminPoliciesDeleteP(PolicyID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["PolicyID"] = PolicyID;
		return await this._requestP("api/v1/admin/policies/delete", params);
	}

	/**
	 * AdminPoliciesGet
	 * Retrieve a single policy object
	 * A hash is also returned, to allow atomic modification operations.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} PolicyID The policy ID to retrieve
	 * @return {Promise<libcomet_GetGroupPolicyResponse>}
	 */
	async AdminPoliciesGetP(PolicyID: string): Promise<libcomet_GetGroupPolicyResponse> {
		const params: { [s: string]: string; } = {};
		params["PolicyID"] = PolicyID;
		return await this._requestP("api/v1/admin/policies/get", params);
	}

	/**
	 * AdminPoliciesList
	 * List all policy object names
	 * For the top-level organization, the API result includes all policies for all organizations, unless the TargetOrganization parameter is present.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string|null} TargetOrganization If present, list the policies belonging to another organization. Only allowed for administrator accounts in the top-level organization. (>= 22.3.7)
	 * @return {Promise<{[k: string]: string}>}
	 */
	async AdminPoliciesListP(TargetOrganization: string|null = null): Promise<{[k: string]: string}> {
		const params: { [s: string]: string; } = {};
		if (TargetOrganization !== null) {
			params["TargetOrganization"] = TargetOrganization;
		}
		return await this._requestP("api/v1/admin/policies/list", params);
	}

	/**
	 * AdminPoliciesListFull
	 * Get all policy objects
	 * For the top-level organization, the API result includes all policies for all organizations, unless the TargetOrganization parameter is present.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string|null} TargetOrganization If present, list the policies belonging to another organization. Only allowed for administrator accounts in the top-level organization. (>= 22.3.7)
	 * @return {Promise<{[k: string]: libcomet_GroupPolicy}>}
	 */
	async AdminPoliciesListFullP(TargetOrganization: string|null = null): Promise<{[k: string]: libcomet_GroupPolicy}> {
		const params: { [s: string]: string; } = {};
		if (TargetOrganization !== null) {
			params["TargetOrganization"] = TargetOrganization;
		}
		return await this._requestP("api/v1/admin/policies/list-full", params);
	}

	/**
	 * AdminPoliciesNew
	 * Create a new policy object
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {libcomet_GroupPolicy} Policy The policy data
	 * @return {Promise<libcomet_CreateGroupPolicyResponse>}
	 */
	async AdminPoliciesNewP(Policy: libcomet_GroupPolicy): Promise<libcomet_CreateGroupPolicyResponse> {
		const params: { [s: string]: string; } = {};
		params["Policy"] = JSON.stringify(Policy);
		return await this._requestP("api/v1/admin/policies/new", params);
	}

	/**
	 * AdminPoliciesSet
	 * Update an existing policy object
	 * An optional hash may be used, to ensure the modification was atomic.
	 * This API can also be used to create a new policy object with a specific hash.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} PolicyID The policy ID to update or create
	 * @param {libcomet_GroupPolicy} Policy The policy data
	 * @param {string|null} CheckPolicyHash An atomic verification hash as supplied by the AdminPoliciesGet API
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminPoliciesSetP(PolicyID: string, Policy: libcomet_GroupPolicy, CheckPolicyHash: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["PolicyID"] = PolicyID;
		params["Policy"] = JSON.stringify(Policy);
		if (CheckPolicyHash !== null) {
			params["CheckPolicyHash"] = CheckPolicyHash;
		}
		return await this._requestP("api/v1/admin/policies/set", params);
	}

	/**
	 * AdminPreviewUserEmailReport
	 * Preview an email report for a customer
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {libcomet_EmailReportConfig} EmailReportConfig Email report configuration to preview
	 * @param {string|null} EmailAddress Email address that may be included in the report body (>= 20.3.3)
	 * @return {Promise<libcomet_EmailReportGeneratedPreview>}
	 */
	async AdminPreviewUserEmailReportP(TargetUser: string, EmailReportConfig: libcomet_EmailReportConfig, EmailAddress: string|null = null): Promise<libcomet_EmailReportGeneratedPreview> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["EmailReportConfig"] = JSON.stringify(EmailReportConfig);
		if (EmailAddress !== null) {
			params["EmailAddress"] = EmailAddress;
		}
		return await this._requestP("api/v1/admin/preview-user-email-report", params);
	}

	/**
	 * AdminReplicationState
	 * Get Replication status
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<libcomet_ReplicatorStateAPIResponse[]>}
	 */
	async AdminReplicationStateP(): Promise<libcomet_ReplicatorStateAPIResponse[]> {
		return await this._requestP("api/v1/admin/replication/state", {});
	}

	/**
	 * AdminRequestStorageVault
	 * Request a new Storage Vault on behalf of a user
	 * This action does not respect the "Prevent creating new Storage Vaults (via Request)" policy setting. New Storage Vaults can be requested regardless of the policy setting.
	 * Prior to Comet 19.8.0, the response type was CometAPIResponseMessage (i.e. no DestinationID field in response).
	 * The StorageProvider must exist for the target user account's organization.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser The user to receive the new Storage Vault
	 * @param {string} StorageProvider ID for the storage template destination
	 * @param {string|null} SelfAddress The external URL for this server. Used to resolve conflicts
	 * @return {Promise<libcomet_RequestStorageVaultResponseMessage>}
	 */
	async AdminRequestStorageVaultP(TargetUser: string, StorageProvider: string, SelfAddress: string|null = null): Promise<libcomet_RequestStorageVaultResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["StorageProvider"] = StorageProvider;
		if (SelfAddress === null) {
			params["SelfAddress"] = this._server_url;
		} else {
			params["SelfAddress"] = SelfAddress;
		}
		return await this._requestP("api/v1/admin/request-storage-vault", params);
	}

	/**
	 * AdminRequestStorageVaultProviders
	 * Get the available options for Requesting a Storage Vault
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string|null} TargetOrganization If present, list the storage template options belonging to another organization. Only allowed for administrator accounts in the top-level organization. (>= 22.3.7)
	 * @return {Promise<{[k: string]: string}>}
	 */
	async AdminRequestStorageVaultProvidersP(TargetOrganization: string|null = null): Promise<{[k: string]: string}> {
		const params: { [s: string]: string; } = {};
		if (TargetOrganization !== null) {
			params["TargetOrganization"] = TargetOrganization;
		}
		return await this._requestP("api/v1/admin/request-storage-vault-providers", params);
	}

	/**
	 * AdminResetUserPassword
	 * Reset user account password
	 * The user account must have a recovery code present. A new replacement recovery code will be generated automatically.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {string} NewPassword New account password
	 * @param {string|null} OldPassword Old account password. Required if no recovery code is present for the user account.
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminResetUserPasswordP(TargetUser: string, NewPassword: string, OldPassword: string|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["NewPassword"] = NewPassword;
		if (OldPassword !== null) {
			params["OldPassword"] = OldPassword;
		}
		return await this._requestP("api/v1/admin/reset-user-password", params);
	}

	/**
	 * AdminRevokeDevice
	 * Revoke device from user account
	 * It's possible to simply remove the Device section from the user's profile, however, using this dedicated API will also gracefully handle live connections.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {string} TargetDevice Selected Device ID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminRevokeDeviceP(TargetUser: string, TargetDevice: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["TargetDevice"] = TargetDevice;
		return await this._requestP("api/v1/admin/revoke-device", params);
	}

	/**
	 * AdminSelfBackupStart
	 * Run self-backup on all targets
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminSelfBackupStartP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/admin/self-backup/start", {});
	}

	/**
	 * AdminSetUserProfile
	 * Modify user account profile
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {libcomet_UserProfileConfig} ProfileData Modified user profile
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminSetUserProfileP(TargetUser: string, ProfileData: libcomet_UserProfileConfig): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["ProfileData"] = JSON.stringify(ProfileData);
		return await this._requestP("api/v1/admin/set-user-profile", params);
	}

	/**
	 * AdminSetUserProfileHash
	 * Modify user account profile (atomic)
	 * The hash parameter can be determined from the corresponding API, to atomically ensure that no changes occur between get/set operations.
	 * The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve current hash values.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetUser Selected account username
	 * @param {libcomet_UserProfileConfig} ProfileData Modified user profile
	 * @param {string} RequireHash Previous hash parameter
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminSetUserProfileHashP(TargetUser: string, ProfileData: libcomet_UserProfileConfig, RequireHash: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetUser"] = TargetUser;
		params["ProfileData"] = JSON.stringify(ProfileData);
		params["RequireHash"] = RequireHash;
		return await this._requestP("api/v1/admin/set-user-profile-hash", params);
	}

	/**
	 * AdminStorageBucketProperties
	 * Retrieve properties for a single bucket
	 * This API can also be used to refresh the size measurement for a single bucket by passing a valid AfterTimestamp parameter.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Storage Role to be enabled.
	 *
	 * @param {string} BucketID Bucket ID
	 * @param {number|null} AfterTimestamp Allow a stale size measurement if it is at least as new as the supplied Unix timestamp. Timestamps in the future may produce a result clamped down to the Comet Server's current time. If not present, the size measurement may be arbitrarily stale.
	 * @return {Promise<libcomet_BucketProperties>}
	 */
	async AdminStorageBucketPropertiesP(BucketID: string, AfterTimestamp: number|null = null): Promise<libcomet_BucketProperties> {
		const params: { [s: string]: string; } = {};
		params["BucketID"] = BucketID;
		if (AfterTimestamp !== null) {
			params["AfterTimestamp"] = ""+AfterTimestamp;
		}
		return await this._requestP("api/v1/admin/storage/bucket-properties", params);
	}

	/**
	 * AdminStorageDeleteBucket
	 * Delete a bucket
	 * All data will be removed from the server. Misuse can cause data loss!
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Storage Role to be enabled.
	 *
	 * @param {string} BucketID Selected bucket name
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminStorageDeleteBucketP(BucketID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["BucketID"] = BucketID;
		return await this._requestP("api/v1/admin/storage/delete-bucket", params);
	}

	/**
	 * AdminStorageFreeSpace
	 * Retrieve available space metrics
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API requires the Storage Role to be enabled.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {string|null} BucketID (This parameter is not used)
	 * @return {Promise<libcomet_StorageFreeSpaceInfo>}
	 */
	async AdminStorageFreeSpaceP(BucketID: string|null = null): Promise<libcomet_StorageFreeSpaceInfo> {
		const params: { [s: string]: string; } = {};
		if (BucketID !== null) {
			params["BucketID"] = BucketID;
		}
		return await this._requestP("api/v1/admin/storage/free-space", params);
	}

	/**
	 * AdminStorageListBuckets
	 * List all buckets
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Storage Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: libcomet_BucketProperties}>}
	 */
	async AdminStorageListBucketsP(): Promise<{[k: string]: libcomet_BucketProperties}> {
		return await this._requestP("api/v1/admin/storage/list-buckets", {});
	}

	/**
	 * AdminStoragePingDestination
	 * Ping a storage destination
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * Access to this API may be prevented on a per-administrator basis.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 *
	 * @param {libcomet_DestinationLocation} ExtraData The destination location settings
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminStoragePingDestinationP(ExtraData: libcomet_DestinationLocation): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["ExtraData"] = JSON.stringify(ExtraData);
		return await this._requestP("api/v1/admin/storage/ping-destination", params);
	}

	/**
	 * AdminStorageRegisterBucket
	 * Create a new bucket
	 * Leave the Set* parameters blank to generate a bucket with random credentials, or, supply a pre-hashed password for zero-knowledge operations.
	 * Any auto-generated credentials are returned in the response message.
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API requires the Storage Role to be enabled.
	 *
	 * @param {string|null} SetBucketValue Bucket ID
	 * @param {string|null} SetKeyHashFormat Bucket key hashing format
	 * @param {string|null} SetKeyHashValue Bucket key hash
	 * @param {string|null} SetOrganizationID Target organization ID (>= 20.9.0)
	 * @return {Promise<libcomet_AddBucketResponseMessage>}
	 */
	async AdminStorageRegisterBucketP(SetBucketValue: string|null = null, SetKeyHashFormat: string|null = null, SetKeyHashValue: string|null = null, SetOrganizationID: string|null = null): Promise<libcomet_AddBucketResponseMessage> {
		const params: { [s: string]: string; } = {};
		if (SetBucketValue !== null) {
			params["SetBucketValue"] = SetBucketValue;
		}
		if (SetKeyHashFormat !== null) {
			params["SetKeyHashFormat"] = SetKeyHashFormat;
		}
		if (SetKeyHashValue !== null) {
			params["SetKeyHashValue"] = SetKeyHashValue;
		}
		if (SetOrganizationID !== null) {
			params["SetOrganizationID"] = SetOrganizationID;
		}
		return await this._requestP("api/v1/admin/storage/register-bucket", params);
	}

	/**
	 * AdminUpdateCampaignStart
	 * Start a new software update campaign
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 * This API requires the Software Build Role to be enabled.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {libcomet_UpdateCampaignOptions} Options Configure targets for the software update campaign
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async AdminUpdateCampaignStartP(Options: libcomet_UpdateCampaignOptions): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["Options"] = JSON.stringify(Options);
		return await this._requestP("api/v1/admin/update-campaign/start", params);
	}

	/**
	 * AdminUpdateCampaignStatus
	 * Get current campaign status
	 *
	 * You must supply administrator authentication credentials to use this API.
	 * This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	 * This API requires the Software Build Role to be enabled.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_UpdateCampaignStatus>}
	 */
	async AdminUpdateCampaignStatusP(): Promise<libcomet_UpdateCampaignStatus> {
		return await this._requestP("api/v1/admin/update-campaign/status", {});
	}

	/**
	 * HybridSessionStart
	 * Generate a session key (log in)
	 * This hybrid API allows you to log in to the Comet Server as either an administrator or end-user account.
	 * This API behaves like either AdminAccountSessionStart or UserWebSessionStart, depending on what the supplied credentials were valid for.
	 *
	 * @return {Promise<libcomet_SessionKeyRegeneratedResponse>}
	 */
	async HybridSessionStartP(): Promise<libcomet_SessionKeyRegeneratedResponse> {
		return await this._requestP("api/v1/hybrid/session/start", {});
	}

	/**
	 * UserDispatcherEmailPreview
	 * Request HTML content of an email
	 * The remote device must have given consent for an MSP to browse their mail
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Snapshot where the email belongs to
	 * @param {string} Destination The Storage Vault ID
	 * @param {string} Path of the email to view
	 * @return {Promise<libcomet_EmailReportGeneratedPreview>}
	 */
	async UserDispatcherEmailPreviewP(TargetID: string, Snapshot: string, Destination: string, Path: string): Promise<libcomet_EmailReportGeneratedPreview> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Snapshot"] = Snapshot;
		params["Destination"] = Destination;
		params["Path"] = Path;
		return await this._requestP("api/v1/user/dispatcher/email-preview", params);
	}

	/**
	 * UserWebAccountRegenerateTotp
	 * Generate a new TOTP secret for user (web)
	 * The secret is returned as a `data-uri` image of a QR code. The new secret is immediately applied to the current admin account.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} ProfileHash Previous account profile hash
	 * @return {Promise<libcomet_TotpRegeneratedResponse>}
	 */
	async UserWebAccountRegenerateTotpP(ProfileHash: string): Promise<libcomet_TotpRegeneratedResponse> {
		const params: { [s: string]: string; } = {};
		params["ProfileHash"] = ProfileHash;
		return await this._requestP("api/v1/user/web/account/regenerate-totp", params);
	}

	/**
	 * UserWebAccountResetPassword
	 * Reset the password for your own user account (web)
	 * A new replacement recovery code will be generated if the present recovery code is not empty
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} ProfileHash Previous account profile hash
	 * @param {string} OldPassword Current account password
	 * @param {string} NewPassword New account password
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebAccountResetPasswordP(ProfileHash: string, OldPassword: string, NewPassword: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["ProfileHash"] = ProfileHash;
		params["OldPassword"] = OldPassword;
		params["NewPassword"] = NewPassword;
		return await this._requestP("api/v1/user/web/account/reset-password", params);
	}

	/**
	 * UserWebAccountValidateTotp
	 * Validate the TOTP code before turning 2fa(TOTP) on
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} ProfileHash Previous account profile hash
	 * @param {string} TOTPCode Six-digit code after scanning barcode image
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebAccountValidateTotpP(ProfileHash: string, TOTPCode: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["ProfileHash"] = ProfileHash;
		params["TOTPCode"] = TOTPCode;
		return await this._requestP("api/v1/user/web/account/validate-totp", params);
	}

	/**
	 * UserWebDispatcherDeleteSnapshot
	 * Instruct a live connected device to delete a stored snapshot
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} DestinationID The Storage Vault GUID
	 * @param {string} SnapshotID The backup job snapshot ID to delete
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherDeleteSnapshotP(TargetID: string, DestinationID: string, SnapshotID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["DestinationID"] = DestinationID;
		params["SnapshotID"] = SnapshotID;
		return await this._requestP("api/v1/user/web/dispatcher/delete-snapshot", params);
	}

	/**
	 * UserWebDispatcherDeleteSnapshots
	 * Instruct a live connected device to delete multiple stored snapshots
	 * The target device must be running Comet 20.9.10 or later.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} DestinationID The Storage Vault GUID
	 * @param {string[]} SnapshotIDs The backup job snapshot IDs to delete
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherDeleteSnapshotsP(TargetID: string, DestinationID: string, SnapshotIDs: string[]): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["DestinationID"] = DestinationID;
		params["SnapshotIDs"] = JSON.stringify(SnapshotIDs);
		return await this._requestP("api/v1/user/web/dispatcher/delete-snapshots", params);
	}

	/**
	 * UserWebDispatcherListActive
	 * List live connected devices in my account
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: libcomet_LiveUserConnection}>}
	 */
	async UserWebDispatcherListActiveP(): Promise<{[k: string]: libcomet_LiveUserConnection}> {
		return await this._requestP("api/v1/user/web/dispatcher/list-active", {});
	}

	/**
	 * UserWebDispatcherOffice365ListVirtualAccounts
	 * Request a list of Office365 Resources (groups, sites, teams groups and users)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_Office365Credential} Credentials The Office365 account credential
	 * @return {Promise<libcomet_BrowseOffice365ListVirtualAccountsResponse>}
	 */
	async UserWebDispatcherOffice365ListVirtualAccountsP(TargetID: string, Credentials: libcomet_Office365Credential): Promise<libcomet_BrowseOffice365ListVirtualAccountsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/user/web/dispatcher/office365-list-virtual-accounts", params);
	}

	/**
	 * UserWebDispatcherPingDestination
	 * Test the connection to the storage bucket
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_DestinationLocation} ExtraData The destination location settings
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherPingDestinationP(TargetID: string, ExtraData: libcomet_DestinationLocation): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["ExtraData"] = JSON.stringify(ExtraData);
		return await this._requestP("api/v1/user/web/dispatcher/ping-destination", params);
	}

	/**
	 * UserWebDispatcherRegisterOfficeApplicationBegin
	 * Begin the process of registering a new Azure AD application that can access Office 365 for backup
	 * After calling this API, you should supply the login details to the end-user, and then begin polling the AdminDispatcherRegisterOfficeApplicationCheck with the supplied "Continuation" parameter to check on the registration process.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} EmailAddress The email address of the Azure AD administrator
	 * @return {Promise<libcomet_RegisterOfficeApplicationBeginResponse>}
	 */
	async UserWebDispatcherRegisterOfficeApplicationBeginP(TargetID: string, EmailAddress: string): Promise<libcomet_RegisterOfficeApplicationBeginResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["EmailAddress"] = EmailAddress;
		return await this._requestP("api/v1/user/web/dispatcher/register-office-application/begin", params);
	}

	/**
	 * UserWebDispatcherRegisterOfficeApplicationCheck
	 * Check the process of registering a new Azure AD application that can access Office 365 for backup
	 * You should begin the process by calling AdminDispatcherRegisterOfficeApplicationBegin and asking the end-user to complete the Azure authentication steps.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Continuation The ID returned from the AdminDispatcherRegisterOfficeApplicationBegin endpoint
	 * @return {Promise<libcomet_RegisterOfficeApplicationCheckResponse>}
	 */
	async UserWebDispatcherRegisterOfficeApplicationCheckP(TargetID: string, Continuation: string): Promise<libcomet_RegisterOfficeApplicationCheckResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Continuation"] = Continuation;
		return await this._requestP("api/v1/user/web/dispatcher/register-office-application/check", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseDiskDrives
	 * Request a list of physical disk drive information from a live connected device
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseDiskDrivesResponse>}
	 */
	async UserWebDispatcherRequestBrowseDiskDrivesP(TargetID: string): Promise<libcomet_BrowseDiskDrivesResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-disk-drives", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseExchangeEdb
	 * Request a list of Exchange EDB databases from a live connected device
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseEDBResponse>}
	 */
	async UserWebDispatcherRequestBrowseExchangeEdbP(TargetID: string): Promise<libcomet_BrowseEDBResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-exchange-edb", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseHyperv
	 * Request a list of Hyper-V virtual machines from a live connected device
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseHVResponse>}
	 */
	async UserWebDispatcherRequestBrowseHypervP(TargetID: string): Promise<libcomet_BrowseHVResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-hyperv", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseMongodb
	 * Request a list of tables in MongoDB database
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_MongoDBConnection} Credentials The MongoDB database authentication settings
	 * @return {Promise<libcomet_BrowseSQLServerResponse>}
	 */
	async UserWebDispatcherRequestBrowseMongodbP(TargetID: string, Credentials: libcomet_MongoDBConnection): Promise<libcomet_BrowseSQLServerResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-mongodb", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseMssql
	 * Request a list of tables in MSSQL database
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_MSSQLConnection} Credentials The MSSQL database authentication settings
	 * @return {Promise<libcomet_BrowseSQLServerResponse>}
	 */
	async UserWebDispatcherRequestBrowseMssqlP(TargetID: string, Credentials: libcomet_MSSQLConnection): Promise<libcomet_BrowseSQLServerResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-mssql", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseMysql
	 * Request a list of tables in MySQL database
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_MySQLConnection} Credentials The MySQL database authentication settings
	 * @return {Promise<libcomet_BrowseSQLServerResponse>}
	 */
	async UserWebDispatcherRequestBrowseMysqlP(TargetID: string, Credentials: libcomet_MySQLConnection): Promise<libcomet_BrowseSQLServerResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-mysql", params);
	}

	/**
	 * UserWebDispatcherRequestBrowseVssAaw
	 * Request a list of installed VSS Writers (Application-Aware Writers) from a live connected device
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @return {Promise<libcomet_BrowseVSSResponse>}
	 */
	async UserWebDispatcherRequestBrowseVssAawP(TargetID: string): Promise<libcomet_BrowseVSSResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		return await this._requestP("api/v1/user/web/dispatcher/request-browse-vss-aaw", params);
	}

	/**
	 * UserWebDispatcherRequestOffice365Accounts
	 * Request a list of Office365 mailbox accounts
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_Office365Credential} Credentials The Office365 account credential
	 * @return {Promise<libcomet_BrowseOffice365ObjectsResponse>}
	 */
	async UserWebDispatcherRequestOffice365AccountsP(TargetID: string, Credentials: libcomet_Office365Credential): Promise<libcomet_BrowseOffice365ObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/user/web/dispatcher/request-office365-accounts", params);
	}

	/**
	 * UserWebDispatcherRequestOffice365Sites
	 * Request a list of Office365 sites
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {libcomet_Office365Credential} Credentials The Office365 account credential
	 * @return {Promise<libcomet_BrowseOffice365ObjectsResponse>}
	 */
	async UserWebDispatcherRequestOffice365SitesP(TargetID: string, Credentials: libcomet_Office365Credential): Promise<libcomet_BrowseOffice365ObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Credentials"] = JSON.stringify(Credentials);
		return await this._requestP("api/v1/user/web/dispatcher/request-office365-sites", params);
	}

	/**
	 * UserWebDispatcherRequestStoredObjects
	 * Request a list of stored objects inside an existing backup job
	 * The remote device must have given consent for an MSP to browse their files.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault ID
	 * @param {string} SnapshotID The selected backup job snapshot
	 * @param {string|null} TreeID Browse objects inside subdirectory of backup snapshot. If it is for VMDK single file restore, it should be the disk image's subtree ID.
	 * @param {libcomet_VMDKSnapshotViewOptions|null} Options Request a list of stored objects in vmdk file
	 * @return {Promise<libcomet_DispatcherStoredObjectsResponse>}
	 */
	async UserWebDispatcherRequestStoredObjectsP(TargetID: string, Destination: string, SnapshotID: string, TreeID: string|null = null, Options: libcomet_VMDKSnapshotViewOptions|null = null): Promise<libcomet_DispatcherStoredObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		params["SnapshotID"] = SnapshotID;
		if (TreeID !== null) {
			params["TreeID"] = TreeID;
		}
		if (Options !== null) {
			params["Options"] = JSON.stringify(Options);
		}
		return await this._requestP("api/v1/user/web/dispatcher/request-stored-objects", params);
	}

	/**
	 * UserWebDispatcherRequestVaultSnapshots
	 * Request a list of Storage Vault snapshots from a live connected device
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault ID
	 * @return {Promise<libcomet_DispatcherVaultSnapshotsResponse>}
	 */
	async UserWebDispatcherRequestVaultSnapshotsP(TargetID: string, Destination: string): Promise<libcomet_DispatcherVaultSnapshotsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		return await this._requestP("api/v1/user/web/dispatcher/request-vault-snapshots", params);
	}

	/**
	 * UserWebDispatcherRequestWindiskSnapshot
	 * Request a Disk Image snapshot with the windiskbrowse-style from a live connected device
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Destination The Storage Vault ID
	 * @param {string} SnapshotID The Snapshot ID
	 * @return {Promise<libcomet_DispatcherWindiskSnapshotResponse>}
	 */
	async UserWebDispatcherRequestWindiskSnapshotP(TargetID: string, Destination: string, SnapshotID: string): Promise<libcomet_DispatcherWindiskSnapshotResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Destination"] = Destination;
		params["SnapshotID"] = SnapshotID;
		return await this._requestP("api/v1/user/web/dispatcher/request-windisk-snapshot", params);
	}

	/**
	 * UserWebDispatcherRunBackup
	 * Instruct a live connected device in my account to run a scheduled backup
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} BackupRule The schedule GUID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherRunBackupP(TargetID: string, BackupRule: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["BackupRule"] = BackupRule;
		return await this._requestP("api/v1/user/web/dispatcher/run-backup", params);
	}

	/**
	 * UserWebDispatcherRunBackupCustom
	 * Instruct a live connected device to run a backup
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Source The Protected Item GUID
	 * @param {string} Destination The Storage Vault GUID
	 * @param {libcomet_BackupJobAdvancedOptions|null} Options Extra job parameters (>= 19.3.6)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherRunBackupCustomP(TargetID: string, Source: string, Destination: string, Options: libcomet_BackupJobAdvancedOptions|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Source"] = Source;
		params["Destination"] = Destination;
		if (Options !== null) {
			params["Options"] = JSON.stringify(Options);
		}
		return await this._requestP("api/v1/user/web/dispatcher/run-backup-custom", params);
	}

	/**
	 * UserWebDispatcherRunRestore
	 * Instruct a live connected device in my account to perform a local restore
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Path The local path to restore to
	 * @param {string} Source The Protected Item ID
	 * @param {string} Destination The Storage Vault ID
	 * @param {string|null} Snapshot If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the selected Protected Item + Storage Vault pair
	 * @param {string[]|null} Paths If present, restore these paths only. Otherwise, restore all data (>= 19.3.0)
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherRunRestoreP(TargetID: string, Path: string, Source: string, Destination: string, Snapshot: string|null = null, Paths: string[]|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Path"] = Path;
		params["Source"] = Source;
		params["Destination"] = Destination;
		if (Snapshot !== null) {
			params["Snapshot"] = Snapshot;
		}
		if (Paths !== null) {
			params["Paths"] = JSON.stringify(Paths);
		}
		return await this._requestP("api/v1/user/web/dispatcher/run-restore", params);
	}

	/**
	 * UserWebDispatcherRunRestoreCustom
	 * Instruct a live connected device in my account to perform a local restore
	 * This command is understood by Comet Backup 18.6.0 and newer.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} Source The Protected Item ID
	 * @param {string} Destination The Storage Vault ID
	 * @param {libcomet_RestoreJobAdvancedOptions} Options Restore targets
	 * @param {string|null} Snapshot If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the selected Protected Item + Storage Vault pair
	 * @param {string[]|null} Paths If present, restore these paths only. Otherwise, restore all data (>= 19.3.0)
	 * @param {number|null} KnownFileCount The number of files to restore, if known. Supplying this means we don't need to walk the entire tree just to find the file count and will speed up the restoration process.
	 * @param {number|null} KnownByteCount The total size in bytes of files to restore, if known. Supplying this means we don't need to walk the entire tree just to find the total file size and will speed up the restoration process.
	 * @param {number|null} KnownDirCount The number of directories to restore, if known. Supplying this means we don't need to walk the entire tree just to find the number of directories and will speed up the restoration process.
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebDispatcherRunRestoreCustomP(TargetID: string, Source: string, Destination: string, Options: libcomet_RestoreJobAdvancedOptions, Snapshot: string|null = null, Paths: string[]|null = null, KnownFileCount: number|null = null, KnownByteCount: number|null = null, KnownDirCount: number|null = null): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["Source"] = Source;
		params["Destination"] = Destination;
		params["Options"] = JSON.stringify(Options);
		if (Snapshot !== null) {
			params["Snapshot"] = Snapshot;
		}
		if (Paths !== null) {
			params["Paths"] = JSON.stringify(Paths);
		}
		if (KnownFileCount !== null) {
			params["KnownFileCount"] = ""+KnownFileCount;
		}
		if (KnownByteCount !== null) {
			params["KnownByteCount"] = ""+KnownByteCount;
		}
		if (KnownDirCount !== null) {
			params["KnownDirCount"] = ""+KnownDirCount;
		}
		return await this._requestP("api/v1/user/web/dispatcher/run-restore-custom", params);
	}

	/**
	 * UserWebDispatcherSearchSnapshots
	 * Search storage vault snapshots
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string} DestinationID The Storage Vault GUID
	 * @param {string[]} SnapshotIDs Snapshots to search
	 * @param {libcomet_SearchClause} Filter The search filter
	 * @return {Promise<libcomet_SearchSnapshotsResponse>}
	 */
	async UserWebDispatcherSearchSnapshotsP(TargetID: string, DestinationID: string, SnapshotIDs: string[], Filter: libcomet_SearchClause): Promise<libcomet_SearchSnapshotsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		params["DestinationID"] = DestinationID;
		params["SnapshotIDs"] = JSON.stringify(SnapshotIDs);
		params["Filter"] = JSON.stringify(Filter);
		return await this._requestP("api/v1/user/web/dispatcher/search-snapshots", params);
	}

	/**
	 * UserWebGetJobLog
	 * Get backup job report log, in plaintext format (Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Selected job GUID
	 * @return {Promise<string>}
	 */
	async UserWebGetJobLogP(JobID: string): Promise<string> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		return await this._requestP("api/v1/user/web/get-job-log", params);
	}

	/**
	 * UserWebGetJobLogEntries
	 * Get backup job report log (Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Selected job GUID
	 * @param {string|null} MinSeverity Return only job log entries with equal or higher severity
	 * @param {string|null} MessageContains Return only job log entries that contain exact string
	 * @return {Promise<libcomet_JobEntry[]>}
	 */
	async UserWebGetJobLogEntriesP(JobID: string, MinSeverity: string|null = null, MessageContains: string|null = null): Promise<libcomet_JobEntry[]> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		if (MinSeverity !== null) {
			params["MinSeverity"] = MinSeverity;
		}
		if (MessageContains !== null) {
			params["MessageContains"] = MessageContains;
		}
		return await this._requestP("api/v1/user/web/get-job-log-entries", params);
	}

	/**
	 * UserWebGetJobProperties
	 * Get backup job properties (Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Selected job GUID
	 * @return {Promise<libcomet_BackupJobDetail>}
	 */
	async UserWebGetJobPropertiesP(JobID: string): Promise<libcomet_BackupJobDetail> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		return await this._requestP("api/v1/user/web/get-job-properties", params);
	}

	/**
	 * UserWebGetJobs
	 * List all backup jobs (Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async UserWebGetJobsP(): Promise<libcomet_BackupJobDetail[]> {
		return await this._requestP("api/v1/user/web/get-jobs", {});
	}

	/**
	 * UserWebGetJobsForCustomSearch
	 * List all backup jobs (Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_BackupJobDetail[]>}
	 */
	async UserWebGetJobsForCustomSearchP(): Promise<libcomet_BackupJobDetail[]> {
		return await this._requestP("api/v1/user/web/get-jobs-for-custom-search", {});
	}

	/**
	 * UserWebGetUserProfileAndHash
	 * Get user account profile (atomic)
	 * (Web interface version)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_GetProfileAndHashResponseMessage>}
	 */
	async UserWebGetUserProfileAndHashP(): Promise<libcomet_GetProfileAndHashResponseMessage> {
		return await this._requestP("api/v1/user/web/get-user-profile-and-hash", {});
	}

	/**
	 * UserWebJobCancel
	 * Cancel a running job
	 * A request is sent to the live-connected device, asking it to cancel the operation. This may fail if there is no live-connection.
	 * Only jobs from Comet 18.3.5 or newer can be cancelled. A job can only be cancelled if it has a non-empty CancellationID field in its properties.
	 * If the device is running Comet 21.9.5 or later, this API will wait up to ten seconds for a confirmation from the client.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} JobID Job ID
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebJobCancelP(JobID: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["JobID"] = JobID;
		return await this._requestP("api/v1/user/web/job/cancel", params);
	}

	/**
	 * UserWebNewsGetAll
	 * Get News entries (Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: libcomet_NewsEntry}>}
	 */
	async UserWebNewsGetAllP(): Promise<{[k: string]: libcomet_NewsEntry}> {
		return await this._requestP("api/v1/user/web/news/get-all", {});
	}

	/**
	 * UserWebRequestFilesystemObjects
	 * Request a list of filesystem objects from the device
	 * The device must have granted the administrator permission to view its filenames.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} TargetID The live connection GUID
	 * @param {string|null} Path Browse objects inside this path. If empty or not present, returns the top-level device paths
	 * @return {Promise<libcomet_DispatcherStoredObjectsResponse>}
	 */
	async UserWebRequestFilesystemObjectsP(TargetID: string, Path: string|null = null): Promise<libcomet_DispatcherStoredObjectsResponse> {
		const params: { [s: string]: string; } = {};
		params["TargetID"] = TargetID;
		if (Path !== null) {
			params["Path"] = Path;
		}
		return await this._requestP("api/v1/user/web/request-filesystem-objects", params);
	}

	/**
	 * UserWebRequestStorageVault
	 * Request a new Storage Vault (Web)
	 * This action can be prevented via policy.
	 * Prior to Comet 19.8.0, the response type was CometAPIResponseMessage (i.e. no DestinationID field in response).
	 * The StorageProvider must exist for the target user account's organization.
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {string} StorageProvider ID for the storage template destination
	 * @param {string|null} SelfAddress The external URL for this server. Used to resolve conflicts
	 * @return {Promise<libcomet_RequestStorageVaultResponseMessage>}
	 */
	async UserWebRequestStorageVaultP(StorageProvider: string, SelfAddress: string|null = null): Promise<libcomet_RequestStorageVaultResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["StorageProvider"] = StorageProvider;
		if (SelfAddress === null) {
			params["SelfAddress"] = this._server_url;
		} else {
			params["SelfAddress"] = SelfAddress;
		}
		return await this._requestP("api/v1/user/web/request-storage-vault", params);
	}

	/**
	 * UserWebRequestStorageVaultProviders
	 * Get the available options for Requesting a Storage Vault (User Web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<{[k: string]: string}>}
	 */
	async UserWebRequestStorageVaultProvidersP(): Promise<{[k: string]: string}> {
		return await this._requestP("api/v1/user/web/request-storage-vault-providers", {});
	}

	/**
	 * UserWebSessionRevoke
	 * Revoke a session key (log out)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebSessionRevokeP(): Promise<libcomet_CometAPIResponseMessage> {
		return await this._requestP("api/v1/user/web/session/revoke", {});
	}

	/**
	 * UserWebSessionStart
	 * Generate a session key (log in)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @return {Promise<libcomet_SessionKeyRegeneratedResponse>}
	 */
	async UserWebSessionStartP(): Promise<libcomet_SessionKeyRegeneratedResponse> {
		return await this._requestP("api/v1/user/web/session/start", {});
	}

	/**
	 * UserWebSetProfileHash
	 * Set account profile (atomic, web)
	 *
	 * You must supply user authentication credentials to use this API, and the user account must be authorized for web access.
	 * This API requires the Auth Role to be enabled.
	 *
	 * @param {libcomet_UserProfileConfig} ProfileData Updated account profile
	 * @param {string} ProfileHash Previous account profile hash
	 * @return {Promise<libcomet_CometAPIResponseMessage>}
	 */
	async UserWebSetProfileHashP(ProfileData: libcomet_UserProfileConfig, ProfileHash: string): Promise<libcomet_CometAPIResponseMessage> {
		const params: { [s: string]: string; } = {};
		params["ProfileData"] = JSON.stringify(ProfileData);
		params["ProfileHash"] = ProfileHash;
		return await this._requestP("api/v1/user/web/set-profile-hash", params);
	}

}

